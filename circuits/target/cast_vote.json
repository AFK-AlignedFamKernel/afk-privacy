{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":3008427631269568393,"abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"proposal_id","type":{"kind":"field"},"visibility":"public"},{"name":"vote","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_default","type":{"kind":"field"},"visibility":"public"},{"name":"leaf","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":254,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"67":{"source":"pub use crate::types::{Calculator, MembershipProver, Modifier, NonMembershipProver, SMT_Creator};\n\npub struct SparseMerkleTree<T> {\n    pub root: T,\n    pub leaf_hasher: fn([T; 3]) -> T,\n    pub hasher: fn([T; 2]) -> T,\n}\n\nimpl<T> SMT_Creator<T> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn default(root: T, leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self { root, leaf_hasher, hasher }\n    }\n\n    fn from(root: T, leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::default(root, leaf_hasher, hasher)\n    }\n\n    fn new(leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::from(T::default(), leaf_hasher, hasher)\n    }\n}\n\nimpl<T> MembershipProver<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn membership<let N: u32>(self, entry: (T, T), indexes: Field, hash_path: [T; N]) {\n        // membership proof: the root is calculated based on the entry, the siblings,\n        // and the path determined by the key of entry through consecutive hashing\n        assert(self.calculate_root(entry, indexes, hash_path) == self.root);\n    }\n}\n\nimpl<T> NonMembershipProver<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn non_membership<let N: u32>(self, matching_entry: (T, T), index: Field, siblings: [T; N]) {\n        if (self.root != T::default()) {\n            // non-membership proof: the root is calculated based on the matching_entry, the siblings\n            // and the path that is determined by the key of entry. This makes sure that matching_entry is in fact\n            // a matching entry for entry meaning that it shares the same first bits as path\n            let mut calculated_root = self.calculate_root(matching_entry, index, siblings);\n            assert(calculated_root == self.root);\n        }\n    }\n}\n\nimpl<T> Modifier<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn add<let N: u32>(&mut self, new_entry: (T, T), index: Field, hash_path: [T; N]) {\n        // if the root node is zero the first leaf is added to the tree in which case\n        // the new root equals H(k,v,T::default())\n        // otherwise the correctness of the old root is validated based on the siblings after which\n        // the new root is calculated and returned\n        if (self.root == T::default()) {\n            self.root = (self.leaf_hasher)([new_entry.0, new_entry.1, T::default()]);\n        } else {\n            let (old, new) = self.calculate_two_roots(new_entry, index, hash_path);\n            assert(old == self.root);\n            self.root = new;\n        }\n    }\n\n    fn delete<let N: u32>(&mut self, entry: (T, T), indexes: Field, hash_path: [T; N]) {\n        // proves membership of entry in the old root, then calculates and returns the new root\n        let (new, old) = self.calculate_two_roots(entry, indexes, hash_path);\n\n        assert(old == self.root);\n        self.root = new;\n    }\n\n    fn update<let N: u32>(\n        &mut self,\n        new_value: (T, T),\n        old_value: (T, T),\n        index: Field,\n        hash_path: [T; N],\n    ) {\n        let key = index;\n        // both the old entry and new entry share the same key that is used to calculate the path\n        let path: [u1; N] = key.to_be_bits();\n\n        // old_parent is a container to temporarily store the nodes that ultimately lead to the OLD root\n        let mut old_parent = (self.leaf_hasher)([old_value.0, old_value.1, T::default()]);\n        // new_parent is a container to temporarily store the nodes that ultimately lead to the NEW root\n        let mut new_parent = (self.leaf_hasher)([new_value.0, new_value.1, T::default()]);\n        // starting from the bottom of the tree, for each level it checks whether there is a sibling and if\n        // that is the case, it hashes the two containers with the sibling and updates the containers with the\n        // resulting hashes until the uppermost level is reached aka the root node\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if sibling != T::default() {\n                if path[i] != 0 {\n                    new_parent = (self.hasher)([sibling, new_parent]);\n                    old_parent = (self.hasher)([sibling, old_parent]);\n                } else {\n                    new_parent = (self.hasher)([new_parent, sibling]);\n                    old_parent = (self.hasher)([old_parent, sibling]);\n                }\n            }\n        }\n        assert(old_parent == self.root);\n        self.root = new_parent;\n    }\n}\n\nimpl<T> Calculator<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    /*\n     * Calculates the root for a given tree entry based on the passed array of siblings and the passed path.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @param path The position of the entry in the tree as represented by bits from bottom to top\n     * @returns The calculated root node\n     */\n    fn calculate_root<let N: u32>(self, entry: (T, T), indexes: Field, hash_path: [T; N]) -> T {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n\n        // serves as container for hashes and is initialized to be the leaf node\n        let mut node = (self.leaf_hasher)([entry.0, entry.1, T::default()]);\n        // iterates over the list of siblings until the first sibling is found\n        // arbitrarily assigns the sibling to be the left and the node to be the\n        // right element of the hashing pair unless the path indicates the opposite\n        // order in which case the order is changed. The new hash is stored in the container\n        // until the root node is reached and returned.\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if sibling != T::default() {\n                let mut left = sibling;\n                let mut right = node;\n                if index_bits[i] == 0 {\n                    left = node;\n                    right = sibling;\n                }\n                node = (self.hasher)([left, right]);\n            }\n        }\n        node\n    }\n\n    /*\n     * Calculates two roots for a given leaf entry based on the passed array of siblings: one root\n     * for if the leaf entry was included in the tree and one for if the leaf entry was not included\n     * in the tree. This is useful for efficiently proving the membership of leaf entries for a\n     * tree while simultaneously modifying the tree.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @returns Two root nodes: the first one doesn't include entry, the second does\n     */\n    fn calculate_two_roots<let N: u32>(\n        self,\n        entry: (T, T),\n        indexes: Field,\n        hash_path: [T; N],\n    ) -> (T, T) {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n\n        // root_with_leaf is a container for hashes to derive the root node for the tree that\n        // includes the entry\n        let mut root_with_leaf = (self.leaf_hasher)([entry.0, entry.1, T::default()]);\n        // root_without_leaf is a container for hashes to derive the root node for the tree that\n        // doesn't include the entry\n        let mut root_without_leaf = T::default();\n        // iterate over the levels of the tree from bottom to top\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            // After the first sibling is found, the processes are started to calculate the two root nodes.\n            // The calulcation of the root node that includes the entry is comparable to `calculate_root`.\n            // To calc the root node that doesn't include entry, the first sibling is put into the container\n            // and starting from each SUBSEQUENT iteration it is hashed with its sibling and the resulting hash\n            // again stored in the container until the root is reached\n            if sibling != T::default() {\n                if hash_path[i - 1] == T::default() {\n                    root_without_leaf = hash_path[i];\n                }\n\n                if index_bits[i] != 0 {\n                    root_with_leaf = (self.hasher)([sibling, root_with_leaf]);\n                    if (root_without_leaf != sibling) {\n                        root_without_leaf = (self.hasher)([sibling, root_without_leaf]);\n                    }\n                } else {\n                    root_with_leaf = (self.hasher)([root_with_leaf, sibling]);\n\n                    if (root_without_leaf != sibling) {\n                        root_without_leaf = (self.hasher)([root_without_leaf, sibling]);\n                    }\n                }\n            }\n        }\n\n        (root_without_leaf, root_with_leaf)\n    }\n}\n","path":"/home/msg-encrypted/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/merkle-trees-v0.0.1/packages/merkle-trees/src/sparse_merkle.nr"},"147":{"source":"use dep::std;\nuse std::hash::poseidon2::Poseidon2::hash;\nuse trees::merkle::MerkleTree;\nuse trees::{sparse_merkle::{SparseMerkleTree, Modifier}, types::{Calculator, MembershipProver, SMT_Creator}};\n\nfn hasher(leaves: [Field; 2]) -> Field {\n    hash(leaves, 2)\n}\n\nfn leaf_hasher(leaves: [Field; 3]) -> Field {\n    hash(leaves, 3)\n}\n\nfn main(\n    root: pub Field,\n    index: Field,\n    secret: Field,\n    proposal_id: pub Field,\n    vote: pub Field,\n    nullifier_default: pub Field,\n    leaf: [Field; 2],\n    siblings: [Field; 254],\n) -> pub Field {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n    let key = leaf[0];\n    let value = leaf[1];    \n    let entry = (key, value);\n    // let note_commitment = std::hash::pedersen_hash([secret]);\n    let nullifier = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n\n    // Calculate and verify root\n    // tree.membership(entry, key, siblings);\n   \n    let root_check = tree.calculate_root(entry, key, siblings);\n    assert(root_check == root);\n\n    // Verify nullifier\n    let computed_nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n    assert(computed_nullifier == nullifier);\n\n    // Return the commitment\n    std::hash::pedersen_hash([root, secret, proposal_id])\n}\n\n#[test]\nfn test_valid_sparse_merkle_tree_membership() {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // Create a simple tree structure\n    let key = 12345;\n    let value = 999;\n    let entry = (key, value);\n    \n    // Initialize tree\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n    \n    // Create siblings array with default values\n    let mut siblings = [0; 254];\n    \n    // Calculate leaf hash\n    let leaf_hash = hash3([key, value, 0]);\n    \n    // Calculate the first level sibling\n    siblings[0] = hash3([0, 0, 1]);\n    \n    // Calculate intermediate nodes\n    let mut current_hash = leaf_hash;\n    for i in 0..3 {  // We'll create a small subtree for testing\n        current_hash = hash2([current_hash, siblings[i]]);\n        if i + 1 < 3 {\n            siblings[i + 1] = hash2([0, 0]);  // Default sibling for next level\n        }\n    }\n    \n    // The final hash becomes our root\n    let root = current_hash;\n    \n    // Create vote parameters\n    let secret = 777;\n    let proposal_id = 1;\n    let vote = 1;\n    let leaf = [key, value];\n    \n    // Calculate nullifier\n    let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n    \n    // Execute the main circuit\n    let result = main(\n        root,\n        0,\n        secret,\n        proposal_id,\n        vote,\n        nullifier,\n        leaf,\n        siblings\n    );\n    \n    // Calculate expected output\n    let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n    assert(result == expected_output);\n}\n\n// #[test]\n// fn test_valid_sparse_merkle_tree_membership() {\n//     // let poseidon2 = std::hash::poseidon2::Poseidon2 {};\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n//     // Let's use a dummy key-value pair\n//     let key = 12345;\n//     let value = 999;\n//     let leaf = [key, value];\n\n//     // Build the SMT\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n//     let entry = (key, value);\n\n//     // NOTE: tree.insert() must happen **outside ZK circuit** (trusted setup)\n//     // let siblings = tree.add(entry, key);\n\n//  let commitment_0 = std::hash::pedersen_hash([1]);\n//     let commitment_1 = std::hash::pedersen_hash([2]);\n    \n//       let commitment_2 = std::hash::pedersen_hash([3]);\n//     let commitment_3 = std::hash::pedersen_hash([4]);\n\n//      let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     let vote = 1;\n//     let secret: Field = 1;\n//     let hash_path = [commitment_1, right_branch];\n//     let leaf = commitment_0;\n//     let mut siblings = [0; 254];\n//     siblings[0] = commitment_1;\n//     siblings[1] = right_branch;\n//     let root = tree.calculate_root(entry, key, siblings);\n\n//     // Create vote identity\n//     let secret = 777;\n//     let proposal_id = 1;\n//     let vote = 1;\n\n//     // Construct the nullifier (public) and return value\n//     let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n//     let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n//     // Now invoke the ZK function\n//     let result = main(\n//         root,\n//         0,\n//         secret,\n//         proposal_id,\n//         vote,\n//         nullifier,\n//         hash_path,\n//         siblings,\n//     );\n\n//     assert(result == expected_output);\n// }\n\n\n\n// // #[test]\n// fn test_valid_build_merkle_tree() {\n//     let commitment_0 = std::hash::pedersen_hash([1]);\n//     let commitment_1 = std::hash::pedersen_hash([2]);\n//     let commitment_2 = std::hash::pedersen_hash([3]);\n//     let commitment_3 = std::hash::pedersen_hash([4]);\n\n//     let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     let proposalId = 0;\n//     let vote = 1;\n//     let secret = 1;\n//     let index = 0;\n//     let hash_path = [commitment_1, right_branch];\n//     let leaf = commitment_0;\n//     let mut siblings = [0; 254];\n//     siblings[0] = commitment_1;\n//     siblings[1] = right_branch;\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n//     // Initialize the tree\n//     // let mut tree = MerkleTree::new(hash2);\n\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n//     let nullifier = main(\n//         root,\n//         index,\n//         hash_path,\n//         secret,\n//         proposalId,\n//         vote,\n//         proposalId,\n//         std::hash::pedersen_hash([secret, proposalId]),\n//         hash_path,\n//         siblings,\n//     );\n\n//     let expected_nullifier = std::hash::pedersen_hash([root, secret, proposalId]);\n\n//     std::println(\"Merkle Tree:\");\n//     std::println([root]);\n//     std::println([left_branch, right_branch]);\n//     std::println([commitment_0, commitment_1, commitment_2, commitment_3]);\n\n//     assert(nullifier == expected_nullifier);\n// }\n\n// fn main(root : pub Field, index : Field, hash_path : [Field; 2], secret: Field, priv_key: Field, proposalId: pub Field, vote: pub u8) -> pub Field {\n//     let note_commitment = std::hash::pedersen([priv_key, secret]);\n//     let nullifier = std::hash::pedersen([root, priv_key, proposalId]);\n\n//     let check_root = std::merkle::compute_merkle_root(note_commitment[0], index, hash_path);\n//     assert(root == check_root);\n\n//     // Originally contrained the vote to avoid front-running,\n//     // but including the vote as a public input is sufficient\n\n//     assert(vote <= 1);\n\n//     nullifier[0]\n// }\n\n// Helpers for getting note_commitments to build the merkle tree.\n// To view: nargo test --show-output\n\n// #[test]\n// fn test_build_merkle_tree() {\n//     let secret = 9;\n//     let commitment_0 = std::hash::pedersen_hash([0, secret]);\n//     let commitment_1 = std::hash::pedersen_hash([1, secret]);\n//     let commitment_2 = std::hash::pedersen_hash([2, secret]);\n//     let commitment_3 = std::hash::pedersen_hash([3, secret]);\n\n//     let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     std::println(\"Merkle Tree:\");\n//     std::println([root]);\n//     std::println([left_branch, right_branch]);\n//     std::println([commitment_0, commitment_1, commitment_2, commitment_3]);\n// }\n\n// #[test]\n// fn test_sparse_merkle_tree() {\n//     // Create hash functions for the tree\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n\n//     // Initialize the tree\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n//     // Create a leaf entry (commitment pair)\n//     let secret = 1;\n//     let value = 100;\n//     let entry = (secret, value);\n\n//     // Create proposal ID and hash path\n//     let proposal_id = 1;\n//     let hash_path = [secret, value];\n\n//     // Create siblings for the proof\n//     let mut siblings = [0; 254];\n\n//     // Calculate note commitment and root\n//     let note_commitment = std::hash::pedersen_hash([secret]);\n//     let root = std::merkle::compute_merkle_root(note_commitment, 0, hash_path);\n\n//     // Calculate nullifier as per main function\n//     let nullifier = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n//     // Test the main function with the same parameters as used in the original test\n//     let result = main(\n//         root, // root\n//         0, // index\n//         hash_path,\n//         secret,\n//         proposal_id,\n//         1, // vote\n//         proposal_id,\n//         nullifier,\n//         hash_path, // leaf\n//         siblings,\n//     );\n\n//     // The expected nullifier should match what we calculated\n//     assert(result == nullifier);\n// }\n","path":"/home/msg-encrypted/Documents/dev/privacy/afk-privacy/circuits/cast_vote/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_to_radix","directive_invert"]}