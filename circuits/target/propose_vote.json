{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":6698233902958185979,"abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"proposal_id","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_default","type":{"kind":"field"},"visibility":"public"},{"name":"leaf","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":254,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+2dBZwVZffHZ3YXNtilW0pRsZ1ne+1AUJCwOzYVuxtFscXG7sDALlQMVGwRxcBARezuzv85752RcZ2B4d7f4Z7nz30+n/O+6zAeTjzP73xn7gVdJ7XGdHSc08pSPxeQtSXLd/67XP//1/P/38tsmQKcLy8iXJDvlmY53165G6rtX/7Pbegf2pIVkhWRFZOVkLUjKyUrI2tP1oGsI1knss5kXci6knUj607Wg6wnWS+y3mRLkfUh60vWj6w/2QCypcmWIRtItizZcmTLkw0iW4FsRbKVyFYmW4VsVbLVyFYn88gMGSdSQVZJVkVWTVZDVktWR7YG2Zpka5GtTbYO2bpk65GtT7YB2YZkg8k2IhtCNpRsY7JNyIaRDSfblGwE2UiyUWSjyTYj25xsC7ItybYi25psG7JtybYj255sB7IdyXYi25lsF7JdyerJGsgayZrImslayHYj251sDNkeZHuS7UW2N9k+ZPuS7Ue2P9kBZAeSHUR2MNkhZIeSHUZ2ONkRZEeSHUU2luxosmPIxpEdS3Yc2Xiy48lOIDuR7CSyk8lOITuV7DSyCWSnk51BdibZWWRnk51Ddi7ZRLLzyM4nu4DsQrKLyC4mu4TsUrLLyC4nu4LsSrKryK4mu4bsWrJJZNeRXU92A9mNZJPJbiK7mewWslvJbiO7newOsjvJ7iK7m+wesilk95LdR3Y/2VSyB8geJHuI7GGyaWSPkD1K9hjZdLLHyZ4ge5LsKbKnyZ4he5bsObIZZM+TzSR7gexFsllkL5G9TPYK2atks8leI3ud7A2yN8nmkL1F9jbZO2Rzyd4lm0f2Htn7ZB+QfUj2EdnHZJ+QfUr2GdnnZF+QfUn2FdnXZN+QfUv2Hdn3ZD+Q/Uj2E9nPZL+Q/Ur2G9nvZH+Q/Un2F9nfZE4enX2yvDxfBPL9/2cRcFtdaxtxrTDiWlHEteKIayUR19pFXCuNuFYWca19xLUOEdc6RlzrFHGtc8S1LhHXukZc6xZxrXvEtR4R13pGXOsVca13xLWlIq71ibjWN+Jav4hr/SOuDYi4tnTEtWUirg2MuLZsxLXlIq4tH3FtUMS1FSKurRhxbaWIaytHXFsl4tqqEddWi7i2esQ1L+KaibhWHnGtIuJaZcS1qohr1RHXaiKu1UZcq4u4tkbEtTUjrq0VcW3tiGvrRFxbN+LaehHX1o+4tkHEtQ0jrg2OuLZRxLUhEdeGRlzbOOLaJhHXhkVcGx5xbdOIayMiro2MuDYq4troiGubRVzbPOLaFhHXtoy4tlXEta0jrm0TcW3biGvbRVzbPuLaDhHXdoy4tlPEtZ0jru0ScW3XiGv1EdcaIq41RlxrirjWHHGtJeLabhHXdo+4Nibi2h4R1/aMuLZXxLW9I67tE3Ft34hr+0Vc2z/i2gER1w6MuHZQxLWDI64dEnHt0Ihrh0VcOzzi2hER146MuHZUxLWxEdeOjrh2TMS1cRHXjo24dlzEtfER146PuHZCxLUTI66dFHHt5Ihrp0RcOzXi2mkR1yZEXDs94toZEdfOjLh2VsS1syOunRNx7dyIaxMjrp0Xce38iGsXRFy7MOLaRRHXLo64dknEtUsjrl0Wce3yiGtXRFy7MuLaVRHXro64dk3EtWsjrk2KuHZdxLXrI67dEHHtxohrkyOu3RRx7eaIa7dEXLs14tptEdduj7h2R8S1OyOu3RVx7e6Ia/dEXJsSce3eiGv3RVy7P+La1IhrD0RcezDi2kMR1x6OuDYt4tojEdcejbj2WMS16RHXHo+49kTEtScjrj0Vce3piGvPRFx7NuLacxHXZkRcez7i2syIay9EXHsx4tqsiGsvRVx7OeLaKxHXXo24Njvi2msR116PuPZGxLU3I67Nibj2VsS1tyOuvRNxbW7EtXcjrs2LuPZexLX3I659EHHtw4hrH0Vc+zji2icR1z6NuPZZxLXPI659EXHty4hrX0Vc+zri2jcR176NuPZdxLXvI679EHHtx4hrP0Vc+zni2i8R136NuPZbxLXfI679EXHtz4hrf0Vc+zvi2v9e2rW65kZcy/Ovhdff/v+v5/+/l9n614coFV51ZWVzTXmzqTD1XnldQ22VV1nVUF1rak1VbVVTeW1FRXNtZW1NXUNdjVdnKiuaTUtVXUWL74zfOWbqq7kltdrifDUV4nzVFeF8mWKYr2ZTAvPVaNrBfNWaUpgvz5ShfDV7pj3KV6NnOqB81XqmI8oXne1OIF/N5KszyFcj+eoC8lVLvrqCfLEWdsP4amZf3TG+GtlXD4yvWvbVE+Prf7OjF8RX8/989Yb4avyfr6Ugvmr/56sPxFdq1vZF+GpO+eqH8NWY8tUf4as25WsAwpfPJksDfDX5vpYB+GrwfQ0E+KrxfS2bua9yn7/Mcpn7MoGv5TP2VdsS+BqUua+GwNcKmfsKeNWsmLGvmn98rZSxr6p/fK2csS/zj69VMvVV+Q/fm1Uz9VUx39dqmfoy832tnqGv5qb5vrxMfc1/HjImQ19NIV/lGfpqCPmqyNBXTchXZWa+vNDzo6nKyFdTS9hXdWa+msK+ajLzVRf2VZuZr/DztqnLyFfjv3ytkZGv+n/5WjMjX9X/8rVWJr7K//V+wqydiS/zb1/rZOCrouXfvtbNxFfDv32tl4mvf7/PMetn4Ku8la8NMvDltfK1Yfq+vMZWvgZn4KvV+y+zUdq+alta+xqSvq+m1r6Gpu+rrrWvjdP31fp9odkkbV81//E1LG1fVf/xNTxtX+Y/vjZN01d1y3/er5oR6fpq/q+vken6avyvr1Hp+qr9r6/R6fr67/tos1mavqoifG2epq+KCF9bpOertiXC15Zp+op4f2+2Ss9XTZSvrdPzVRXla5v0fJkoX9um5as+6vMOs11avuoifW2flq+aSF87pOWrItLXjun4qo38fMjslI6vmmhfO6fjqyra1y7p+DLRvnZNw1d19Odppj4NX1UxvhrS8FUR46tx0X3VtMT4akrDV8znj6Z50X1Vx/lqWXRflXG+dlt0X16cr90X2VdF3Oe1Zswi+yqP9bXHIvvyYn3tuai+ahpjfe21yL5iP982ey+qr+p4X/ssqq/KeF/7LqovL97Xfovoqyn++wBm/0X01bgAXwcsoq/6Bfg6cBF9VS/A10GL5qt8Ad+fMAcvmi+zIF+HLJKv8pYF+Tp00Xw1LMjXYYvma0HfNzGHL5Ivs0BfRyyKr5qWBfo6cpF8NSzQ11GL5Ktigb7GLoqv6gX7OnpRfFUu2Ncxi+LLW7CvcYvgy9Qu2Nexi+DLW4iv45L7amxeiK/xi+CrfiG+jl8EX+UL8XVCcl8NC/N1YnJfdQvzdVJyX1UL83VyYl+VTQvzdUpiXxUL9XVqYl9mob5OS+qrpmmhviYk9lW1UF+nJ/VVvXBfZyT1VblwX2cm9eUt3NdZCX1V1i7c19kJfVUk8HVOQl8mga9zk/nymhL4mpjQV1UCX+cl8lXTksTX+cl8NSXxdUEyX3VJfF2YzJdJ4uuiRL6qE/m6OJGvykS+Lknky0vk69IkvrzaRL4uS+CrpiWZr8uT+GpK5uuKJL7qkvm6Mokvk8zXVQl8VSf0dXUCX5UJfV2TwJeX0Ne1C/dVVZvQ16SF+6pM6uu6hfsqT+rr+oX6qm9O6uuGhfuqTurrxoX6qkvsa/JCfdUk9nXTQn1VJPZ188J8VTYk9nXLwnxVJPd168J8meS+bluIr4qm5L5uX5ivquS+7liIr/JF8HXnQnx5i+DrrgX6qmxpXARfdy/EV+Ui+Lpnwb6aF8XXlAX7alwUX/cu2Fftovi6b8G+vEXxdf8CfVUskq+pC/RlFsnXAwvyVdO0SL4eXKCvqkXy9dCCfFUvmq+HF+SrctF8TVuQL2/RfD2yAF/1tYvm69EF+KpbRF+PLcBXzSL6mr4AXxWL6OvxeF+1DYvo64l4XzWL6uvJeF9Vi+rrqXhfZlF9PR3ry9Qtqq9nYn15i+zr2RhfdS3Ni+zruVhf9Yvsa0asr/JF9vV8nK/mRfc1M85X46L7eiHOV+2i+3oxzpe36L5mxfiqTcPXSzG+qtPw9XKMr/I0fL0S7curT8PXq5G+ylvS8TU72ldTOr5ei/ZVl46v16N9mXR8vRHpy6Tl680oX15LWr7mRPpqSMvXW5G+KtLy9XaEr6aW9Hy9E+WrKT1fc6N81aXn690oXyY9X/MifDWm6eu9CF/1afp6P8JXdZq+PvivL9Ocpq8P/+vLS9fXR//xVd2crq+P/+urPl1fn/zXV3m6vj79j6+qtH199h9fFWn7+ry1r6aWtH198R9fNWn7+rK1r8b0fX3V2ld9+r6+bu2rOn1f37TyVdGcvq9vW/kqz8DXd618eRn4+v7fvioaM/D1QytflRn4+vHfvsoz8fXTv315mfj6+V++qhoz8fXLv31VZuLr13/5qszI12//8lWeka/fQ77KW5oz8vXHv3xVZ+Trz7Cv5sx8/RX21ZiZr7/Dvmoz8+XkhXx5mflyQ75Mhr7yQr68DBf7cH1fIJ8m+I8I5LXyW5FZ3l4470x95eNqaJzQ0pxzAThnqX3jgmt4bQfZ84LYiwUCeU8C5x2sAsV7vA1wjwP3jQH2wkjsQRauNnnze7yk7Zu2uX2TVt2Yt9ouwfumMLdv0qobM3/hErxvinL7Jq268XNn0RK8b4pz+yatuvG7j+IleN+ULCH7Jljo5/DfXZyvdnm6zwrvlXYCz6OleTK9bn3uvMyWQZ67MqCv8LnT9m7Alj14nfK8+YyUCeR9vdC7oHxwnO2BGgHstbnekjn1G3BOdVA+p3ivdBA4Kx2F5hT6rHTKk9FFbVpjy765QXnevK87CeR9oyWzpTPwXAN7bW5U/uzM343onDe/Lzb0ukuu12nVjb9T08WyXnddQnodLDQz/gxkxm7KmZH3SjeBGdjdEmbskSfDO9oYwpZ9M1l53ryvewjkfZMlzNgTeK6BvTY3KecI/s5wT8s4oleu12nVjb9r3suyXvfO9TqtuvGfUehtWa+XWkJ6HSz088H3wOeDPsqfD3iv9BHgnb6WPB/0Az4fTAY+H9yknJOl9s3NyvPmfd1PIO9bLHk+6A8818Bem1uUcwT/Gcz+lnHEgFyv06ob/9ndAZb1euklpNfBQjPjN0BmXEY5M/JeWUZgBg60hBmXBTLjzUBmvEU5O0ntm1uV5837elmBvG+zhBmXA55rYK/NbZbMlq+Bs2V55bOF98ryAmdlkCWzZYU8GV3UpjW27JvblefN+3oFgbzvsGS2rAg818BemzssmS1fAWfLSspnC++VlQTOysqWzJZV8mR0UZvW2LJv7lSeN+/rVQTyvsuS2bIq8FwDe23uUv7+k/+ux1Xz5vfFhl6vlut1WnXjvyN0Nct6vfoS0utgoZnxcyAzesqZkfeKJzADjSXMWJ4nwzvaGMKWfXO38rx5X5cL5H2PJcxYATzXwF6beyyZLZ8BZ0ul8tnCe6VS4KxUWTJbqvNkdFGb1tiyb6Yoz5v3dbVA3vdaMltqgOca2GtzryWz5VPgbKlVPlt4r9QKnJU6S2bLGnkyuqhNa2zZN/cpz5v39RoCed9vyWxZE3iugb029yt//8n/Tak18+b3xYZer5XrdVp14/8W2VqW9XrtJaTXwUIz40dAZlxHOTPyXllHYAauawkzrpcnwzvaGMKWfTNVed7/29cCeT9gCTOuDzzXwF6bB5RzBP+3Vte3jCM2WEJ6HSw0R3wA5IgNlXME75UNBXRxsCUcsVGezAzUNlds2TcPKs+b9/VGAnk/ZAlHDAGea2CvzUOWzJb3gbNlqPLZwntlqMBZ2diS2bJJnowuatMaW/bNw8rz5n29iUDe0yyZLcOA5xrYazPNktnyHnC2DFc+W3ivDBc4K5taMltG5MnoojatsWXfPKI8b97XIwTyftSS2TISeK6BvTaPKn//OY8cjsyb3xcbej0q1+u06vYuORxlWa9H53qdVt3mksPRlvV6s1yv06rbO+RwM8t6vfkS0utgoZ8F3wY+C26h/FmQ98oWAmy7pSXPglsBnwUfAT4LPqr8mUhq3zymPG/e11sJ5D3dkmfBrYHnGthrM105R7xFDre2jCO2yfU6rbrNIYfbWNbrbZeQXgcLzYxvAplxO+XMyHtlO4EZuL0lzLhDngzvaGMIW/bN48rz5n29g0DeT1jCjDsCzzWw1+YJS2bLG8DZspPy2cJ7ZSeBs7KzJbNllzwZXdSmNbbsmyeV5837eheBvJ+yZLbsCjzXwF6bp5Q/o75ODnfNm98XG3pdn+t1WnV7jRzWW9brhlyv06rbbHLYYFmvG5eQXgcL/XzwKvD5oEn58wHvlSYB3mm25PmgBfh88CTw+eAp5ZwstW+eVp437+sWgbyfseT5YDfguQb22jxjyWx5BThbdlc+W3iv7C5wVsZYMlv2yJPRRW1aY8u+eVZ53ryv9xDI+zlLZsuewHMN7LV5Tvkz6svkcM+8+X2xodd7LSG9DhaaI14CcsTeyjmC98reArq4jyUcsW+ezAzUNlds2TczlOfN+3pfgbyft4Qj9gOea2CvzfPKOWIWOdzPMo7YP9frtOr2Ijnc37JeH5DrdVp1e4EcHmBZrw/M9Tqtus0khwda1uuDcr1Oj8fI4UGW9frgXK/Te+Yghwdb1utDcr1O77maHB5iWa8PXUJ6HSz0+7xnge/zDlP+Po/3ymEC7ycOz5PpNfqsHAF8nzcD+D7veeXvtaT2zUzlefO+PkIg7xcseZ93JPBcA3ttXlDOEc+QwyMt44ijlpBeBwvNEU8DOWKsco7gvTJWQBePtoQjjsmTmYHa5oot++ZF5Xnzvj5GIO9ZlnDEOOC5BvbazFLOEU+Rw3GWccSxuV6n92cYyOGxlvX6uCWk18FCM+MTQGYcr5wZea+MF5iBx1vCjCcAmfHFDnoZwpZ985LyvHlfnyCQ98uWMOOJwHMN7LV52ZLZ8jhwtpykfLbwXjlJ4KycbMlsOSVPRhe1aY0t++YV5Xnzvj5FIO9XLZktpwLPNbDX5lXlz6jTyeGpefP7YkOvT1tCeh0sNEc8BuSICco5gvfKBAFdPN0SjjgjT2YGapsrtuyb2crz5n19hkDer1nCEWcCzzWw1+Y1S2bLo8DZcpby2cJ75SyBs3K2JbPlnDwZXdSmNbbsm9eV5837+hyBvN+wZLacCzzXwF6bNyyZLY8AZ8tE5bOF98pEgbNyniWz5fw8GV3UpjW27Js3lefN+/p8gbznWDJbLgCea2CvzRzl7z+nkcML8ub3xYZeX5jrdVp1e5gcXmhZry/K9Tqtuj1EDi+yrNcX53qdVt0eJIcXW9brS5aQXgcL/Sz4APBZ8FLlz4K8Vy4VYNvLLHkWvBz4LPgm8FlwjvJnIql985byvHlfXy6Q99uWPAteATzXwF6bt5VzxFRyeIVlHHHlEtLrYKE54n4gR1ylnCN4r1wloItXW8IR1+TJzEBtc8WWffOO8rx5X18jkPdcSzjiWuC5BvbazFXOEfeRw2st44hJuV6nVbd7yeEky3p9Xa7XadVtCjm8zrJeX5/rdVp1u4ccXm9Zr2/I9Tqtut1NDm+wrNc3LiG9Dhb6uf8u4HP/ZOXP/bxXJgs8x9yUJ9Nr9Fm5Gfjc/w7wuX+u8udfqX3zrvK8eV/fLJD3PEue+28Bnmtgr8085RxxJzm8xTKOuDXX67Tqdgc5vNWyXt+W63VadbudHN5mWa9vX0J6HSz088FtwOeDO5Q/H/BeuUOAd+605PngLuDzwbvA54N5yjlZat+8pzxv3td3CeT9viXPB3cDzzWw1+Z95RxxKzm82zKOuGcJ6XWw0BxxC5AjpijnCN4rUwR08V5LOOK+PJkZqG2u2LJvPlCeN+/r+wTy/tASjrgfeK6BvTYfWjJbbgbOlqnKZwvvlakCZ+UBS2bLg3kyuqhNa2zZNx8pz5v39YMCeX9syWx5CHiugb02Hyt/Rr2JHD6UN78vNvT64SWk18FCc8RkIEdMU84RvFemCejiI5ZwxKN5MjNQ21yxZd98ojxv3tePCuT9qSUc8RjwXAN7bT61ZLbcCJwt05XPFt4r0wXOyuOWzJYn8mR0UZvW2LJvPlOeN+/rJwTy/tyS2fIk8FwDe20+V/6MegM5fDJvfl9s6PVTS0ivg4XmiOuBHPG0co7gvfK0gC4+YwlHPJsnMwO1zRVb9s0XyvPmff2sQN5fWsIRzwHPNbDX5ktLZst1wNkyQ/ls4b0yQ+CsPG/JbJmZJ6OL2rTGln3zlfK8eV/PFMj7a0tmywvAcw3stfla+TPqJHL4Qt78vtjQ6xeXkF4HC80R1wI5YpZyjuC9MktAF1+yhCNezpOZgdrmii375hvlefO+flkg728t4YhXgOca2GvzrXKOuIYcvmIZR7ya63VadbuaHL5qWa9n53qdVt2uIoezLev1a7lep1W3K8nha5b1+vVcr9Oq2xXk8HXLev1Grtdp1e1ycviGZb1+cwnpdbDQ73guA77jmaP8HQ/vlTkCz6xv5cn0Gn1W3ga+4/kG+I7nW+XvOqT2zXfK8+Z9/bZA3t9b8o7nHeC5BvbafG/JbLkUOFvmKp8tvFfmCpyVdy2ZLfPyZHRRm9bYsm9+UJ437+t5Ann/aMlseQ94roG9Nj8qf0a9hBy+lze/Lzb0+v1cr9Oq28Xk8H3Lev1Brtdp1e0icviBZb3+MNfrtOp2ITn80LJef5TrdVp1u4AcfmRZrz/O9Tqtup1PDj+2rNefLCG9Dhb6Hc95wHc8nyp/x8N75VOBZ9bP8mR6jT4rnwPf8fwAfMfzo/J3HVL75iflefO+/lwg758tecfzBfBcA3ttflbOERPJ4ReWccSXS0ivg4XmiHOBHPGVco7gvfKVgC5+bQlHfJMnMwO1zRVb9s0vyvPmff2NQN6/WsIR3wLPNbDX5lflHHEOOfzWMo74bgnpdbDQHHE2kCO+V84RvFe+F9DFHyzhiB/zZGagtrliy775TXnevK9/FMj7d0s44ifguQb22vxuyWw5CzhbflY+W3iv/CzxrGHJbPk1T0YXtWmNLfvmD+V5877+VSDvPy2ZLb8BzzWw1+ZP5c+oZ5LD3/Lm98WGXv+e63VadTuDHP5uWa//yPU6rbqdTg7/sKzXf+Z6nVbdJpDDPy3r9V9LSK+DhX4WPA34LPi38mdB3it/C7Atb2qJXqPPipsv8xyj7dnAln3zl/K8eQPynkH7/duSZ8E84LkG9tr8rZwjTiWHefnz+2JDr/OXkF4HC80RpwA5oiBf9/7mvVIgoIttLOGItvkyM1DbXLFl3zgddefN+7qtQN5uRztmSyHyXONyNsD6ic6Wk4GzpUj5bOG9UiRwVootmS0l+TK6qE1rbNk3ecrz5n1dIpB3viWzpR3wXAN7bfItmS0nAWdLqfLZwnulVOCslFkyW9rny+iiNq2xZd8UKM+b93V7ied8S2ZLB+C5BvbatOmoW2dPJIcdLHv/2XEJ6XWw0BxxApAjOinnCN4rnQR0sbMlHNElX2YGapsrtuybtsrz5n3dRSDvQks4oivwXAN7bQqVc8Tx5LCrZRzRLdfrtOo2nhx2s6zX3ZeQXgcLzYzHAZmxh3Jm5L3SQ2AG9rSEGXvly/CONoawZd8UKc+b93Uvic8BLWHG3sBzDey1KVbOEceSw96WccRSS0ivg4XmiHFAjuijnCN4r/QR0MW+lnBEv3yZGahtrtiyb0qU5837up9A3u0s4Yj+wHMN7LVpp5wjjiGH/S3jiAG5XqdVt6PJ4QDLer10rtdp1W0sOVzasl4vk+t1WnU7ihwuY1mvB+Z6nVbdjiSHAy3r9bJLSK+DhX7uPwL43L+c8ud+3ivLCTzHLG/Jc/8g4HN/CfC5v53y51+pfVOqPG/e14MkvuttyXP/CsBzDey1KbNkthwOnC0rKp8tvFdWFDgrK1kyW1bOl9FFbVpjy75przxv3tcrC+TdwZLZsgrwXAN7bToof0Y9jByuYtkz6qq5XqdVt0PJ4aqW9Xq1JaTXwUIz4yFAZlxdOTPyXlldYAZ6ljCjyZfhHW0MYcu+6ag8b97XRiDvTpYwYznwXAN7bTpZMlsOBs6WCuWzhfdKhcBZqbRktlTly+iiNq2xZd90Vp437+sqgby7WDJbqoHnGthr08WS2XIQcLbUKJ8tvFdqBM5KrSWzpS5fRhe1aY0t+6ar8rx5X9cJ5N3NktmyBvBcA3ttulkyWw4EzpY1lc8W3itrCpyVtSyZLWvny+iiNq2xZd90V5437+u1BfLuYclsWQd4roG9Nj0smS0HAGfLuspnC++VdQXOynqWzJb182V0UZvW2LJveirPm/f1+gJ597JktmwAPNfAXpteHXXr7P7kcAPLvrex4RLS62ChOWI/IEcMVs4RvFcGC+jiRpZwxJB8mRmoba7Ysm96K8+b9/UQgbyXsoQjhgLPNbDXZinlHLEvORxqGUdsnOt1WnXbhxxubFmvN8n1Oq267U0ON7Gs18NyvU6rbnuRw2GW9Xr4EtLrYKGfBfcEPgtuqvxZkPfKpgJsO8KSZ8GRwGfB3sBnwaWUPxNJ7Zs+yvPmfT1SIO++ljwLjgKea2CvTV/lHLEHORxlGUeMzvU6rbqNIYejLev1ZktIr4OFZsbdgcy4uXJm5L2yucAM3MISZtwyX4Z3tDGELfumn/K8eV9vKZB3f0uYcSvguQb22vRXzhG7kcOtLOOIrXO9TqtuLeRwa8t6vU2u12nVrZkcbmNZr7fN9TqtujWRw20t6/V2S0ivg4V+FmwEPgtur/xZkPfK9gJsu4Mlz4I7Ap8F+wGfBfsrfyaS2jcDlOfN+3pHgbyXtuRZcCfguQb22ixtyWxpAM6WnZXPFt4rOwuclV0smS275svoojatsWXfLKM8b97XuwrkPdCS2VIPPNfAXpuBlsyWeuBsaVA+W3ivNAiclUZLZktTvowuatMaW/bNssrz5n3dJJD3cpbMlmbguQb22ixnyWzZFThbWpTPFt4rLQJnZTdLZsvu+TK6qE1rbNk3yyvPm/f17gJ5D7JktowBnmtgr82gjrp1dhdyOMayz9b2yPU6vXeV5HAPy3q95xLS62ChmXEnIDPupZwZea/sJTAD97aEGffJl+EdbQxhy75ZQXnevK/3Ech7RUuYcV/guQb22qxoyWzZEThb9lM+W3iv7CdwVva3ZLYckC+ji9q0xpZ9s5LyvHlfHyCQ98qWzJYDgeca2GuzsvJn1B3I4YGWPaMetIT0OlhojtgeyBEHK+cI3isHC+jiIZZwxKH5MjNQ21yxZd+sojxv3teHCuS9qiUccRjwXAN7bVa1ZLZsB5wthyufLbxXDhc4K0dYMluOzJfRRW1aY8u+WU153ryvjxTIe3VLZstRwHMN7LVZ3ZLZsi1wtoxVPlt4r4wVOCtHWzJbjsmX0UVtWmPLvvGU5837+hiBvI0ls2Uc8FwDe21MR906uw05HGfZ+89jc71O7+/5IYfHWtbr45aQXgcLzYxbAZlxvHJm5L0yXmAGHm8JM56QL8M72hjCln1Trjxv3tcnCORdYQkzngg818BemwrlHLElOTzRMo44aQnpdbDQHLEFkCNOVs4RvFdOFtDFUyzhiFPzZWagtrliy76pVJ437+tTBfKusoQjTgOea2CvTZUls2Vz4GyZoHy28F6ZIHBWTrdktpyRL6OL2rTGln1TrTxv3tdnCORdY8lsORN4roG9NjWWzJbNgLPlLOWzhffKWQJn5WxLZss5+TK6qE1rbNk3tcrz5n19jkDedZbMlnOB5xrYa1PXUbfOjiaH51r2/nNirtdp1W0UOZxoWa/Py/U6rbqNJIfnWdbr83O9TqtuI8jh+Zb1+oIlpNfBQj8Lbgp8FrxQ+bMg75ULBdj2IkueBS8GPgvWAp8F65Q/E0ntmzWU5837+mKBvNe05FnwEuC5BvbarKmcI4aTw0ss44hLc71Oq27DyOGllvX6siWk18FCM+MmQGa8XDkz8l65XGAGXmEJM16ZL8M72hjCln2zlvK8eV9fKZD32pYw41XAcw3stVlbOUdsTA6vsowjrs71Oq26DSWHV1vW62tyvU6rbkPI4TWW9fraJaTXwUI/H2wEfD6YpPz5gPfKJAHeuc6S54Prgc8HawGfD9ZWzslS+2Yd5Xnzvr5eIO91LXk+uAF4roG9Nusq54jB5PAGyzjixiWk18FCc8SGQI6YrJwjeK9MFtDFmyzhiJvzZWagtrliy75ZT3nevK9vFsh7fUs44hbguQb22qyvnCM2IIe3WMYRt+Z6nd5ZJoe3Wtbr23K9Tm9ekcPbLOv17blep8dk5PB2y3p9xxLS62ChnwXXAT4L3qn8WZD3yp0CbHuXJc+CdwOfBdcDPguur/yZSGrfbKA8b97XdwvkvaElz4L3AM81sNdmQ0tmy9rA2TJF+WzhvTJF4Kzca8lsuS9fRhe1aY0t+2aw8rx5X98nkPdGlsyW+4HnGthrs5Els2Ut4GyZqny28F6ZKnBWHrBktjyYL6OL2rTGln0zRHnevK8fFMh7qCWz5SHguQb22gy1ZLasCZwtDyufLbxXHhY4K9MsmS2P5MvoojatsWXfbKw8b97XjwjkvYkls+VR4LkG9tpsYslsWQM4Wx5TPlt4rzwmcFamWzJbHs+X0UVtWmPLvhmmPG/e148L5D3cktnyBPBcA3tthnfUrbN15PAJy7638WSu1+n9/WDk8EnLev1Urtdp1a2GHD5lWa+fzvU6rbpVk8OnLev1M0tIr4OFfhasAj4LPqv8WZD3yrMCbPucJc+CM4DPgsOAz4LDlT8TSe2bTZXnzft6hkDeIyx5FnweeK6BvTYjLJktlcDZMlP5bOG9MlPgrLxgyWx5MV9GF7VpjS37ZqTyvHlfvyiQ9yhLZsss4LkG9tqMsmS2VABny0vKZwvvlZcEzsrLlsyWV/JldFGb1tiyb0Yrz5v39SsCeW9myWx5FXiugb02m1kyW8qBs2W28tnCe2W2wFl5zZLZ8nq+jC5q0xpb9s3myvPmff26QN5bWDJb3gCea2CvzRaWzBYDnC1vKp8tvFfeFDgrcyyZLW/ly+iiNq2xZd9sqTxv3tdvCeS9lSWz5W3guQb22mzVUbfOeuTwbcu+t/HOEtLrYKE5YnUgR8xVzhG8V+YK6OK7lnDEvHyZGahtrtiyb7ZWnjfv63kCeW9jCUe8BzzXwF6bbZRzxGrk8D3LOOL9JaTXwUJzxKpAjvhAOUfwXvlAQBc/tIQjPsqXmYHa5oot+2Zb5Xnzvv5IIO/tLOGIj4HnGthrs50ls2UV4Gz5RPls4b3yicBZ+dSS2fJZvowuatMaW/bN9srz5n39mUDeO1gyWz4Hnmtgr80Oyp9RVyaHn1v2jPpFrtdp1W0lcviFZb3+cgnpdbDQzLgikBm/Us6MvFe+EpiBX1vCjN/ky/CONoawZd/sqDxv3tffCOS9kyXM+C3wXAN7bXZSzhErkMNvLeOI73K9Tqtug8jhd5b1+vslpNfBQjPj8kBm/EE5M/Je+UFgBv5oCTP+lC/DO9oYwpZ9s7PyvHlf/ySQ9y6WMOPPwHMN7LXZxZLZshxwtvyifLbwXvlF4Kz8asls+S1fRhe1aY0t+2ZX5Xnzvv5NIO96S2bL78BzDey1qbdktiwLnC1/KJ8tvFf+EDgrf1oyW/7Kl9FFbVpjy75pUJ437+u/BPJutGS2/A0818Bem0ZLZstA4GxxCnTPFt4rHCPar1tgx2zJK5DRRW1aY8u+aVKeN+/rPIG8my2ZLfnAcw3stWm2ZLYsA5wtBcpnC++VAoGz0saS2dK2QEYXtWmNLfumRXnevK/bCuS9myWzpRB4roG9NrtZMluWBs6WIuWzhfdKkcBZKbZktpQUyOiiNq2xZd/srjxv3tclAnmPsWS2tAOea2CvzZiOunV2ADnk2jmt/HoZLslel+Z6nVbd+pPDUst6XZbrdVp160cOyyzrdftcr9OqW19y2N6yXnfI9TqtuvUhhx0s63XHXK/TqttS5LCjZb3ulOt1WnXrTQ47Wdbrzrlep1W3XuSws2W97pLrdVp160kOu1jW6665XqdVtx7ksKtlve6W63VadetODrtZ1uvuuV6nd0bIYXfLet0j1+v0Zh857GFZr3vmep0e05LDnpb1uleu1+k9q5LDXpb1uneu1+m9gyKHvS3r9VK5Xqf3bpkcLmVZr/vkep3eZ0bksI9lve6b63V6nwWTw76W9bpfrtfpfceDHPazrNf9c71O77tb5LC/Zb0ekOt1et/JJIcDLOv10rlep/d9dXK4tGW9XibX6/S+a04Ol7Gs1wNzvU7vzwmRw4GW9XrZXK/T+7Mz5HBZy3q9XK7X6f3ZZXK4nGW9Xn4J6XWw8sD1awP886ODlP/5Ud4rgwT+PNwKlvz50RWBf350d+CfH0X/ecLWZ8TLbJlg36D88X5ZMUJnM/57p0IL/t+WKpCZB/D/3ln6cVa0vsCxdXb+91ce/RMr//yX/3Ob0M9cn+Dnlf2fg39vFfphVbLVyFYvSF1nKwzlv6CaeJkt0xbnywvH6xUIBuwV4P2aAuxhk8jbCAEY+qAV5KViRYst+0XFWF4gW0Mvs2XiaojoDcpXBRhu0PuFzwwyRhbrcgFIrCzQDTlcx3JwHSsE6lhlCYhUpx9neesLUSBSGQKOqoJoEKluBSI19EMtWR3ZGlkAkUJHBkTWLBAMeE0BEFlLOYhw3mstJhDxMlvGzUvFin5adoFDFNnvtZUPZBZ+JGizrxoB0KwBxriOMGgi9nLUGfEyWyZ8RrzMFlQT11UOW6yvwBgNa8I6ArC1ngV1ROoh13BdgTquX4AFn9YwuF4I+tZPCIMb0A8bkg0m2ygLMFjkYGsSrCEFggEPEYDBocphkPMeagkMssIMFYBBBwiDyH5vrBwG1/IHEypf9reBAAxuAIxxE+UwGHdGvMyWcfJ0auIw5RDD+gqM0bAmbCIAMcMtqCNSD7mGwwTquKkwDA4PQd+mCWFwBP0wkmwU2egswGCxg61JsDYrEAx4MwEY3Fw5DHLem1sCg3+7qVjh/6014HemkP3eQjkMDvUHEypf9jdCAAZHAGPcUjkMxp0RL7NlwmfEy2xBNXEr5RDD+gqM0bAmbCkAMVtbUEekHnINtxKo4zbCMLh1CPq2SQiD29IP25FtT7ZDFmCwxMHWJFg7FggGvKMADO6kHAY5750sgcG/3FSs8P9QNRAGkf3eWTkMbu4PJlS+7G9bARjcFhjjLsphMO6MeJkt85erUxN3VQ4xrK/AGA1rwi4CEFNvQR2Resg13FWgjg3CMFgfgr6GhDDYSD80kTWTtWQBBts52JoEa7cCwYB3E4DB3ZXDIOe9uyUw+KebihUNg38CYRDZ7zHKYXAnfzCh8mV/jQIw2AiMcQ/lMBh3RrzMlvnT1amJeyqHGNZXYIyGNWEPAYjZy4I6IvWQa7inQB33FobBvULQt3dCGNyHftiXbD+y/bMAg6UOtibBOqBAMOADBGDwQOUwyHkfaAkM/uGmYkXD4B9AGET2+yDlMLi7P5hQ+bK/fQRgcB9gjAcrh8G4M+Jltswfrk5NPEQ5xLC+AmM0rAkHC0DMoRbUEamHXMNDBOp4mDAMHhqCvsMSwuDh9MMRZEeSHZUFGCxzsDUJ1tgCwYDHCsDg0cphkPM+ejHBYMZ/P3FeKlb4U2ceLsZjlIvqgf4wQeXL/g4X6MnhwBjHCQOcl9kycfsacV5Qvo5V/mDCOoaMkc/xOAFYOE65PnAdgRpmuIbHCtRxvDB0HReCq/EJoet4+uEEshPJTsoCdLV3sDUJ1skFggGfLABdpyiHLs77FEugq0NeKla00HQADqdTlYvq0f4wQeXL/o4X6MnxwBhPUw5dcfsacV5QviYohy7WMWSMfI5PE4CF05XrA9cRqGGGazhBoI5nCEPX6SG4OiMhdJ1JP5xFdjbZOVmArg4OtibBOrdAMOBzBaBronLo4rwnLibo8jJb5lc3FSv6Y89fgR97Ivt9nvJBd4o/mFD5sr8zBQDuTGCM5wsDHGIvR50RL7NlfnV1auIFyiGG9RUYo2FNOF8AYi60oI5IPeQaXiBQx4uEYfDCEPRdlBAGL6YfLiG7lOyyLMBgRwdbk2BdXiAY8OUCMHiFchjkvK+wBAZ/cVOxomHwFyAMIvt9pXIYnOgPJlS+7O9iARi8GBjjVcphMO6MeJkt84urUxOvVg4xrK/AGA1rwlUCEHONBXVE6iHX8GqBOl4rDIPXhKDv2oQwOIl+uI7serIbsgCDnRxsTYJ1Y4FgwDcKwOBk5TDIeU9eTDCYaf7d8lKxooWmG/Bjq5uUi+oV/jBB5cv+Jgn0ZBIwxpuVfxwbt68R5wXl6xblDyasY8gY+RzfLAALtyrXB64jUMMM1/AWgTreJgxdt4bg6raE0HU7/XAH2Z1kd2UBujo72JoE6+4CwYDvFoCue5RDF+d9jyVv4H5yU7Gi38D9BHwDh+z3FOWDbrI/mFD5sr/bBQDudmCM9yp/Axd3RrzMlvnJ1amJ9ymHGNZXYIyGNeFeAYi534I6IvWQa3ifQB2nCsPg/SHom5oQBh+gHx4ke4js4SzAYBcHW5NgTSsQDHiaAAw+ohwGOe9HLIHBH91UrGgY/BEIg8h+P6ocBu/xBxMqX/b3gAAMPgCM8THlMBh3RrzMlvnR1amJ05VDDOsrMEbDmvCYAMQ8bkEdkXrINZwuUMcnhGHw8RD0PZEQBp+kH54ie5rsmSzAYFcHW5NgPVsgGPCzAjD4nHIY5LyfswQGf3BTsaJh8AcgDCL7PUM5DD7iDyZUvuzvSQEYfBIY4/PKYTDujHiZLfODq1MTZyqHGNZXYIyGNeF5AYh5wYI6IvWQazhToI4vCsPgCyHoezEhDM6iH14ie5nslSzAYDcHW5NgvVogGPCrAjA4WzkMct6zFxMMZpp/n7xUrGih6QP8DtNrykX1OX+YoPJlf7MEejILGOPrwgDnZbZM3L5GnBeUrzeUP5iwjiFj5HP8ugAsvKlcH7iOQA0zXMM3BOo4Rxi63gzB1ZyE0PUW/fA22Ttkc7MAXd0dbE2C9W6BYMDvCkDXPOXQxXnPs+QN3HduKlb0G7jvgG/gkP1+T/mgm+0PJlS+7O8tAYB7Cxjj+8rfwMWdES+zZb5zdWriB8ohhvUVGKNhTXhfAGI+tKCOSD3kGn4gUMePhGHwwxD0fZQQBj+mHz4h+5TssyzAYA8HW5NgfV4gGPDnAjD4hXIY5Ly/sAQGv3VTsaJh8FsgDCL7/aVyGJznDyZUvuzvYwEY/BgY41fKYTDujHiZLfOtq1MTv1YOMayvwBgNa8JXAhDzjQV1ROoh1/BrgTp+KwyD34Sg79uEMPgd/fA92Q9kP2YBBns62JoE66cCwYB/EoDBn5XDIOf982KCwUzzXyYvFStaaJYBfmz1i3JR/cIfJqh82d93Aj35Dhjjr8o/jo3b14jzgvL1m/IHE9YxZIx8jn8VgIXflesD1xGoYYZr+JtAHf8Qhq7fQ3D1R0Lo+pP/mexvvtBm8UNXLwdbk3/ibCMYMDtH+81roxu6OO+8NvMLDPIrAl3L56ViRQvN8sDhlN9Gt6j+7A8TVL7s708B6PoTGGNBG9l97WW2TNy+RpwXlK82uBqKQBfrGDJGPscFbfAa1la5PnAdgRpmuIZtBOpY2AYLGK2hi/sUwFVhm2TQVUT3FZOVkLXLAnT1drA1CVZpG8GASwWgq0w5dHHeZZZA10p5qVjRQrMScDi1Vy6qef4wQeXL/ooEelIEjLGDcuiK29eI84Ly1VE5dLGOIWPkc9xBABY6KdcHriNQwwzXsKNAHTsLQ1enEGh1TghdXei+rmTdyLpnAbqWcrA1CVaPNoIB9xCArp7KoYvz7rmYoMvLbJkv3VSs6O+afQn8rhmy372UD7oyfzCh8mV/XQQArgswxt7CAIfYy1FnxMtsmS9dnZq4lHKIYX0FxmhYE3oLQEwfC+qI1EOu4VICdewrDIN9QgDYNyEM9qP7+pMNIFs6CzDYx8HWJFjLtBEMeBkBGByoHAY574GWwOAXbipWNAx+AYRBZL+XVQ6DPf3BhMqX/fUTgMF+wBiXUw6DcWfEy2yZL1ydmri8cohhfQXGaFgTlhOAmEEW1BGph1zD5QXquIIwDA4KAeAKCWFwRbpvJbKVyVbJAgz2dbA1CdaqbQQDXlUABldTDoOc92qWfBzr5aViRQuNB/zYanXlojrQHyaofNnfigI9WREYo6f849i4fY04LyhfRvmDCesYMkY+x54ALJQr1weuI1DDDNfQCNSxQhi6ykOgVZEQuirpviqyarKaLEBXPwdbk2DVthEMuFYAuuqUQxfnXWcJdFXmpWJFC00lcDitoVxUV/OHCSpf9lcp0RNgjGsqh664fY04LyhfaymHLtYxZIx8jtcUgIW1lesD1xGoYYZruJZAHdcRhq61Q6C1TkLoWpdjIlufbIMsQFd/B1uTYG3YRjDgDQWga7By6OK8B1sCXbV5qVjRQlMLHE4bKRfVOn+YoPJlf+sK9GRdYIxDlENX3L5GnBeUr6HKoYt1DBkjn+MhArCwsXJ94DoCNcxwDYcK1HETYejaOARamySErmF033CyTclGZAG6BjjYmgRrZBvBgEcKQNco5dDFeY9aTNDlZbbMJ24qVvR3zT4BftcM2e/RygfdYH8wofJlf8MEAG4YMMbNhAEOsZejzoiX2TKfuDo1cXPlEDOAfABjNKwJmwlAzBYW1BGph1zDzQXquKUwDG4RAsAtE8LgVnTf1mTbkG2bBRhc2sHWJFjbtREMeDsBGNxeOQxy3ttbAoMfu6lY0TD4MRAGkf3eQTkMjvIHEypf9reVAAxuBYxxR+UwGHdGvMyW+djVqYk7KYcY1ldgjIY1YUcBiNnZgjoi9ZBruJNAHXcRhsGdQwC4S0IY3JXuqydrIGvMAgwu42BrEqymNoIBNwnAYLNyGOS8my35OHadvFSsaKFZB/ixVYtyUd3eHyaofNnfrgI92RUY427KP46N29eI84LytbvyBxPWMWSMfI53E4CFMcr1gesI1DDDNdxdoI57CEPXmBBo7ZEQuvak+/Yi25tsnyxA10AHW5Ng7dtGMOB9BaBrP+XQxXnvZ8kbuA/dVKzoN3AfAt/AIfu9v/JB1+wPJlS+7G9PAYDbExjjAcrfwMWdES+zZT50dWrigcohhvUVGKNhTThAAGIOsqCOSD3kGh4oUMeDhWHwoBAAHpwQBg+h+w4lO4zs8CzA4LIOtibBOqKNYMBHCMDgkcphkPM+0pI3cBvmpWJFC82GwDcVRykX1f38YYLKl/0dItCTQ4AxjlX+Bi5uXyPOC8rX0cofTFjHkDHyOR4rAAvHKNcHriNQwwzX8GiBOo4Thq5jQqA1LiF0HUv3HUc2nuz4LEDXcg62JsE6oY1gwCcIQNeJyqGL8z7REugampeKFS00Q4HD6STlonqkP0xQ+bK/YwV6ciwwxpOVQ1fcvkacF5SvU5RDF+sYMkY+xycLwMKpyvWB6wjUMMM1PEWgjqcJQ9epIdA6LSF0TaD7Tic7g+zMLEDX8g62JsE6q41gwGcJQNfZyqGL8z7bEuganpeKFS00w4HD6RzlonqiP0xQ+bK/CQI9mQCM8Vzl0BW3rxHnBeVronLoYh1Dxsjn+FwBWDhPuT5wHYEaZriGEwXqeL4wdJ0XAq3zE0LXBXTfhWQXkV2cBega5GBrEqxL2ggGfIkAdF2qHLo470sXE3R5mS0zz03Fiv6u2Tzgd82Q/b5M+aA72x9MqHzZ3wUCAHcBMMbLhQEOsZejzoiX2TLzXJ2aeIVyiGF9BcZoWBMuF4CYKy2oI1IPuYZXCNTxKmEYvDIEgFclhMGr6b5ryK4lm5QFGFzBwdYkWNe1EQz4OgEYvF45DHLe11sCg++6qVjRMPguEAaR/b5BOQxe6g8mVL7s72oBGLwaGOONymEw7ox4mS3zrqtTEycrhxjWV2CMhjXhRgGIucmCOiL1kGs4WaCONwvD4E0hALw5IQzeQvfdSnYb2e1ZgMEVHWxNgnVHG8GA7xCAwTuVwyDnfaclMDjXTcWKhsG5QBhE9vsu5TB4vT+YUPmyv1sEYPAWYIx3K4fBuDPiZbbMXFenJt6jHGJYX4ExGtaEuwUgZooFdUTqIdfwHoE63isMg1NCAHhvQhi8j+67n2wq2QNZgMGVHGxNgvVgG8GAHxSAwYeUwyDn/ZAlMPiOm4oVDYPvAGEQ2e+HlcPgnf5gQuXL/u4TgMH7gDFOUw6DcWfEy2yZd1ydmviIcohhfQXGaFgTpglAzKMW1BGph1zDRwTq+JgwDD4aAsDHEsLgdLrvcbInyJ7MAgyu7GBrEqyn2ggG/JQADD6tHAY576cXEwxm/J+0yUvFihYa9ouK8RnlovqQP0xQ+bK/6QI9mQ6M8VlhgPMyWyZuXyPOC8rXc8ofTFjHkDHyOX5WABZmKNcHriNQwwzX8DmBOj4vDF0zQqD1fELomkn3vUD2ItmsLEDXKg62JsF6qY1gwC8JQNfLyqGL837Zkjdwb7mpWNFv4N4CvoFD9vsV5YPuaX8wofJlfzMFAG4mMMZXlb+BizsjXmbLvOXq1MTZyiGG9RUYo2FNeFUAYl6zoI5IPeQazhao4+vCMPhaCABfTwiDb9B9b5LNIXsrCzC4qoOtSbDebiMY8NsCMPiOchjkvN+xBAbnuKlY0TA4BwiDyH7PVQ6DL/uDCZUv+3tDAAbfAMb4rnIYjDsjXmbLzHF1auI85RDD+gqM0bAmvCsAMe9ZUEekHnIN5wnU8X1hGHwvBIDvJ4TBD+i+D8k+Ivs4CzC4moOtSbA+aSMY8CcCMPipchjkvD+15OPY7fJSsaKFZjvgx1afKRfVd/xhgsqX/X0g0JMPgDF+rvzj2Lh9jTgvKF9fKH8wYR1Dxsjn+HMBWPhSuT5wHYEaZriGXwjU8Sth6PoyBFpfJYSur+m+b8i+JfsuC9C1uoOtSbC+byMY8PcC0PWDcujivH+wBLp2ykvFihaanYDD6UflovqpP0xQ+bK/rwV68jUwxp+UQ1fcvkacF5Svn5VDF+sYMkY+xz8JwMIvyvWB6wjUMMM1/Fmgjr8KQ9cvIdD6NSF0/Ub3/U72B9mfWYAuz8HWJFh/tREM+C8B6PpbOXSx078t+djzdTcVK/pjz9eBH3tC+91W96D7wR9MqHzZ328CAPcbMEa3rewZQezlvwU+9nzd1amJeW11Qww7zUOeY/LFexC9b/ItqCNSD7mGeQJ1LGiLBZ/WMMh9CqCvoG0yGGxD97UlKyQrarv4YdA42JoEq7itYMDFbfF+S9rqhkHOu6Tt/AKD/IrE+pqbihUNg68BYRDZ73bKYZCHugvMl/2xcKHjbAOMsVQ5DMadES+zZV5zdWpimXKI4YMHjNGwJpQKQEx7C+qI1EOuYZlAHTsIw2D7EAB2SAiDHem+TmSdybpkAQbLHWxNgtW1rWDAXQVgsJtyGOS8u1kCg7PdVKxoGJwNhEFkv7srh8ESfzCh8mV/HQVgsCMwxh7KYTDujHiZLTPb1amJPZVDDOsrMEbDmtBDAGJ6WVBHpB5yDXsK1LG3MAz2CgFg74QwuBTd14esL1m/LMBghYOtSbD6txUMuL8ADA5QDoOc94DFBIOZ5t+Ul4oVLTRNwO8wLa1cVLv5wwSVL/tbSqAnSwFjXEYY4LzMlonb14jzgvI1UPmDCesYMkY+x8sIwMKyyvWB6wjUMMM1HChQx+WEoWvZEGgtlxC6lqf7BpGtQLZiFqCr0sHWJFgrtRUMeCUB6FpZOXRx3itbAl2756ViRQvN7sDhtIpyUR3gDxNUvuxveYGeLA+McVXl0BW3rxHnBeVrNeXQxTqGjJHP8aoCsLC6cn3gOgI1zHANVxOooycMXauHQMtLCF2G7isnqyCrzAJ0VTnYmgSrqq1gwFUC0FWtHLo472pLPvZ82U3Fiv7Y82Xgx57IftcoH3Qr+4MJlS/7MwIAZ4Ax1ir/2DPujHiZLfOyq1MT65RDDOsrMEbDmlArADFrWFBHpB5yDesE6rimMAyuEQLANRPC4Fp039pk65CtmwUYrHawNQnWem0lAxaAwfWVwyDnvb4lb+D2zkvFihaavYFvKjZQLqrV/jBB5cv+1hLoyVrAGDdU/gYubl8jzgvK12DlDyasY8gY+RxvKAALG2nXB/IB1DDDNRwsUMchwtC1UQi0hiSErqF038Zkm5ANywJ01TjYmgRreFvBgIcLQNemyqGL897Ukjdws9xUrOg3cLOAb+CQ/R6hfNCt7w8mVL7sb6gAwA0FxjhS+Ru4uDPiZbbMLFenJo5SDjGsr8AYDWvCSAGIGW1BHZF6yDUcJVDHzYRhcHQIADdLCIOb031bkG1JtlUWYLDWwdYkWFu3FQx4awEY3EY5DHLe21gCgy+6qVjRMPgiEAaR/d5WOQxu6g8mVL7sb3MBGNwcGON2ymEw7ox4mS3zoqtTE7dXDjGsr8AYDWvCdgIQs4MFdUTqIddwe4E67igMgzuEAHDHhDC4E923M9kuZLtmAQbrHGxNglXfVjDgegEYbFAOg5x3gyUw+IKbihUNgy8AYRDZ70blMLiNP5hQ+bK/nQRgcCdgjE3KYTDujHiZLfOCq1MTm5VDDOsrMEbDmtAkADEtFtQRqYdcw2aBOu4mDIMtIQDcLSEM7k73jSHbg2zPLMDgGg62JsHaq61gwHsJwODeymGQ897bEhic6aZiRcPgTCAMIvu9j3IYbPAHEypf9re7AAzuDoxxX+UwGHdGvMyWmenq1MT9lEMM6yswRsOasK8AxOxvQR2Resg13E+gjgcIw+D+IQA8ICEMHkj3HUR2MNkhWYDBNR1sTYJ1aFvBgA8VgMHDlMMg532YJTD4vJuKFQ2DzwNhENnvw5XD4N7+YELly/4OFIDBA4ExHqEcBuPOiJfZMs+7OjXxSOUQw/oKjNGwJhwhADFHWVBHpB5yDY8UqONYYRg8KgSAYxPC4NF03zFk48iOzQIMruVgaxKs49oKBnycAAyOVw6DnPd4S2BwhpuKFQ2DM4AwiOz38cph8DB/MKHyZX9HC8Dg0cAYT1AOg3FnxMtsmRmuTk08UTnEsL4CYzSsCScIQMxJFtQRqYdcwxMF6niyMAyeFALAkxPC4Cl036lkp5FNyAIMru1gaxKs09sKBny6AAyeoRwGOe8zLIHB59xUrGgYfA4Ig8h+n6kcBsf7gwmVL/s7RQAGTwHGeJZyGIw7I15myzzn6tTEs5VDDOsrMEbDmnCWAMScY0EdkXrINTxboI7nCsPgOSEAPDchDE6k+84jO5/sgizA4DoOtibBurCtYMAXCsDgRcphkPO+aDHBYMZvjvJSscLfcOXhYrxYuaie4Q8TVL7sb6JATyYCY7xEGOC8zJaJ29eI84LydanyBxPWMWSMfI4vEYCFy5TrA9cRqGGGa3ipQB0vF4auy0KgdXlC6LqC7ruS7Cqyq7MAXes62JoE65q2ggFfIwBd1yqHLs77WkvewD3jpmJFv4F7BvgGDtnvScoH3UX+YELly/6uEAC4K4AxXqf8DVzcGfEyW+YZV6cmXq8cYlhfgTEa1oTrBCDmBgvqiNRDruH1AnW8URgGbwgB4I0JYXAy3XcT2c1kt2QBBtdzsDUJ1q1SMLie7xzt9zblMMh+brPkDdzYvFSsaKEZC3xTcbtyUb3WHyaofNnfZIGeTAbGeIfyN3Bx+xpxXlC+7lT+YMJ+kDHyOb5DABbuUq4P7AeoYYZreKdAHe8Whq67QqB1d0Louofum0J2L9l9WYCu9R1sTYJ1f1vBgO8XgK6pyqGL855qyRu4p9xUrOg3cE8B38Ah+/2A8kF3mz+YUPmyv3sEAO4eYIwPKn8DF3dGvMyWecrVqYkPKYcY1ldgjIY14UEBiHnYgjoi9ZBr+JBAHacJw+DDIQCclhAGH6H7HiV7jGx6FmBwAwdbk2A93lYw4McFYPAJ5TDIeT9hCQw+6aZiRcPgk0AYRPb7SeUwONUfTKh82d8jAjD4CDDGp5TDYNwZ8TJb5klXpyY+rRxiWF+BMRrWhKcEIOYZC+qI1EOu4dMCdXxWGAafCQHgswlh8Dm6bwbZ82QzswCDGzrYmgTrhbaCAb8gAIMvKodBzvtFSz6OHZ+XihUtNOOBH1vNUi6qT/jDBJUv+3tOoCfPAWN8SfnHsXH7GnFeUL5eVv5gwjqGjJHP8UsCsPCKcn3gOgI1zHANXxao46vC0PVKCLReTQhds+m+18heJ3sjC9A12MHWJFhvthUM+E0B6JqjHLo47zmWQNdJealY0UJzEnA4vaVcVF/0hwkqX/Y3W6Ans4Exvq0cuuL2NeK8oHy9oxy6WMeQMfI5flsAFuYq1weuI1DDDNfwHYE6visMXXNDoPVuQuiaR/e9R/Y+2QdZgK6NHGxNgvVhW8GAPxSAro+UQxfn/ZElH3tOd1Oxoj/2nA782BPZ74+VD7o5/mBC5cv+5gkA3DxgjJ8o/9gz7ox4mS0z3dWpiZ8qhxjWV2CMhjXhEwGI+cyCOiL1kGv4qUAdPxeGwc9CAPh5Qhj8gu77kuwrsq+zAINDHGxNgvVNW8GAvxGAwW+VwyDn/a0lb+Am5KViRQvNBOCbiu+Ui+pH/jBB5cv+vhDoyRfAGL9X/gYubl8jzgvK1w/KH0xYx5Ax8jn+XgAWflSuD1xHoIYZruEPAnX8SRi6fgyB1k8Joetnuu8Xsl/JfssCdA11sDUJ1u9tBQP+XQC6/lAOXZz3H5ZA11l5qVjRQnMWcDj9qVxUv/WHCSpf9vezQE9+Bsb4l3LoitvXiPOC8vW3cuhiHUPGyOf4LwFY4AmM3IsSdQRqmOEa/i1QR7cQCxitoYv7FMCVW5gMuvLovnyyArI2hYsfujZ2sDUJVttCwYDZOdpvYaFu6OK8CwvnFxjkVwS6JualYkULzUTgcCpSLqp/+MMEle//YEGgJ3nAc1NcKLuvvcyWidvXiPOC8lWCq6EIdLGOIWPkc1xciNewdsr1gesI1DDDNSwRqGOpMHS1C4FWaULoKqP72pN1IOuYBejaxMHWJFidCgUD7iQAXZ2VQxfn3XkxQZeX2TLT3FSs6O+aTQN+1wzZ7y7KB12hP5hQ+bK/MgGAKwPG2FUY4BB7OeqMeJktM83VqYndlEMM6yswRsOa0FUAYrpbUEekHnINuwnUsYcwDHYPAWCPhDDYk+7rRdabbKkswOAwB1uTYPUpFAy4jwAM9lUOg5x3X0tg8GE3FSsaBh8GwiCy3/2Uw2BnfzCh8mV/PQVgsCcwxv7KYTDujHiZLfOwq1MTByiHGNZXYIyGNaG/AMQsbUEdkXrINRwgUMdlhGFw6RAALpMQBgfSfcuSLUe2fBZgcLiDrUmwBhUKBjxIAAZXUA6DnPcKlsDgQ24qVjQMPgSEQWS/V1QOg339wYTKl/0NFIDBgcAYV1IOg3FnxMtsmYdcnZq4snKIYX0FxmhYE1YSgJhVLKgjUg+5hisL1HFVYRhcJQSAqyaEwdXovtXJPDKTBRjc1MHWJFjlhYIBlwvAYIVyGOS8KyyBwQfdVKxoGHwQCIPIflcqh8EV/MGEypf9rSYAg6sBY6xSDoNxZ8TLbJkHXZ2aWK0cYlhfgTEa1oQqAYipsaCOSD3kGlYL1LFWGAZrQgBYmxAG6+i+NcjWJFsrCzA4wsHWJFhrFwoGvLYADK6jHAY573UWEwxmmv+lealY0ULDflExrqtcVCv8YYLKl/3VCfSkDhjjesIA52W2TNy+RpwXlK/1lT+YsI4hY/zfORaAhQ2U6wPXEahhhmu4vkAdNxSGrg1CoLVhQugaTPdtRDaEbGgWoGukg61JsDYuFAx4YwHo2kQ5dHHem1jyBm6qm4oV/QZuKvANHLLfw5QPunX8wYTKl/0NFgC4wcAYhyt/Axd3RrzMlpnq6tTETZVDDOsrMEbDmjBcAGJGWFBHpB5yDTcVqONIYRgcEQLAkQlhcBTdN5psM7LNswCDoxxsTYK1RaFgwFsIwOCWymGQ897SkjdwV+WlYkULzVXANxVbKRfVTfxhgsqX/Y0S6MkoYIxbK38DF7evEecF5Wsb5Q8mrGPIGPkcby0AC9sq1weuI1DDDNdwG4E6bicMXduGQGu7hNC1Pd23A9mOZDtlAbpGO9iaBGvnQsGAdxaArl2UQxfnvYslb+Duc1Oxot/A3Qd8A4fs967KB92W/mBC5cv+thcAuO2BMdYrfwMXd0a8zJa5z9WpiQ3KIYb1FRijYU2oF4CYRgvqiNRDrmGDQB2bhGGwMQSATQlhsJnuayHbjWz3LMDgZg62JsEaUygY8BgBGNxDOQxy3ntYAoP3uqlY0TB4LxAGkf3eUzkM7uIPJlS+7K9ZAAabgTHupRwG486Il9ky97o6NXFv5RDD+gqM0bAm7CUAMftYUEekHnIN9xao477CMLhPCAD3TQiD+9F9+5MdQHZgFmBwcwdbk2AdVCgY8EECMHiwchjkvA+2BAanuKlY0TA4BQiDyH4fohwG9/AHEypf9refAAzuB4zxUOUwGHdGvMyWmeLq1MTDlEMM6yswRsOacKgAxBxuQR2Resg1PEygjkcIw+DhIQA8IiEMHkn3HUU2luzoLMDgFg62JsE6plAw4GMEYHCcchjkvMdZAoP3uKlY0TB4DxAGkf0+VjkMHuwPJlS+7O9IARg8EhjjccphMO6MeJktc4+rUxPHK4cY1ldgjIY14TgBiDnegjoi9ZBrOF6gjicIw+DxIQA8ISEMnkj3nUR2MtkpWYDBLR1sTYJ1aqFgwKcKwOBpymGQ8z7NEhi8203FiobBu4EwiOz3BOUwOM4fTKh82d+JAjB4IjDG05XDYNwZ8TJb5m5XpyaeoRxiWF+BMRrWhNMFIOZMC+qI1EOu4RkCdTxLGAbPDAHgWQlh8Gy67xyyc8kmZgEGt3KwNQnWeYWCAZ8nAIPnK4dBzvv8xQSDmeY/OS8VK1po2C8qxguUi+pp/jBB5cv+zhboydnAGC8UBjgvs2Xi9jXivKB8XaT8wYR1DBkjn+MLBWDhYuX6wHUEapjhGl4kUMdLhKHr4hBoXZIQui6l+y4ju5zsiixA19YOtibBurJQMOArBaDrKuXQxXlfZckbuDvdVKzoN3B3At/AIft9tfJBd74/mFD5sr9LBQDuUmCM1yh/Axd3RrzMlrnT1amJ1yqHGNZXYIyGNeEaAYiZZEEdkXrINbxWoI7XCcPgpBAAXpcQBq+n+24gu5FschZgcBsHW5Ng3VQoGPBNAjB4s3IY5LxvtgQG73BTsaJh8A4gDCL7fYtyGLzKH0yofNnf9QIweD0wxluVw2DcGfEyW+YOV6cm3qYcYlhfgTEa1oRbBSDmdgvqiNRDruFtAnW8QxgGbw8B4B0JYfBOuu8usrvJ7skCDG7rYGsSrCmFggFPEYDBe5XDIOd9ryUweLubihUNg7cDYRDZ7/uUw+DN/mBC5cv+7hSAwTuBMd6vHAbjzoiX2TK3uzo1capyiGF9BcZoWBPuF4CYByyoI1IPuYZTBer4oDAMPhACwAcTwuBDdN/DZNPIHskCDG7nYGsSrEcLBQN+VAAGH1MOg5z3Y4sJBjN+6spLxYoWmjuA32GarlxU7/WHCSpf9veQQE8eAsb4uDDAeZktE7evEecF5esJ5Q8mrGPIGPkcPy4AC08q1weuI1DDDNfwCYE6PiUMXU+GQOuphND1NN33DNmzZM9lAbq2d7A1CdaMQsGAZwhA1/PKoYvzft6SN3C3uqlY0W/gbgW+gUP2e6byQfeYP5hQ+bK/pwUA7mlgjC8ofwMXd0a8zJa51dWpiS8qhxjWV2CMhjXhBQGImWVBHZF6yDV8UaCOLwnD4KwQAL6UEAZfpvteIXuVbHYWYHAHB1uTYL1WKBjwawIw+LpyGOS8X7fkDdyUvFSsaKGZAnxT8YZyUX3eHyaofNnfywI9eRkY45vK38DF7WvEeUH5mqP8wYR1DBkjn+M3BWDhLeX6wHUEapjhGs4RqOPbwtD1Vgi03k4IXe/QfXPJ3iWblwXo2tHB1iRY7xUKBvyeAHS9rxy6OO/3LYGuqXmpWNFCMxU4nD5QLqqv+8MElS/7e0egJ+8AY/xQOXTF7WvEeUH5+kg5dLGOIWPkc/yhACx8rFwfuI5ADTNcw48E6viJMHR9HAKtTxJC16d032dkn5N9kQXo2snB1iRYXxYKBvylAHR9pRy6OO+vLPnY8yY3FSv6Y8+bgB97Ivv9tfJB974/mFD5sr9PBQDuU2CM3yj/2DPujHiZLXOTq1MTv1UOMayvwBgNa8I3AhDznQV1ROoh1/BbgTp+LwyD34UA8PuEMPgD3fcj2U9kP2cBBnd2sDUJ1i+FggH/IgCDvyqHQc77V0vewE3LS8WKFpppwDcVvykX1a/8YYLKl/39INCTH4Ax/q78DVzcvkacF5SvP5Q/mLCOIWPkc/y7ACz8qVwfuI5ADTNcwz8E6viXMHT9GQKtvxJC1988R4vo18jyihY/dO3iYGsSrPwiwYDZOdpvQZFu6OK8C4rmFxjkVwS6puelYkULzXTgcGpTpFtUf/WHCSpf9ve3AHT9DYyxbZHsvvYyWyZuXyPOC8pXIa6GItDFOoaMkc9x2yK8hhUp1weuI1DDDNewUKCOxUVYwGgNXdynAK6Ki5JBVwnd146slKwsC9C1q4OtSbDaFwkG3F4Aujoohy7Ou8Nigi4vs2VucFOxoj/2vAH4sSey3x2VD7oCfzCh8mV/JQJQXQKMsZMwwCH2ctQZ8TJb5gZXpyZ2Vg4xu5IPYIyGNaGTAMR0saCOSD3kGnYWqGNXYRjsEgLArglhsBvd152sB1nPLMBgvYOtSbB6FQkG3EsABnsrh0HOu7clb+CezkvFihaap4FvKpZSLqod/GGCypf9dRPoSTdgjH2Uv4GL29eI84Ly1Vf5gwnrGDJGPsd9BGChn3J94DoCNcxwDfsK1LG/MHT1C4FW/4TQNYDuW5psGbKBWYCuBgdbk2AtWyQY8LIC0LWccujivJezBLpm5KViRQvNDOBwWl65qPb2hwkqX/Y3QKAnA4AxDlIOXXH7GnFeUL5WUA5drGPIGPkcDxKAhRWV6wPXEahhhmu4gkAdVxKGrhXDoJUQulam+1YhW5VstSxAV6ODrUmwVi8SDHh1AejylEMX5+1Z8rHnJDcVK/pjz0nAjz2R/TbKB91y/mBC5cv+VhYAuJWBMZYr/9gz7ox4mS0zydWpiRXKIYb1FRijYU0oF4CYSgvqiNRDrmGFQB2rhGGwMgSAVQlhsJruqyGrJavLAgw2OdiaBGuNIsGA1xCAwTWVwyDnvaYlb+Bm5aViRQvNLOCbirWUi6rnDxNUvuyvWqAn1cAY11b+Bi5uXyPOC8rXOsofTFjHkDHyOV5bABbWVa4PXEeghhmu4ToCdVxPGLrWDYHWegmha326bwOyDckGZwG6mh1sTYK1UZFgwBsJQNcQ5dDFeQ+x5A3cNW4qVvQbuGuAb+CQ/R6qfNCt6Q8mVL7sb30BgFsfGOPGyt/AxZ0RL7NlrnF1auImyiGG9RUYo2FN2FgAYoZZUEekHnINNxGo43BhGBwWAsDhCWFwU7pvBNlIslFZgMEWB1uTYI0uEgx4tAAMbqYcBjnvzSyBwavdVKxoGLwaCIPIfm+uHAaH+IMJlS/721QABjcFxriFchiMOyNeZstc7erUxC2VQwzrKzBGw5qwhQDEbGVBHZF6yDXcUqCOWwvD4FYhANw6IQxuQ/dtS7Yd2fZZgMHdHGxNgrVDkWDAOwjA4I7KYZDz3tESGLzKTcWKhsGrgDCI7PdOymFwM38wofJlf9sIwOA2wBh3Vg6DcWfEy2yZq1ydmriLcohhfQXGaFgTdhaAmF0tqCNSD7mGuwjUsV4YBncNAWB9QhhsoPsayZrImrMAg7s72JoEq6VIMOAWARjcTTkMct67WQKDV7qpWNEweCUQBpH93l05DO7oDyZUvuyvQQAGG4AxjlEOg3FnxMtsmStdnZq4h3KIYX0FxmhYE8YIQMyeFtQRqYdcwz0E6riXMAzuGQLAvRLC4N503z5k+5LtlwUYHONgaxKs/YsEA95fAAYPUA6DnPcBlsDgFW4qVjQMXgGEQWS/D1QOg7v5gwmVL/vbWwAG9wbGeJByGIw7I15my1zh6tTEg5VDDOsrMEbDmnCQAMQcYkEdkXrINTxYoI6HCsPgISEAPDQhDB5G9x1OdgTZkVmAwT0cbE2CdVSRYMBHCcDgWOUwyHmPtQQGL3dTsaJh8HIgDCL7fbRyGDzAH0yofNnfYQIweBgwxmOUw2DcGfEyW+ZyV6cmjlMOMayvwBgNa8IxAhBzrAV1ROoh13CcQB2PE4bBY0MAeFxCGBxP9x1PdgLZiVmAwT0dbE2CdVKRYMAnCcDgycphkPM+eTHBYKb5z8lLxYoWGvaLivEU5aI61h8mqHzZ33iBnowHxniqMMB5mS0Tt68R5wXl6zTlDyasY8gY+RyfKgALE5TrA9cRqGGGa3iaQB1PF4auCSHQOj0hdJ1B951JdhbZ2VmArr0cbE2CdU6RYMDnCEDXucqhi/M+1xLompuXihUtNHOBw2miclE92R8mqHzZ3xkCPTkDGON5yqErbl8jzgvK1/nKoYt1DBkjn+PzBGDhAuX6wHUEapjhGp4vUMcLhaHrghBoXZgQui6i+y4mu4Ts0ixA194OtibBuqxIMODLBKDrcuXQxXlfbsnHnpe4qVjRH3teAvzYE9nvK5QPunP9wYTKl/1dJABwFwFjvFL5x55xZ8TLbJlLXJ2aeJVyiGF9BcZoWBOuFICYqy2oI1IPuYZXCdTxGmEYvDoEgNckhMFr6b5JZNeRXZ8FGNzHwdYkWDcUCQZ8gwAM3qgcBjnvGy2BwYvdVKxoGLwYCIPIfk9WDoOX+4MJlS/7u1YABq8FxniTchiMOyNeZstc7OrUxJuVQwzrKzBGw5pwkwDE3GJBHZF6yDW8WaCOtwrD4C0hALw1IQzeRvfdTnYH2Z1ZgMF9HWxNgnVXkWDAdwnA4N3KYZDzvtsSGLzITcWKhsGLgDCI7Pc9ymHwRn8wofJlf7cJwOBtwBinKIfBuDPiZbbMRa5OTbxXOcSwvgJjNKwJUwQg5j4L6ojUQ67hvQJ1vF8YBu8LAeD9CWFwKt33ANmDZA9lAQb3c7A1CdbDRYIBPywAg9OUwyDnPc0SGLzQTcWKhsELgTCI7PcjymHwbn8wofJlf1MFYHAqMMZHlcNg3BnxMlvmQlenJj6mHGJYX4ExGtaERwUgZroFdUTqIdfwMYE6Pi4Mg9NDAPh4Qhh8gu57kuwpsqezAIP7O9iaBOuZIsGAnxGAwWeVwyDn/awlMHiBm4oVDYMXAGEQ2e/nlMPgNH8wofJlf08IwOATwBhnKIfBuDPiZbbMBa5OTXxeOcSwvgJjNKwJMwQgZqYFdUTqIdfweYE6viAMgzNDAPhCQhh8ke6bRfYS2ctZgMEDHGxNgvVKkWDArwjA4KvKYZDzftUSGDzfTcWKhsHzgTCI7Pds5TD4rD+YUPmyvxcFYPBFYIyvKYfBuDPiZbbM+a5OTXxdOcSwvgJjNKwJrwlAzBsW1BGph1zD1wXq+KYwDL4RAsA3E8LgHLrvLbK3yd7JAgwe6GBrEqy5RYIBzxWAwXeVwyDn/e5igsFM8/80LxUrWmjYLyrGecpF9VV/mKDyZX9zBHoyBxjje8IA52W2TNy+RpwXlK/3lT+YsI4hY+Rz/J4ALHygXB+4jkANM1zD9wXq+KEwdH0QAq0PE0LXR3Tfx2SfkH2aBeg6yMHWJFifFQkG/JkAdH2uHLo4788teQM30U3Fin4DNxH4Bg7Z7y+UD7p3/cGEypf9fSQAcB8BY/xS+Ru4uDPiZbbMRFenJn6lHGJYX4ExGtaELwUg5msL6ojUQ67hVwJ1/EYYBr8OAeA3CWHwW7rvO7LvyX7IAgwe7GBrEqwfiwQD/lEABn9SDoOc90+WvIH7Ki8VK1povgK+qfhZuah+7g8TVL7s71uBnnwLjPEX5W/g4vY14rygfP2q/MGEdQwZI5/jXwRg4Tfl+sB1BGqY4Rr+KlDH34Wh67cQaP2eELr+oPv+5HvJ/s4CdB3iYGvyzyoWDJido/26xbqhi/N2i+fXF+RXJNZz3FSs6Ddw5wDfwCH7nVese9D95A8mVL7s7w8BgPsDGGN+sewZQezlqDPiZbbMOa5OTSwo1g0xrK/AGA1rQn4xft+0saCOSD3kGhYI1LFtMRZ8WsMg9ymAvrbFyWCwkO4rIismKyle/DB4qIOtSbDaFQsG3E4ABkuVwyDnXbqYYDDT/L/PS8WKFprvgW8qypSLqusPE1S+7K9QoCeFwBjbCwOcl9kycfsacV5QvjoofzBhHUPGyOe4vQAsdFSuD1xHoIYZrmEHgTp2EoaujiHQ6pQQujrTfV3IupJ1ywJ0HeZgaxKs7sWCAXcXgK4eyqGL8+5hCXT9nJeKFS00PwOHU0/lolrqDxNUvuyvs0BPOgNj7KUcuuL2NeK8oHz1Vg5drGPIGPkc9xKAhaWU6wPXEahhhmvYW6COfYSha6kQaPVJCF196b5+ZP3JBmQBug53sDUJ1tLFggEvLQBdyyiHLs57GUs+9jzTTcWK/tjzTODHnsh+D1Q+6Hr4gwmVL/vrKwBwfYExLqv8Y8+4M+JltsyZrk5NXE45xLC+AmM0rAnLCkDM8hbUEamHXMPlBOo4SBgGlw8B4KCEMLgC3bci2UpkK2cBBo9wsDUJ1irFggGvIgCDqyqHQc57VUtg8Aw3FSsaBs8AwiCy36sph8Fl/MGEypf9rSAAgysAY1xdOQzGnREvs2XOcHVqoqccYlhfgTEa1oTVBSDGWFBHpB5yDT2BOpYLw6AJAWB5QhisoPsqyarIqrMAg0c62JoEq6ZYMOAaARisVQ6DnHetJTB4upuKFQ2DpwNhENnvOuUwuKo/mFD5sr8KARisAMa4hnIYjDsjXmbLnO7q1MQ1lUMM6yswRsOasIYAxKxlQR2Resg1XFOgjmsLw+BaIQBcOyEMrkP3rctxka2fBRg8ysHWJFgbFAsGvIEADG6oHAY57w0tgcEJbipWNAxOAMIgst+DlcNgrT+YUPmyv3UEYHAdYIwbKYfBuDPiZbbMBFenJg5RDjGsr8AYDWvCRgIQM9SCOiL1kGs4RKCOGwvD4NAQAG6cEAY3ofuGkQ0n2zQLMDjWwdYkWCOKBQMeIQCDI5XDIOc9cjHBYKb5/52XihUtNOwXFeMo5aK6oT9MUPmyv00EerIJMMbRwgDnZbZM3L5GnBeUr82UP5iwjiFj5HM8WgAWNleuD1xHoIYZruFmAnXcQhi6Ng+B1hYJoWtLum8rsq3JtskCdB3tYGsSrG2LBQPeVgC6tlMOXZz3dpa8gTvVTcWKfgN3KvANHLLf2ysfdCP9wYTKl/1tKQBwWwJj3EH5G7i4M+Jltsyprk5N3FE5xLC+AmM0rAk7CEDMThbUEamHXMMdBeq4szAM7hQCwJ0TwuAudN+uZPVkDVmAwWMcbE2C1VgsGHCjAAw2KYdBzrvJkjdwBfmpWNFCw35RMTYrF9Xt/GGCypf97SLQk12AMbYofwMXt68R5wXlazflDyasY8gY+Ry3CMDC7sr1gesI1DDDNdxNoI5jhKFr9xBojUkIXXvQfXuS7UW2dxaga5yDrUmw9ikWDHgfAejaVzl0cd77WgJdRfmpWNFCUwQcTvspF9Umf5ig8mV/ewj0ZA9gjPsrh664fY04LyhfByiHrnHkAxkjn+P9BWDhQOX6wHUEapjhGh4gUMeDhKHrwBBoHZQQug6m+w4hO5TssCxA17EOtibBOrxYMODDBaDrCOXQxXkfYQl0leanYkULTSlwOB2pXFT39YcJKl/2d7BATw4GxniUcuiK29eI84LyNVY5dLGOIWPkc3yUACwcrVwfuI5ADTNcw7ECdTxGGLqODoHWMQmhaxzddyzZcWTjswBdxznYmgTr+GLBgI8XgK4TlEMX533CYoIuL7NlTnRTsaK/a3Yi8LtmyH6fqHzQHeEPJlS+7G+cAMCNA8Z4kjDAIfZy1BnxMlvmRFenJp6sHGJYX4ExGtaEkwQg5hQL6ojUQ67hyQJ1PFUYBk8JAeCpCWHwNLpvAtnpZGdkAQbHO9iaBOvMYsGAzxSAwbOUwyDnfZYlb+A65adiRQtNJ+CbirOVi+oJ/jBB5cv+ThPoyWnAGM9R/gYubl8jzgvK17nKH0xYx5Ax8jk+RwAWJirXB64jUMMM1/BcgTqeJwxdE0OgdV5C6Dqf7ruA7EKyi7IAXcc72JoE6+JiwYAvFoCuS5RDF+d9iSVv4I53U7Gi38AdD3wDh+z3pcoH3Vn+YELly/7OFwC484ExXqb8DVzcGfEyW+Z4V6cmXq4cYlhfgTEa1oTLBCDmCgvqiNRDruHlAnW8UhgGrwgB4JUJYfAquu9qsmvIrs0CDJ7gYGsSrEnFggFPEoDB65TDIOd9nSUwON5NxYqGwfFAGET2+3rlMHiJP5hQ+bK/qwRg8CpgjDcoh8G4M+Jltsx4V6cm3qj9jTf5AMZoWBNuEICYyRbUEamHXMMbBep4kzAMTg4B4E0JYfBmuu8WslvJbssCDJ7oYGsSrNuLBQO+XQAG71AOg5z3HZZ8HNsjPxUrWmh6AD+2ulO5qF7nDxNUvuzvZoGe3AyM8S7lH8fG7WvEeUH5ulv5gwnrGDJGPsd3CcDCPcr1gesI1DDDNbxboI5ThKHrnhBoTUkIXffSffeR3U82NQvQdZKDrUmwHigWDPgBAeh6UDl0cd4PWvIG7lg3FSv6DdyxwDdwyH4/pHzQ3eEPJlS+7O9eAYC7Fxjjw8rfwMWdES+zZY51dWriNOUQw/oKjNGwJjwsADGPWFBHpB5yDacJ1PFRYRh8JASAjyaEwcfovulkj5M9kQUYPNnB1iRYTxYLBvykAAw+pRwGOe+nLHkD1yc/FStaaPoA31Q8rVxUH/SHCSpf9veYQE8eA8b4jPI3cHH7GnFeUL6eVf5gwjqGjJHP8TMCsPCccn3gOgI1zHANnxWo4wxh6HouBFozEkLX83TfTLIXyF7MAnSd4mBrEqxZxYIBzxKArpeUQxfn/ZIlb+COcVOxot/AHQN8A4fs98vKB91T/mBC5cv+nhcAuOeBMb6i/A1c3BnxMlvmGFenJr6qHGJYX4ExGtaEVwQgZrYFdUTqIdfwVYE6viYMg7NDAPhaQhh8ne57g+xNsjlZgMFTHWxNgvVWsWDAbwnA4NvKYZDzftsSGDzaTcWKhsGjgTCI7Pc7ymHwJX8wofJlf68LwODrwBjnKofBuDPiZbbM0a5OTXxXOcSwvgJjNKwJcwUgZp4FdUTqIdfwXYE6vicMg/NCAPheQhh8n+77gOxDso+yAIOnOdiaBOvjYsGAPxaAwU+UwyDn/YklMDjWTcWKhsGxQBhE9vtT5TD4tj+YUPmyv/cFYPB9YIyfKYfBuDPiZbbMWFenJn6uHGJYX4ExGtaEzwQg5gsL6ojUQ67h5wJ1/FIYBr8IAeCXCWHwK7rva7JvyL7NAgxOcLA1CdZ3xYIBfycAg98rh0HO+3tLYPAoNxUrGgaPAsIgst8/KIfBT/zBhMqX/X0lAINfAWP8UTkMxp0RL7NljnJ1auJPyiGG9RUYo2FN+FEAYn62oI5IPeQa/iRQx1+EYfDnEAD+khAGf6X7fiP7neyPLMDg6Q62JsH6s1gw4D8FYPAv5TDIef9lCQwe6aZiRcPgkUAYRPb7b+Uw+L0/mFD5sr9fBWDwV+QZLNENg3FnxMtsmSNdnZroluiGGNZXYIyGNYH3IHrf5FlQR6gelqT6gq5jfgkWfFrDIPcpgL78kmQwWED3tSFrS1ZYsvhh8AwHW5NgFZUIBlxUgvdbXKIbBjnv4pL5BQb5FRl0y+WnYkULzXLAP91YolxU//KHCSpf9lcg0JMCYIzthAHOy2yZuH2NOC8oX6VAoJHY16xjyBj5HLcTgIUy5frAdQRqmOEalgrUsb0wdJWFQKt9QujqQPd1JOtE1jkL0HWmg61JsLqUCAbcRQC6uiqHLs67qyXQtWJ+Kla00KwIHE7dlItqsT9MUPmyvw4CPekAjLG7cuiK29eI84Ly1UM5dLGOIWPkc9xdABZ6KtcHriNQwwzXsIdAHXsJQ1fPEGj1Sghdvem+pcj6kPXNAnSd5WBrEqx+JYIB9xOArv7KoYvz7r+YoMvLbJnD3FSs6I89DwN+7Ins9wDlg66rP5hQ+bK/3gIA1xsY49LKP/aMOyNeZssc5urUxGWUQwzrKzBGw5qwtADEDLSgjkg95BouI1DHZYVhcGAIAJdNCIPL0X3Lkw0iWyELMHi2g61JsFYsEQx4RQEYXEk5DHLeK1kCg4e6qVjRMHgoEAaR/V5ZOQz29wcTKl/2t5zEx9rAGFdRDoNxZ8TLbJlDXZ2auKpyiGF9BcZoWBNWEYCY1SyoI1IPuYarCtRxdWEYXC0EgKsnhEGP7jNk5WQVWYDBcxxsTYJVWSIYcKUADFYph0HOu8qSj2NXz0/Fihaa1YEfW1UrF9WV/GGCypf9eQI98YAx1ij/ODZuXyPOC8pXrfIHE9YxZIx8jmsEYKFOuT5wHYEaZriGtQJ1XEMYuupCoLVGQuhak+5bi2xtsnWyAF3nOtiaBGvdEsGA1xWArvWUQ9f/GmUJdFXkp2JFC00FcDitr1xUq/xhgsqX/a0p0JM1gTFuoBy64vY15LyAfG2oHLpYx5Ax8jneQAAWBivXB64jUMMM13BDgTpuJAxdg0OgtVFC6BpC9w0l25hskyxA10QHW5NgDSsRDHiYAHQNVw5dnPdwS6CrJj8VK1poaoDDaVPlorqeP0xQ+bK/IQI9GQKMcYRy6Irb14jzgvI1Ujl0sY4hY+RzPEIAFkYp1weuI1DDDNdwpEAdRwtD16gQaI1OCF2b0X2bk21BtmUWoOs8B1uTYG1VIhjwVgLQtbVy6OK8t7YEutbMT8UKf6sCHE7bKBfV4f4wQeXL/jYT6MlmwBi3VQ5dcfsacV5QvrZTDl2sY8gY+RxvKwAL2yvXB64jUMMM13A7gTruIAxd24dAa4eE0LUj3bcT2c5ku2QBus53sDUJ1q4lggHvKgBd9cqhi/OutwS61s1PxYoWmnWBw6lBuahu7Q8TVL7sb0eBnuwIjLFROXTF7WvEeUH5alIOXaxjyBj5HDcKwEKzcn3gOgI1zHANmwTq2CIMXc0h0GpJCF270X27k40h2yML0HWBg61JsPYsEQx4TwHo2ks5dHHeey0m6PIyW2Z/NxUr+k9V7g/8U5XIfu+tfNDV+4MJlS/7200A4HYDxriPMMAh9nLUGfEyW2Z/V6cm7qscYlhfgTEa1oR9BCBmPwvqiNRDruG+AnXcXxgG9wsB4P4JYfAAuu9AsoPIDs4CDF7oYGsSrENKBAM+RAAGD1UOg5z3oZa8gRucn4oVLTSDgW8qDlMuqnv5wwSVL/s7QKAnBwBjPFz5G7i4fY04LyhfRyh/MGEdQ8bI5/hwAVg4Urk+cB2BGma4hkcI1PEoYeg6MgRaRyWErrF039Fkx5CNywJ0XeRgaxKsY0sEAz5WALqOUw5dnPdxlryB29dNxYp+A7cv8A0cst/jlQ+6Q/3BhMqX/Y0VALixwBiPV/4GLu6MeJkts6+rUxNPUA4xrK/AGA1rwvECEHOiBXVE6iHX8ASBOp4kDIMnhgDwpIQweDLddwrZqWSnZQEGL3awNQnWhBLBgCcIwODpymGQ8z7dEhjcx03FiobBfYAwiOz3Gcph8Dh/MKHyZX8nC8DgycAYz1QOg3FnxMtsmX1cnZp4lnKIYX0FxmhYE84UgJizLagjUg+5hmcJ1PEcYRg8OwSA5ySEwXPpvolk55GdnwUYvMTB1iRYF5QIBnyBAAxeqBwGOe8LLYHBvd1UrGgY3BsIg8h+X6QcBk/3BxMqX/Z3rgAMnguM8WLlMBh3RrzMltnb1amJlyiHGNZXYIyGNeFiAYi51II6IvWQa3iJQB0vE4bBS0MAeFlCGLyc7ruC7Eqyq7IAg5c62JoE6+oSwYCvFoDBa5TDIOd9jSUwuJebihUNg3sBYRDZ72u1fx/KH0yofNnf5QIweDkwxknKYTDujHiZLbOXq1MTr1MOMayvwBgNa8IkAYi53oI6IvWQa3idQB1vEIbB60MAeENCGLyR7ptMdhPZzVmAwcscbE2CdUuJYMC3CMDgrcphkPO+dTHBYMZ/4W5+Kla00GwK/EL7bcpF9Rp/mKDyZX83CvTkRmCMtwsDnJfZMnH7GnFeUL7uUP5gwjqGjJHP8e0CsHCncn3gOgI1zHAN7xCo413C0HVnCLTuSghdd9N995BNIbs3C9B1uYOtSbDuKxEM+D4B6LpfOXRx3vdb8gZuDzcVK/oN3B7AN3DIfk9VPuhu9QcTKl/2d7cAwN0NjPEB5W/g4s6Il9kye7g6NfFB5RDD+gqM0bAmPCAAMQ9ZUEekHnINHxSo48PCMPhQCAAfTgiD0+i+R8geJXssCzB4hYOtSbCmlwgGPF0ABh9XDoOc9+OWwOAYNxUrGgbHAGEQ2e8nlMPg/f5gQuXL/qYJwOA0YIxPKofBuDPiZbbMGFenJj6lHGJYX4ExGtaEJwUg5mkL6ojUQ67hUwJ1fEYYBp8OAeAzCWHwWbrvObIZZM9nAQavdLA1CdbMEsGAZwrA4AvKYZDzfsGSj2M3z0/FihaazYEfW72oXFQf94cJKl/296xAT54FxjhL+cexcfsacV5Qvl5S/mByJflAxsjneJYALLysXB+4jkANM1zDlwTq+IowdL0cAq1XEkLXq3TfbLLXyF7PAnRd5WBrEqw3SgQDfkMAut5UDl2c95uWvIHbzU3Fin4DtxvwDRyy33OUD7oX/MGEypf9vSoAcK8CY3xL+Ru4uDPiZbbMbq5OTXxbOcSwvgJjNKwJbwlAzDsW1BGph1zDtwXqOFcYBt8JAeDchDD4Lt03j+w9svezAINXO9iaBOuDEsGAPxCAwQ+VwyDn/aElMNjipmJFw2ALEAaR/f5IOQy+6Q8mVL7s710BGHwXGOPHymEw7ox4mS3T4urUxE+UQwzrKzBGw5rwsQDEfGpBHZF6yDX8RKCOnwnD4KchAPwsIQx+Tvd9QfYl2VdZgMFrHGxNgvV1iWDAXwvA4DfKYZDz/sYSGGx2U7GiYbAZCIPIfn+rHAY/9AcTKl/297kADH4OjPE75TAYd0a8zJZpdnVq4vfKIYb1FRijYU34TgBifrCgjkg95Bp+L1DHH4Vh8IcQAP6YEAZ/ovt+JvuF7NcswOC1DrYmwfqtRDDg3wRg8HflMMh5/24JDDa5qVjRMNgEhEFkv/9QDoPf+IMJlS/7+0kABn8CxvinchiMOyNeZss0uTo18S/lEMP6CozRsCb8KQAxf1tQR6Qecg3/Eqij004WBv8OASD/Xklg0KX78sjyyQraLX4YnORgaxKsNu0EA2bnaL9t2+mGQc67bbv5BQb5FRl02+enYkULzfbAL7QXttMtqr/7wwSVL/tzBXriAs9NUTvZfe1ltkzcvkacF5SvYlwNRR5MWMeQMfI5LmqH17AS5frAdQRqmOEaFgvUsZ0wdJWEQKtdQugqpfvKyNqTdcgCdF3nYGsSrI7tBAPuKABdnZRDF+fdyRLo2jk/FStaaHYGDqfOykW1rT9MUPmyv1KBnpQCY+yiHLri9jXivKB8dVUOXaxjyBj5HHcRgIVuyvWB6wjUMMM17CpQx+7C0NUtBFrdE0JXD7qvJ1kvst5ZgK7rHWxNgrVUO8GAlxKArj7KoYvz7mMJdDXkp2JFC00DcDj1VS6qnfxhgsqX/fUQ6EkPYIz9lENX3L5GnBeUr/7KoYt1DBkjn+N+ArAwQLk+cB2BGma4hv0F6ri0MHQNCIHW0gmhaxm6byDZsmTLZQG6bnCwNQnW8u0EA15eALoGKYcuznuQJdDVkp+KFS00LcDhtIJyUe3jDxNUvuxvGYGeLAOMcUXl0BW3rxHnBeVrJeXQxTqGjJHP8YoCsLCycn3gOgI1zHANVxKo4yrC0LVyCLRWSQhdq9J9q5GtTuZlAbpudLA1CZZpJxiwEYCucuXQxXmXLybo8jJbZhc3FSv6C/67AL/gj+x3hfJBN8gfTKh82d+qAgC3KjDGSmGAQ+zlqDPiZbbMLq5OTaxSDjGsr8AYDWtCpQDEVFtQR6Qecg2rBOpYIwyD1SEArEkIg7V0Xx3ZGmRrZgEGJzvYmgRrrXaCAa8lAINrK4dBznttS2BwZzcVKxoGdwbCILLf6yiHwXJ/MKHyZX+1AjBYC4xxXeUwGHdGvMyW2dnVqYnrKYeY/w1C4DlmTVhXAGLWt6COSD383zkWqOMGwjC4fggAN0gIgxvSfYPJNiIbkgUYvMnB1iRYQ9sJBjxUAAY3Vg6DnPfGlnwcu1d+Kla00OwF/NhqE+WiurY/TFD5sr8NBXqyITDGYco/jo3b14jzgvI1XPmDCesYMkY+x8MEYGFT5frAdQRqmOEaDheo4whh6No0BFojEkLXSLpvFNloss2yAF03O9iaBGvzdoIBby4AXVsohy7OewtLoGu//FSsaKHZDzictlQuqhv7wwSVL/sbKdCTkcAYt1IOXXH7GnFeUL62Vg5drGPIGPkcbyUAC9so1weuI1DDDNdwa4E6bisMXduEQGvbhNC1Hd23PdkOZDtmAbpucbA1CdZO7QQD3kkAunZWDl2c986WfOy5g5uKFf2x5w7Ajz2R/d5F+aDbwh9MqHzZ33YCALcdMMZdlX/sGXdGvMyW2cHVqYn1yiGG9RUYo2FN2FUAYhosqCNSD7mG9QJ1bBSGwYYQADYmhMEmuq+ZrIVstyzA4K0OtibB2r2dYMC7C8DgGOUwyHmPseQN3MH5qVjRQnMw8E3FHspFdWd/mKDyZX9NAj1pAsa4p/I3cHH7GnFeUL72Uv5gwjqGjJHP8Z4CsLC3cn3gOgI1zHAN9xKo4z7C0LV3CLT2SQhd+9J9+5HtT3ZAFqDrNgdbk2Ad2E4w4AMFoOsg5dDFeR9kCXQdnp+KFS00hwOH08HKRXWMP0xQ+bK/fQV6si8wxkOUQ1fcvkacF5SvQ5VDF+sYMkY+x4cIwMJhyvWB6wjUMMM1PFSgjocLQ9dhIdA6PCF0HUH3HUl2FNnYLEDX7Q62JsE6up1gwEcLQNcxyqGL8z7GEugam5+KFS00Y4HDaZxyUT3IHyaofNnfEQI9OQIY47HKoStuXyPOC8rXccqhi3UMGSOf42MFYGG8cn3gOgI1zHANjxOo4/HC0DU+BFrHJ4SuE+i+E8lOIjs5C9B1h4OtSbBOaScY8CkC0HWqcujivE9dTNDlZbbMNm4qVvR3zbYBftcM2e/TlA+6Y/zBhMqX/Z0gAHAnAGOcIAxwiL0cdUa8zJbZxtWpiacrhxjWV2CMhjVhggDEnGFBHZF6yDU8XaCOZwrD4BkhADwzIQyeRfedTXYO2blZgME7HWxNgjWxnWDAEwVg8DzlMMh5n2cJDG7tpmJFw+DWQBhE9vt85TB4qj+YUPmyv7MEYPAsYIwXKIfBuDPiZbbM1q5OTbxQOcSwvgJjNKwJFwhAzEUW1BGph1zDCwXqeLEwDF4UAsCLE8LgJXTfpWSXkV2eBRi8y8HWJFhXtBMM+AoBGLxSOQxy3lda8nHs+PxUrGihGQ/82Ooq5aJ6nj9MUPmyv0sEenIJMMarlX8cG7evEecF5esa5Q8mrGPIGPkcXy0AC9cq1weuI1DDDNfwGoE6ThKGrmtDoDUpIXRdR/ddT3YD2Y1ZgK67HWxNgjW5nWDAkwWg6ybl0MV532TJG7gt3VSs6DdwWwLfwCH7fbPyQXelP5hQ+bK/6wQA7jpgjLcofwMXd0a8zJbZ0tWpibcqhxjWV2CMhjXhFgGIuc2COiL1kGt4q0AdbxeGwdtCAHh7Qhi8g+67k+wusruzAIP3ONiaBOuedoIB3yMAg1OUwyDnPcWSN3An56diRQvNycA3FfcqF9Wb/GGCypf93SHQkzuAMd6n/A1c3L5GnBeUr/uVP5iwjiFj5HN8nwAsTFWuD1xHoIYZruH9AnV8QBi6poZA64GE0PUg3fcQ2cNk07IAXVMcbE2C9Ug7wYAfEYCuR5VDF+f9qCXQNSE/FStaaCYAh9NjykV1ij9MUPmyvwcFevIgMMbpyqErbl8jzgvK1+PKoYt1DBkjn+PpArDwhHZ9IB9ADTNcw8cF6vikMHQ9EQKtJxNC11N039Nkz5A9mwXoutfB1iRYz7UTDPg5AeiaoRy6OO8ZlkDXWfmpWNFCcxZwOD2vXFQf9YcJKl/295RAT54CxjhTOXTF7WvEeUH5ekE5dLGOIWPkczxTABZeVK4PXEeghhmu4QsCdZwlDF0vhkBrVkLoeonue5nsFbJXswBd9znYmgRrdjvBgGcLQNdryqGL835tMUGXl9kyo91UrOjvmo0GftcM2e/XlQ+6Gf5gQuXL/l4SALiXgDG+IQxwiL0cdUa8zJYZ7erUxDeVQwzrKzBGw5rwhgDEzLGgjkg95Bq+KVDHt4RhcE4IAN9KCINv033vkM0lezcLMHi/g61JsOa1Ewx4ngAMvqccBjnv9yyBwVFuKlY0DI4CwiCy3+8rh8HX/MGEypf9vS0Ag28DY/xAOQzGnREvs2VGuTo18UPlEMP6CozRsCZ8IAAxH1lQR6Qecg0/FKjjx8Iw+FEIAD9OCIOf0H2fkn1G9nkWYHCqg61JsL5oJxjwFwIw+KVyGOS8v7QEBke6qVjRMDgSCIPIfn+lHAbf8wcTKl/294kADH4CjPFr5TAYd0a8zJYZ6erUxG+UQwzrKzBGw5rwtQDEfGtBHZF6yDX8RqCO3wnD4LchAPwuIQx+T/f9QPYj2U9ZgMEHHGxNgvVzO8GAfxaAwV+UwyDn/YslMDjCTcWKhsERQBhE9vtX5TD4pT+YUPmyv+8FYPB7YIy/KYfBuDPiZbbMCFenJv6uHGJYX4ExGtaE3wQg5g8L6ojUQ67h7wJ1/FMYBv8IAeCfCWHwL7rvb57xpfTrpYsfBh90ZGAwr9T/QSJgdo72m1+qGwY57/zS+QUG+RUZdBfmp2JFC82FwC+0F5TqFtVf/GGCypf9/SUAcH8BY2xTKruvvcyWidvXiPOC8tUWV0ORBxPWMWSMfI7blOI1rFC5PnAdgRpmuIZtBepYVIoFjNbQxX0K4KqoNBl0FdN9JWTtyEqzAF0POdiaBKusVDDgMgHoaq8cujjv9osJurzMlhnupmJFv4EbDnwDh+x3B+WDLt8fTKh82V+xAFQXA2PsKAxwiL0cdUa8zJYZ7urUxE7KIYb1FRijYU3oKAAxnS2oI1IPuYadBOrYRRgGO4cAsEtCGOxK93Uj607WIwsw+LCDrUmwepYKBtxTAAZ7KYdBzruXJTA4zE3FiobBYUAYRPa7t3IYbO8PJlS+7K+rAAx2Bca4lHIYjDsjXmbLDHN1amIf5RDD+gqM0bAmLCUAMX0tqCNSD7mGfQTq2E8YBvuGALBfQhjsT/cNIFuabJkswOA0B1uTYA0sFQx4oAAMLqscBjnvZS35OPby/FSsaKG5HPix1XLKRbWXP0xQ+bK//gI96Q+McXnlH8fG7WvEeUH5GqT8wYR1DBkjn+PlBWBhBeX6wHUEapjhGg4SqOOKwtC1Qgi0VkwIXSvRfSuTrUK2ahag6xEHW5NgrVYqGPBqAtC1unLo4rxXt+QN3MZuKlb0G7iNgW/gkP32lA+6Zf3BhMqX/a0kAHArAWM0yt/AxZ0RL7NlNnZ1amK5coh5hHwAYzSsCUYAYiosqCNSD7mG5QJ1rBSGwYoQAFYmhMEquq+arIasNgsw+KiDrUmw6koFA64TgME1lMMg572GJTA41E3FiobBoUAYRPZ7TeUwuLo/mFD5sr8qARisAsa4lnIYjDsjXmbLDHV1auLayiGG9RUYo2FNWEsAYtaxoI5IPeQari1Qx3WFYXCdEACumxAG16P71ifbgGzDLMDgYw62JsEaXCoY8GABGNxIOQxy3htZAoND3FSsaBgcAoRBZL+HKIfBNfzBhMr3f5AgAIPrAWMcqhwG486Il9kyQ1ydmrixcohhfQXGaFgThgpAzCYW1BGph1zDjQXqOEwYBjcJAeCwhDA4nO7blGwE2cgswOB0B1uTYI0qFQx4lAAMjlYOg5z36MUEg5nmPyk/FStaaCYBv8O0mXJR3cgfJqh82d9wgZ4MB8a4uTDAeZktE7evEecF5WsL5Q8mrGPIGPkcby4AC1sq1weuI1DDDNdwC4E6biUMXVuGQGurhNC1Nd23Ddm2ZNtlAboed7A1Cdb2pYIBby8AXTsohy7OewdL3sANdlOxot/ADQa+gUP2e0flg260P5hQ+bK/rQUAbmtgjDspfwMXd0a8zJYZ7OrUxJ2VQwzrKzBGw5qwkwDE7GJBHZF6yDXcWaCOuwrD4C4hANw1IQzW030NZI1kTVmAwSccbE2C1VwqGHCzAAy2KIdBzrvFkjdwk/NTsaKFZjLwTcVuykV1B3+YoPJlf/UCPakHxri78jdwcfsacV5QvsYofzBhHUPGyOd4dwFY2EO5PnAdgRpmuIZjBOq4pzB07RECrT0TQtdedN/eZPuQ7ZsF6HrSwdYkWPuVCga8nwB07a8cujjv/S15A7eBm4oV/QZuA+AbOGS/D1A+6Fr8wYTKl/3tJQBwewFjPFD5G7i4M+JltswGrk5NPEg5xLC+AmM0rAkHCkDMwRbUEamHXMODBOp4iDAMHhwCwEMSwuChdN9hZIeTHZEFGHzKwdYkWEeWCgZ8pAAMHqUcBjnvoyyBwfXdVKxoGFwfCIPIfo9VDoP7+4MJlS/7O1QABg8Fxni0chiMOyNeZsus7+rUxGOUQwzrKzBGw5pwtADEjLOgjkg95BoeI1DHY4VhcFwIAI9NCIPH0X3jyY4nOyELMPi0g61JsE4sFQz4RAEYPEk5DHLeJ1kCg+u5qVjRMLgeEAaR/T5ZOQwe5Q8mVL7s7zgBGDwOGOMpymEw7ox4mS2znqtTE09VDjGsr8AYDWvCKQIQc5oFdUTqIdfwVIE6ThCGwdNCADghIQyeTvedQXYm2VlZgMFnHGxNgnV2qWDAZwvA4DnKYZDzPscSGFzXTcWKhsF1gTCI7Pe5ymHwJH8wofJlf6cLwODpwBgnKofBuDPiZbbMuq5OTTxPOcSwvgJjNKwJEwUg5nwL6ojUQ67heQJ1vEAYBs8PAeAFCWHwQrrvIrKLyS7JAgw+62BrEqxLSwUDvlQABi9TDoOc92WLCQYzzf/O/FSsaKG5E/iF9suVi+o5/jBB5cv+LhToyYXAGK8QBjgvs2Xi9jXivKB8Xan8wYR1DBkjn+MrBGDhKuX6wHUEapjhGl4pUMerhaHrqhBoXZ0Quq6h+64lm0R2XRag6zkHW5NgXV8qGPD1AtB1g3Lo4rxvsAS6puSnYkULzRTgcLpRuahe5g8TVL7s7xqBnlwDjHGycuiK29eI84LydZNy6GIdQ8bI53iyACzcrFwfuI5ADTNcw5sE6niLMHTdHAKtWxJC1610321kt5PdkQXomuFgaxKsO0sFA75TALruUg5dnPddlkDX1PxUrGihmQocTncrF9Ub/GGCypf93SrQk1uBMd6jHLri9jXivKB8TVEOXaxjyBj5HN8jAAv3KtcHriNQwwzXcIpAHe8Thq57Q6B1X0Loup/um0r2ANmDWYCu5x1sTYL1UKlgwA8JQNfDyqGL837YEuh6OD8VK1poHgYOp2nKRfUuf5ig8mV/9wv05H5gjI8oh664fY04LyhfjyqHLtYxZIx8jh8RgIXHlOsD1xGoYYZr+KhAHacLQ9djIdCanhC6Hqf7niB7kuypLEDXTAdbk2A9XSoY8NMC0PWMcujivJ+xBLoey0/Fihaax4DD6VnlovqwP0xQ+bK/xwV68jgwxueUQ1fcvkacF5SvGcqhi3UMGSOf4+cEYOF55frAdQRqmOEazhCo40xh6Ho+BFozE0LXC3Tfi2SzyF7KAnS94GBrEqyXSwUDflkAul5RDl2c9yuLCbq8zJapc1Oxov9UZR3wT1Ui+/2q8kH3jD+YUPmyvxcEAO4FYIyzhQEOsZejzoiX2TJ1rk5NfE05xLC+AmM0rAmzBSDmdQvqiNRDruFrAnV8QxgGXw8B4BsJYfBNum8O2Vtkb2cBBl90sDUJ1julggG/IwCDc5XDIOc91xIYrHVTsaJhsBYIg8h+v6scBl/xBxMqX/b3pgAMvgmMcZ5yGIw7I15my9S6OjXxPeUQw/oKjNGwJswTgJj3LagjUg+5hu8J1PEDYRh8PwSAHySEwQ/pvo/IPib7JAswOMvB1iRYn5YKBvypAAx+phwGOe/PLIHBGjcVKxoGa4AwiOz358phcK4/mFD5sr8PBWDwQ2CMXyiHwbgz4mW2TI2rUxO/VA4xrK/AGA1rwhcCEPOVBXVE6iHX8EuBOn4tDINfhQDw64Qw+A3d9y3Zd2TfZwEGX3KwNQnWD6WCAf8gAIM/KodBzvtHS2Cw2k3FiobBaiAMIvv9k3IY/MwfTKh82d83AjD4DTDGn5XDYNwZ8TJbptrVqYm/KIcY1ldgjIY14WcBiPnVgjoi9ZBr+ItAHX8ThsFfQwD4W0IY/J3u+4PsT74/CzD4soOtSbD+LhUM+G8BGHTKdMMg580xOli/IoPu2fxUrGiheRb4hXa3TLeo/ugPE1S+7O93AYD7HRhjXpnsvvYyWyZuXyPOC8pXfhlQEwX2NesYMkY+x7xv0BpWoFwfuI5ADTNcw3yBOrYpwwJGa+jiPgVw1aYsGXS1pfsKyYrIissWP3S94mBrEqySMsGAS8rwftsphy7Ou50l0DUzPxUrWmhmAodTqXJRdfxhAtuTZSmxQcfZFhhjmXLoitvXiPOC8tVeOXSxjiFj5HNcJgALHZTrA9cRqGGGa9heoI4dhaGrQwi0OiaErk50X2eyLmRdswBdrzrYmgSrW5lgwN0EoKu7cujivLtbAl0v5adihb9SBw6nHspFtZ0/TFD5sr9OAj3pBIyxp3LoitvXiPOC8tVLOXSxjiFj5HPcUwAWeivXB64jUMMM17CXQB2XEoau3iHQWiohdPWh+/qS9SPrnwXomu1gaxKsAWWCAQ8QgK6llUMX5720JdA1Oz8VK1poZgOH0zLKRbW7P0xQ+bK/PgI96QOMcaBy6Irb14jzgvK1rHLoYh1DxsjneKAALCynXB+4jkANM1zDZQXquLwwdC0XAq3lE0LXILpvBbIVyVbKAnS95mBrEqyVywQDXlkAulZRDl2c9yqWQNeb+alY0ULzJnA4rapcVJf2hwkqX/Y3SKAng4AxrqYcuuL2NeK8oHytrhy6WMeQMfI5Xk0AFjzl+sB1BGqY4RquLlBHIwxdXgi0TELoKqf7KsgqyaqyAF2vO9iaBKu6TDDgagHoqlEOXZx3zWKCLi+zZXgncKzoP1XpAf9UJbLftcoH3Sr+YELly/7KBQCuHBhjnTDAIfZy1BnxMlvGc3Vq4hrKIYb1FRijYU2oE4CYNS2oI1IPuYZrCNRxLWEYXDMEgGslhMG16b51yNbl2LIAg2842JoEa/0ywYDXF4DBDZTDIOe9gSVv4Obmp2JFC81c4JuKDZWLao0/TFD5sr+1BXqyNjDGwcrfwMXta8R5QfnaSPmDCesYMkY+x4MFYGGIcn3gOgI1zHANNxKo41Bh6BoSAq2hCaFrY7pvE7JhZMOzAF1vOtiaBGvTMsGANxWArhHKoYvzHmHJG7jV3FSs6DdwqwHfwCH7PVL5oNvAH0yofNnfxgIAtzEwxlHK38DFnREvs2VWc3Vq4mjlEMP6CozRsCaMEoCYzSyoI1IPuYajBeq4uTAMbhYCwM0TwuAWdN+WZFuRbZ0FGJzjYGsSrG3KBAPeRgAGt1UOg5z3tpa8gfsgPxUrWmg+AL6p2E65qI7whwkqX/a3hUBPtgDGuL3yN3Bx+xpxXlC+dlD+YMI6hoyRz/H2ArCwo3J94DoCNcxwDXcQqONOwtC1Ywi0dkoIXTvTfbuQ7UpWnwXoesvB1iRYDWWCATcIQFejcujivBstga5P8lOxooXmE+BwalIuqtv6wwSVL/vbWaAnOwNjbFYOXXH7GnFeUL5alEMX6xgyRj7HzQKwsJtyfeA6AjXMcA1bBOq4uzB07RYCrd0TQtcYum8Psj3J9soCdL3tYGsSrL3LBAPeWwC69lEOXZz3PpZ87Lmym4oV/bHnysCPPZH93lf5oGv0BxMqX/Y3RgDgxgBj3E/5x55xZ8TLbJmVXZ2auL9yiGF9BcZoWBP2E4CYAyyoI1IPuYb7C9TxQGEYPCAEgAcmhMGD6L6DyQ4hOzQLMPiOg61JsA4rEwz4MAEYPFw5DHLeh1sCgyu5qVjRMLgSEAaR/T5COQzu4w8mVL7s7yABGDwIGOORymEw7ox4mS2zkqtTE49SDjGsr8AYDWvCkQIQM9aCOiL1kGt4lEAdjxaGwbEhADw6IQweQ/eNIzuW7LgswOBcB1uTYI0vEwx4vAAMHq8cBjnv4y35OPar/FSsaKH5Cvix1QnKRfVwf5ig8mV/xwj05BhgjCcq/zg2bl8jzgvK10nKH0xYx5Ax8jk+UQAWTlauD1xHoIYZruFJAnU8RRi6Tg6B1ikJoetUuu80sglkp2cBut51sDUJ1hllggGfIQBdZyqHLs77TEvewK3gpmJFv4FbAfgGDtnvs5QPuuP9wYTKl/2dKgBwpwJjPFv5G7i4M+JltswKrk5NPEc5xLxLPoAxGtaEswUg5lwL6ojUQ67hOQJ1nCgMg+eGAHBiQhg8j+47n+wCsguzAIPzHGxNgnVRmWDAFwnA4MXKYZDzvtgSGBzkpmJFw+AgIAwi+32Jchg80x9MqHzZ33kCMHgeMMZLlcNg3BnxMltmkKtTEy9TDjGsr8AYDWvCpQIQc7kFdUTqIdfwMoE6XiEMg5eHAPCKhDB4Jd13FdnVZNdkAQbfc7A1Cda1ZYIBXysAg5OUwyDnPcmSj2N/yE/FihaaH4AfW12nXFQv9ocJKl/2d6VAT64Exni98o9j4/Y14rygfN2g/MGEdQwZI5/j6wVg4Ubl+sB1BGqY4RreIFDHycLQdWMItCYnhK6b6L6byW4huzUL0PW+g61JsG4rEwz4NgHoul05dHHet1sCXb/kp2JFC80vwOF0h3JRneQPE1S+7O8mgZ7cBIzxTuXQFbevEecF5esu5dDFOoaMkc/xnQKwcLdyfeA6AjXMcA3vEqjjPcLQdXcItO5JCF1T6L57ye4juz8L0PWBg61JsKaWCQY8VQC6HlAOXZz3A5ZA1x/5qVjRQvMHcDg9qFxUb/eHCSpf9jdFoCdTgDE+pBy64vY14rygfD2sHLpYx5Ax8jl+SAAWpinXB64jUMMM1/BhgTo+Igxd00Kg9UhC6HqU7nuMbDrZ41mArg8dbE2C9USZYMBPCEDXk8qhi/N+0hLo4h38pMCAZ7+oGJ9SLqoP+MMElS/7e1SgJ48CY3xaOXTF7WvEeUH5ekY5dLGOIWPkc/y0ACw8q1wfuI5ADTNcw2cE6vicMHQ9GwKt5xJC1wy673mymWQvZAG6PnKwNQnWi2WCAb8oAF2zlEMX5z3LEugqKEjFihaaAuBwekm5qD7pDxNUvuxvhkBPZgBjfFk5dMXta8R5Qfl6RTl0sY4hY+Rz/LIALLyqXB+4jkANM1zDVwTqOFsYul4NgdbshND1Gt33OtkbZG9mAbo+drA1CdacMsGA5whA11vKoYvzfssS6CoqSMWKFpoi4HB6W7mozvKHCSpf9veaQE9eA8b4jnLoitvXiPOC8jVXOXSxjiFj5HP8jgAsvKtcH7iOQA0zXMO5AnWcJwxd74ZAa15C6HqP7nuf7AOyD7MAXZ842JoE66MywYA/EoCuj5VDF+f98WKCLi+zZQa4qVjRf5XFAOBfZYHs9yfKB91b/mBC5cv+3hMAuPeAMX4qDHCIvRx1RrzMlhng6tTEz5RDDOsrMEbDmvCpAMR8bkEdkXrINfxMoI5fCMPg5yEA/CIhDH5J931F9jXZN1mAwU8dbE2C9W2ZYMDfCsDgd8phkPP+zhIY7O+mYkXDYH8gDCL7/b32tx7+YELly/6+FIDBL4Ex/qAcBuPOiJfZMv1dnZr4o3KIYX0FxmhYE34QgJifLKgjUg+5hj8K1PFnYRj8KQSAPyeEwV/ovl/JfiP7PQsw+JmDrUmw/igTDPgPARj8UzkMct5/WgKD/dxUrGgY7AeEQWS//1IOg9/5gwmVL/v7RQAGfwHG+LdyGIw7I15my/RzlWpie90Qw/oKjNGwJvwtADGuBXVE6iHXkPuCrmNeeyz4tIZB7lMAfXntk8FgPt1XQNaGrG37xQ+DnzvYmgSrsL1gwIXtBb530143DHLeRe3nFxjkVyTWvm4qVjQM9gXCILLfxcAhwj7QAv2nP5hQ+f4PYtrj48wH9qSkvewZQezlqDPiZbZMX1enJrZTDjGsr8AYDWtCiQDElFpQR6Qecg3bCdSxTBgGS0MAWJYQBtvTfR3IOpJ1ygIMfuFgaxKszu0FA+4sAINdlMMg593FEhjs46ZiRcNgHyAMIvvdVTkMFvmDCZUv+2svAIPtgTF2Uw6DcWfEy2yZPq5OTeyuHGJYX4ExGtaEbgIQ08OCOiL1kGvYXaCOPYVhsEcIAHsmhMFedF9vsqXI+mQBBr90sDUJVt/2ggH3FYDBfsphkPPuZwkMLuWmYkXD4FJAGET2u79yGOziDyZUvuyvlwAM9gLGOEA5DMadES+zZZZydWri0sohhvUVGKNhTRggADHLWFBHpB5yDZcWqONAYRhcJgSAAxPC4LJ033Jky5MNygIMfuVgaxKsFdoLBryCAAyuqBwGOe8VLYHB3m4qVjQM9gbCILLfKymHwX7+YELly/6WFYDBZYExrqwcBuPOiJfZMr1dnZq4inKIYX0FxmhYE1YWgJhVLagjUg+5hqsI1HE1YRhcNQSAqyWEwdXpPo/MkJVnAQa/drA1CVZFe8GAKwRgsFI5DHLelZbAYC83FSsaBnsBYRDZ7yrlMLiiP5hQ+bK/1QVgcHVgjNXKYTDujHiZLdPL1amJNcohhvUVGKNhTagWgJhaC+qI1EOuYY1AHeuEYbA2BIB1CWFwDbpvTbK1yNbOAgx+42BrEqx12gsGvI4ADK6rHAY573UtgcGebipWNAz2BMIgst/rKYfBSn8wofJlf2sIwOAawBjXVw6DcWfEy2yZnq5OTdxAOcSwvgJjNKwJ6wtAzIYW1BGph1zDDQTqOFgYBjcMAeDghDC4Ed03hGwo2cZZgMFvHWxNgrVJe8GANxGAwWHKYZDzHmYJDPZwU7GiYbAHEAaR/R6uHAbX9QcTKl/2t5EADG4EjHFT5TAYd0a8zJbp4erUxBHKIYb1FRijYU3YVABiRlpQR6Qecg1HCNRxlDAMjgwB4KiEMDia7tuMbHOyLbIAg9852JoEa8v2ggFvKQCDWymHQc57K0tgsLubihUNg92BMIjs99bKYXCYP5hQ+bK/0QIwOBoY4zbKYTDujHiZLdPd1amJ2yqHGNZXYIyGNWEbAYjZzoI6IvWQa7itQB23F4bB7UIAuH1CGNyB7tuRbCeynbMAg9872JoEa5f2ggHvIgCDuyqHQc57V0tgsJubihUNg92AMIjsd71yGNzKH0yofNnfDgIwuAMwxgblMBh3RrzMlunm6tTERuUQw/oKjNGwJjQIQEyTBXVE6iHXsFGgjs3CMNgUAsDmhDDYQvftRrY72ZgswOAPDrYmwdqjvWDAewjA4J7KYZDz3tMSGOzqpmJFw2BXIAwi+72Xchjc1R9MqHzZX4sADLYAY9xbOQzGnREvs2W6ujo1cR/lEMP6CozRsCbsLQAx+1pQR6Qecg33EajjfsIwuG8IAPdLCIP7030HkB1IdlAWYPBHB1uTYB3cXjDggwVg8BDlMMh5H2IJDHZxU7GiYbALEAaR/T5UOQzu6Q8mVL7sb38BGNwfGONhymEw7ox4mS3TxdWpiYcrhxjWV2CMhjXhMAGIOcKCOiL1kGt4uEAdjxSGwSNCAHhkQhg8iu4bS3Y02TFZgMGfHGxNgjWuvWDA4wRg8FjlMMh5H2sJDHZ2U7GiYbAzEAaR/T5OOQwe4g8mVL7s7ygBGDwKGON45TAYd0a8zJbp7OrUxOOVQwzrKzBGw5owXgBiTrCgjkg95BoeL1DHE4Vh8IQQAJ6YEAZPovtOJjuF7NQswODPDrYmwTqtvWDApwnA4ATlMMh5T7AEBju5qVjRMNgJCIPIfp+uHAaP9QcTKl/2d5IADJ4EjPEM5TAYd0a8zJbp5OrUxDOVQwzrKzBGw5pwhgDEnGVBHZF6yDU8U6COZwvD4FkhADw7IQyeQ/edSzaR7LwswOAvDrYmwTq/vWDA5wvA4AXKYZDzvsASGOzopmJFw2BHIAwi+32hchic4A8mVL7s7xwBGDwHGONFymEw7ox4mS3T0dWpiRcrhxjWV2CMhjXhIgGIucSCOiL1kGt4sUAdLxWGwUtCAHhpQhi8jO67nOwKsiuzAIO/OtiaBOuq9oIBXyUAg1crh0HO+2pLYLCDm4oVDYMdgDCI7Pc1ymHwAn8wofJlf5cJwOBlwBivVQ6DcWfEy2yZDq5OTZykHGJYX4ExGtaEawUg5joL6ojUQ67hJIE6Xi8Mg9eFAPD6hDB4A913I9lkspuyAIO/OdiaBOvm9oIB3ywAg7coh0HO+xZLYLC9m4oVDYPtgTCI7PetymHwan8wofJlfzcIwOANwBhvUw6DcWfEy2yZ9q5OTbxdOcSwvgJjNKwJtwlAzB0W1BGph1zD2wXqeKcwDN4RAsA7E8LgXXTf3WT3kE3JAgz+7mBrEqx72wsGfK8ADN6nHAY57/ssgcEyNxUrGgbLgDCI7Pf9ymHwFn8wofJlf3cJwOBdwBinKofBuDPiZbZMmatTEx9QDjGsr8AYDWvCVAGIedCCOiL1kGv4gEAdHxKGwQdDAPhQQhh8mO6bRvYI2aNZgME/HGxNgvVYe8GAHxOAwenKYZDznm4JDJa6qVjRMFgKhEFkvx9XDoP3+YMJlS/7e1gABh8GxviEchiMOyNeZsuUujo18UnlEMP6CozRsCY8IQAxT1lQR6Qecg2fFKjj08Iw+FQIAJ9OCIPP0H3Pkj1HNiMLMPing61JsJ5vLxjw8wIwOFM5DHLeMy2BwXZuKlY0DLYDwiCy3y8oh8Hp/mBC5cv+nhGAwWeAMb6oHAbjzoiX2TLtXJ2aOEs5xLC+AmM0rAkvCkDMSxbUEamHXMNZAnV8WRgGXwoB4MsJYfAVuu9Vstlkr2UBBv9ysDUJ1uvtBQN+XQAG31AOg5z3G5bAYImbihUNgyVAGET2+03lMDjTH0yofNnfKwIw+AowxjnKYTDujHiZLVPi6tTEt5RDDOsrMEbDmjBHAGLetqCOSD3kGr4lUMd3hGHw7RAAvpMQBufSfe+SzSN7Lwsw+LeDrUmw3m8vGPD7AjD4gXIY5Lw/sAQGi91UrGgYLAbCILLfHyqHwTf8wYTKl/3NFYDBucAYP1IOg3FnxMtsmWJXpyZ+rBxiWF+BMRrWhI8EIOYTC+qI1EOu4ccCdfxUGAY/CQHgpwlh8DO673OyL8i+zAIMOi62JsH6qr1gwF8JwODXymGQHX5tCQwW+bGiYbAICIPIfn+jHAY/8AcTKl/295kADH4GjPFb5TAYd0a8zJYpcnVq4nfKIYYbDIzRsCZ8KwAx31tQR6Qecg2/E6jjD8Iw+H0IAH9ICIM/0n0/kf1M9ksWYNAVgsFf2wsG/KsADP6mHAY5798sgcFCP1Y0DBYCYRDZ79+Vw+DX/mBC5cv+fhSAwR+BMf6hHAbjzoiX2TKFrk5N/FM5xLC+AmM0rAl/CEDMXxbUEamHXMM/Ber4tzAM/hUCwL8TwqDTga6T5ZHld1j8MJgnBIMFHQQDZudov2066IZBzrtNh/kFBvkVibWtHysaBtsCYRDZ77YddMPgb/5gQuX7v4eSDgJvFYA9Kewge0YQeznqjHiZLdPW1amJRR10QwzrKzBGw5pQ2EHg6wUW1BGph1zDIoE6lnTAgk9rGOQ+BdBX0iEZDLaj+0rJysjaZwEG84VgsEMHwYA7CMBgR+UwyHl3XEwwmGn+gwpSsaKFhv2iYuykXFTb+MMElS/7ayfQk3bAGDsLA5yX2TJx+xpxXlC+uih/MGEdQ8bI57izACx0Va4PXEeghhmuYReBOnYThq6uIdDqlhC6utN9Pch6kvUKQVe4T1FrPVCt/weIor9HTbmM3+oWu/zWVMr4rZKqQ4WQ31ohv1WW1aHhH4d84PkgLq4DHwgrehB09Adg4C/j/05uh5RAouGpO3ig/tPEPGfxNbFA9PfIqXZqhVQ7W6c0WPBvezsCp8Bx7JEV9LMTMmekRPHGzXcW09f7cL688EHr7b9vWqpDqwTQn2C4wA3RO/mmbVyIL7OUpRsiz5HZEH38jdBXekPkATdEH+CG6At+mi0iKw7V8R/ftRXNNXXGNNVWVHl1NdXldRRBdU1VhWlpNFWN9S1NNXX1tXUNzc2NDRV1dV5FS3VdVU15Y3VFdUtlfVX9X638mfqalqrmlvr6ppqWCnJQXlVfZ2pbKrzGxtqmmoqKipbGxvqGGvrlxjqvxVQ2NdeahsbGqvLalrq6iqqmv7D99f6z4asq6+trq+trKhobausrKqvKq5qrGhqam6qbKysa6o2pq22urfZaqloq6qq88uralhrT1FJZVWcamporvfLW8ZV7dU2NLQ0t5fQ/VTUtdS3VXiVVprKpxtQ3VrfUt9TWlNNv2dJYU+nVNHqVzQ3V5aa+ury2prG+0ZRXS+db3tRS21BX6TVX1dZ5zZW0HWtqmr2qipqKlvrm6rp601RTVUk9rahqpqLUeg3V1dV1lTWV1P/yxqbG//SjvLmxqba2yVTVVdc0NFZVNNTWUm3Km70mU11bXW0o18aG6vr6xvKmipbaquZyyrOmubmlobzR1NFmk8i3re+Lf+4dejOzVOjnPqGf+/o/A+MoR+fF/vpRnP3JBoTeHC0uPO0s+nuIPXVLPX80yfit8YT8Cr0tkXrLJfZ2x7a3cs0yfqX2Q3WjZX7rhPxWWxavlD7Mf6/0/+19Sj+pt4ptFmOROon+Hjn1EvabU6+UX3n1gvoVowXbaExqnxkZv7bpzv/jTzPyHYHpG17oTwuAAUPRY3G+HAb6+tfL4aX9l8LLSL8cRm6IpYEvh5cReDlcGqrjP75zL4f/X78cNo2VlS3l9VXl9LvXGtp29bUVFEAV7cLG5toG2p3GK6/kAtCPtaauoaGpvqWqvry+qb6W3hHX/ie+ivr65uaK6ubqyvJyerXsmTpTXVFOuVbV1dU31zU30KZopDfBNfW1jXXlXn19BW2i2obausaqFvrNcy/DM8+3yPfFPy8deum9TOjnLL0kr5B4ST6Q4lyWbLlWwwD9NYUC4J8PHQjW73++purO733waoE/HCl05n8AyF8Hbeek9L6MzP/jlk5HJ/V6gF/8dyHrStaNrDtZD7KeZL147/Ce4b3Ce4SsH1l/sgG833ifcU/IliVbjmx5skFkK5CtSLYS2cpkq5CtSrYa2epcBzIeuPwMxp8OMMsyf/MzQw0Zf6+QnyfXIFuTbC2ytcnWIVvX7/P6ZBuQbUg2mGwjsiFkQ8k2JtuEbBjZcLJNyUaQjSQbRTaabDOyzcm2INuSbCuyrcm2IduWbDuy7cl2INuRbCeyncl2IduVrJ6sgYz5nj8x4Pch/Oy3G9nuZGPI9iDbk2wvsr3J9iHbl2w/sv3JDiA7kOwgsoPJDiE7lOwwssPJjiA7kuwosrFkR5MdQzaO7Fiy48jGkx1PdgLZiWQnkZ1MdgrZqWSnkU0gO53sDLIzyc4iO5vsHLJzySaSnUd2PtkFZBeSXUR2MdklZJeSXUZ2OdkVZFeSXUV2Ndk1ZNeSTSK7jux6shvIbiSbTHYT2c1kt5DdSnYb2e1kd5DdSXYX2d1k95BNIbuX7D6y+8mmkj1A9iDZQ2QPk00je4TsUbLHyKaTPU72BNmTZE+RPU32DNmzZM+RzSB7nmwm2QtkL5LNInuJ7GWyV8heJZtN9hrZ62RvkL1JNofsLbK3yd4hm0v2Ltk8svfI3if7gOxDso/IPib7hOxTss/IPif7guxLsq/Ivib7huxbsu/Ivif7gexHsp/Ifib7hexXst/Ififj/7Iq/we1WAP5r8/lQ8/nn/+MJH9lP2BhXqyFYegvCNF/MC8m+P9fHPp3fLcO8mGmOOQX7b/Wq2wJf8lBIP6K4pBPAf8Ngf8CGf9eoe9n8Lh/+3da/b75re5r/e+E79kodM9GoXvCvoeE7hkSc8/Q0D1DY+7ZOHTPxjH3bBK6Z5OYe4aF7hkWc8/w0D3DY+7ZNHTPpjH3jAjdMyLmnpGhe0a2uqcs9HOwBvv3BPtF4rzSeaoS3o/1Za3q4ITyDH7vNjK/d4Pb6vdznH+fBafV71/iiJ79f96ktWkVT+v6BL0uC+4ZNz+e1r9WMO6/eQS/1ib0a0F/eR4MDN0XtbeC+1YL/by6/3PQM0l9l9rvvLpExB/+vXgVjnP+WUE98kPXgroGdS4K39/q14pDv1Yw7t+/T4n/z8FLu9a+gjjatLp/Vf+fg0eitqF/J/j3O0b8/m1b/f7/ijviWuu6FEfcXxxxPz+TLO//3M433kMnBv+O899zFv7mrpfRqjBRmobzX90YpVs4/zXlgf+2MvWpD/wXytSnLvBfJFOffxiqWMZ/U+C/RKY+tYH/diL+y//Zn6Uy9akM/JfJ1Ocf/+1l/P+zfzqI+K/wAv8dZeL/h9k6yfivCfx3ltk//zxjdZGJvznw31XEf3l5wE3dnPmrNdN2D13H8YtpTsq0we9f0ipWKabt3iqe1vUJcyv/Wo+IWDtG/FrrGdIj4vfpEfH7RPnqCvTVHuirEOirC9BXGdAXsvZtlcbVGeirFOirDdCX1r3aCegLuSfaKY2rAOirI9CX1j2BPI8lQF9adTUf6KsD0FfwzBj1DoLXev7/exmuINaCiFjzImIN7o96NxjFUaWhe/c7YMw+BzmtVvg3DpyHfw5+vSQmgL6t/v38GL+t/Yf/uWQhv943whcLZtCkgnH//v3X8697Gaya2vlfHAle1rVx/v0C1mn1+7dpdf9p/j+H8wv+vyCDOFtq6k1LRX1LfVV9U1NlY33nVv555YXqdLv/s+Uf6lVb/qFeuU0f6v0//rDJZPHDpnK31e8X7kf415a0D5t6he6L2lvBfcuGfl7O/1n4w6bq3IdN8++P+7BpoP/Pmj9s6uP/HP6waXLw7zjRQLqe/89eRqu6WvjDplrZD5vmv0yW+bCppk72w6b5H2bJfNg0/8MsoQ+bGmQ/bKrxZD9smv9hkMyHTfM/bJX5sGn+h61CHzZVyn7YNP/DLJkPm+Z/GCrzYdP8D+tlPmya/2GWzIdN8z9slfmwqfqf+nST8d8c9YEVsD7lrT/wCX4PXsHv3TN0HcdfFZVJmTz4/UtaxSrF5D1bxdO6PmHu5l/rFRFrx4hfaz2jekX8Pr0ifp8oX92BvjoAfRUBfXUD+moP9IWsfaHSuLoCfZUp9YXMsS3QF7KPXZTGVQr01QboC6k5nYG+2gF9FQB9adXCTkBfWs8Qck8g9asE6At5trXu1RwXZk+jc1y4aL7ygb6QewKpE0g20bq/Ogr4sulLG1HP87AvbbgxAVS0+vcX5UsbC/q14J8rIu614Qsbt/n/nO0vbIz3f7b8Cxt1ln9hQ/qLCP+v/xT2/+MvkFRm8QskVW6r389xcl8gYYDrG7ovam8F960Q+nlF/2fhL5DU5b5AMv/+uC+QDPL/WfMXSAb4P4e/QDI2+Hec/54ztvX8f/YyWhWVuT+tvKCV+9PKC4m/VvYLJPM/4Lb0CyTSf1q5QfYLJPO/gCH0BZIq4T+tXCP7BZL5f5pY6AskzcJfIPnnCxLBh4XB78Er6ssfOL4wTUmZM/j9S1rFKsWc3VrF07o+Ya7kX+seEWvHiF9rrfFRf2q5e8TvE+WrC9BXGdBXIdBXZ6CvUqAvZO3bKo2rE9BXO6CvNkBfWvdqR6Av5J4oURpXAdBXB6AvrXsCeR6Lgb606mo+0FfA6TZ9mBTFPrAPkwpiAujT6t9flA+TWv8ecb/eJ8KXDR8oHef/c7Y/UAr+1JzlHyjVLK4PlCTr01pMpD9QinoRvqAPZ/jhJxA//rlj6N/htVHIt9vq14ZE/L6SOS+GD3vKu0TEXxDKjdeG45x/Vpq/r2l9IXjB3M/3l+9ED7lwTK0HR/h+J+KaG+Enr9W9/2hghL8g73wnXsdbxxZVRyfiWlRs+QuJrSAittZ+8xaQR9zvE46p9UuF1oM5/GtRsdswtwb6/5ztuTXR/9nuuVW12OaWzFwxFbkvQvz759b3LIl/HX1wz6jQPaNi7hkdumd0zD2bhe7ZLOaezUP3bB5zzxahe7aIuWfL0D1bxtyzVeierWLu2Tp0z9at7vn/+wUYU569L8CYCrfV7+c4Tu4LME7qP6cU3Be1t4L7qkM/1/g/y34Bpqom9wWY+ffHfQEm+M/Mav4CTPCfegh/AeaM4N9x/nvO2Nbz/9nLaOX+uv4Fr9wXYBbiP/fX9S9w5f66/gWvitrcX9e/oJX76/rTX7m/rj/31/Uv2Ffur+vPXly5v64/e3s199f1L5qv3F/Xn73zmPvr+hfNV+6v6//v/bAv63SOCQDx1/V3Xsiv2/rX9Z/r/3O2P/QM4rD8Q0/L/7p+Y9Vf15/70DP3oafT6ufW92T6oef/4w80s/ifhDC5/yRE6NfCH2iuFLovam8F91WFfg4+3BT+QDP3n4QI3R/3gWal/8+aP9Bc1f85/IHm6cG/4/z3nLGt5/+zl9HKfaC54JX7QHMh/nMfaC5w5T7QXPCqqMl9oLmglftAM/2V+0Az94Fm7gPN3Aeai+Yr94Fm9vZE7gPN/x97IveB5qL5yn2g+e9zFo41LyLW4P7F/oFmp5gAEB9odlrIr9v6geY5/j9n+wPNoL5BvYT+alwv8N9Wxv8/H5gWyvivKHT+u8LX/ulv6Pd3Wv0cxBQWEIFY692I+PJb/Z6tYwzf0/pPfvPKa/XPBa2u5ye4t/XvF/618H8fIO7fK46INXwt2Ftlzn9X674ED4VtYnwVhn49fH9hq3uletglIiY35veWejAP/Av9VYFe1JkKD6qurfIM76v1QDEE/oI90Mb578pr9WvhD7jC8bn4+IzTakXpS7CCPRP+q4aCev4f6entgnuRDgA=","debug_symbols":"7Z3brh3HlWX/Rc96yBWx4uZfaTQKvlVBgGEZvjTQMPzvnZRFSiVSPJ1nelGjfOZLoSjvS2jm5lyp2HuM+PtXv/v9b/72X//xzR//89u/fPWr//X3r/7w7W9//ddvvv3j/ae/f3V994/+8qdf//Hdn/7y11//+a9f/WpnfP3V7//4u/v/m9c/vv7qP7/5w++/+tXs//j6o4eOGPv7x45Y88ODV/vEg/Ma6/sH57X6hwfH/sf//vqr4CylcZbSOUtJzlIGZymTs5TFWcrmLOWAKo5Ut6C+DVDhBqhxA1S5AercAJVugFo3QLUboN5toN5tpPtcUO82UO82UO82UO82UO82UO82UO82UO92UO92UO920gYDqHc7qHc7qHc7qHc7qHc7qHc7qHcT1LsJ6t0E9W6SdnZBvZug3k1Q7yaodxPUuwnq3QHq3QHq3QHq3QHq3QHq3QHq3QHq3QHq3QHq3QHq3Qnq3Qnq3Qnq3Qnq3Qnq3Un6LQOodyeodyeodyeodxeodxeodxeodxeodxeodxeodxfpR2Sg3l2g3l2g3t2g3t2g3t2g3t2g3t2g3t2g3t2g3t2kX++CeneDeveAeveAeveAeveAeveAeveAeveAeveAeveQsAkUN0ECJy4SOXGR0ImLxE5coPKNi0RPXCR84iLxExcJoLhIDcxC10gNjILXUPQaCl9D8WsogA1FsKEQNhLDFiSILUgUW5AwtiBxbEEC2YJEsgUJZQsSyxYkmC1INFuQcLYg8WxBAtqCRLQFCWkLEtMWJKgtSFRbkLC2IHFtQQLbgkS2BQltCxLbFiS4LUh0W5DwtiDxbUEC3IJEuAUJcQsS4xYkyC1IlFuQMLcgcW5BAt2CRLoFCXULEusWJNgtSLRbkHC3IPFuQQLegkS8BQl5CxLzFiToLUjUW5CwtyBxb0EC34JEvgUJfQsS+xYk+C1I9FuQ8Lcg8W9BAuCCRMAFCYELEgMXJAguSBRckDC4IHFwQQLhgkTCBQmFCxILFyQYLkg0XJBwuCDxcEEC4oJExAUJiQsSE9dITFwjMXGNxMQ1EhPXLlADNxIT10hMXCMxcY3ExDUSE9dITFwjMXGNxMQ1EhPXSExcIzFxjcTENRIT10hMXEOd64Y62I11shupgVFnu6EOd0Od7oY63g11vhvqgDcSE9dITFwjMXGNxMQ1EhPXSExcIzFxjcTENRIT10hMXCMxcY3ExDUSE9dITFwjMXGNxMQ1EhPXSExcIzFxjcTENRIT10hMXCMxcY3ExDUSE9dITFwjMXHtCzNxmf39YnK0jxazSIv5sg3czw+Lua6PFnNAi/nCTNwLiwnQZ+YLM3EvJNNJySQpmUFKZpKSITXwJDXwF2biPp/M+gUbeH+0mCAtppEuE6mBV5Iu0yAtZpIWs0iL2aQPMKmBN+keeAdpMaR74E1q4J2kZEj3wJvUwJvUwJvUwJvUwIfUwIfUwIfUwIfUwIfUwIfUwIe0C3FIuxBng8bBOZzF9C/MxH32MvULtA/cL1AD9y/MxL2wGFAD9wvUwP0CNXC/QA3cL1AD94vUwEFq4CA1cDTSZeqkxSRpMaB94B6g30L0IDVwkBo4SA3cQN/E9Qb6Jq430DdxvYF2IXpL0J1eG6TFkO6BG6mBG+i3EL2B9oF7JzVwJzVwJzVwJzVwT9JlIt0Dd9A3cb2DvonrHfRNXO+kBk5SAyepgZO0C5GkXYgvzMS98AEm7QMn6R44F2kxpHvgJDXwAP0Wog/SPvAgNfAgNfAgNfAgNfAgNfAgNTCJieuD1MCTdA88SffAk7QLQWLi+i/JxH18mUi7EJO0CzFJuxCTtAtBYuI6iYnrJCauL9I98CLdA39hJu6FDzDpHniR7oEX6R54ke6BSUxcJzFxfZN2IUhMXCcxcZ3ExHUSE9dJTFwnMXGdxMR1EhPXSUxcJzFxncTEdRIT10lMXCcxcf2QGviQGviQGviAGjgv0C5EXqBdiLxAuxB5gXYh8krSBxjUwEli4vIC7ULkBdqFyIvUwAG6B04SE5cBugfOAN0DJ4mJSxITlyQmLklMXJKYuCQxcUli4pLExCWJiUsSE5ckJi5JTFySmLgkMXHZSA3cSA3cQV6I7KR74E66B+4gM092UgN30i5EJzVwJzVwJ+1CkJi4TNIuRJIaOEkNnKR74CQ1MImJSxITl0lq4CTdAyfpHniQ7oFJTFwOUgMP0j3wIDUwiYnLAfotRA7QbyFygH4LkSQmLknnxOUE/RotSefEJYmJS9I5cUk6Jy5JTFySmLgkMXFJYuKSxMQliYlLEhOXJCYuSUxckpi4JDFxSWLiksTEJYmJy01q4E1q4E36LQSJictfkon7+DKRfo1GYuKSxMQliYlLEhOXh9TAh9TAh3QPfEj3wF+YiXvhA0y6ByadE5eHdA98SPfAJCZuXKB94EE6J26QzokbF+geeFxJSgbUwOMC3QOPC3QPPC7QPfAgMXGDxMSNAH0TN0hM3CAxcYPExA0SEzdITNwgMXEjQPfA45dk4j5aTCM1cCPdAzdSA5OYuEFi4kYj3QOTmLhBYuIG6Zy4QTonbpDOiRukc+IG6Zy4QTonbpCYuNFBVPIgMXGDxMQNEhM3SEzcIDFxg8TEDdI5cYN0TtwgnRM3SEzcIDFxg3RO3CCdEzdI58SNQboHHqR74EG6Bx6ke+Bfkon7+DKR9oFJTNwgMXGDxMQNEhM3SEzcIDFxg8TEDRITN0jnxA3SOXFjkr6Jm6RdiAnyQowJ8kIMEhM3SEzcWKR74EVq4JWg2bRI+8AkJm4sUgMvUgMvUgNvkJlnkM6JG5u0D7xJ+8AkJm6QmLixSffAm9TAm7QPvEm/RiOdEzcOqYFJTNwgMXGDxMQNEhM3SEzcIDFxg8TEDRITN0lM3CQxcZPExE0SEzevJCUDauBJOiduXqB74Ek6J26SmLgZoH3gGaB94BmgfeBJYuImiYmbJCZuBui3EDNAv4WYAfotxAxSA5OYuNlAv4WYJCZukpi4SWLiJomJmyQmbpKYuEli4iaJiZud1MCkc+Im6Zy4SWLi5i/JxH10c9VJ98Ad9E3cJDFxk8TEzQ76Jm6SmLhJYuImiYmbJCZukpi4SWLiJomJmyQmbpKYuEli4iaJiZskJm6SmLhJYuImiYmbJCZukpi4SWLiJomJmyQmbpKYuEli4iaJiZskJm6SzombpHPi5iTdA5OYuDlJ98Ckc+ImiYmbJCZukpi4SWLiJomJmyQmbpKYuEli4iaJiZskJm6SmLhJYuImiYmbJCZukpi4SWLiJomJmyQmbm5SA29SA5POiZukc+LmId0DH9I98EnQnd4h3QOTmLh5SA18SA18QA28LtA98CIxcYvExK2rkxYDauBFYuIWiYlbJCZuXaAGXhepgYPUwEFqYNI5cStIDRykBg5SA5OYuEVi4haJiVskJm6RmLhFYuIWiYlbJCZukZi4RWLiFomJWyQmbpGYuEVi4haJiVskJm510Ddxq4O+iVtfmIl74TKRGriT7oE76R64k3YhOmkXIkm7ECQmbiXpHjhJuxBfmIl7YTGkBiYxcStJ98BJauAkNfAgNfAgNfAg3QMP0j0wiYlbJCZuDdCv0dYgNfAgNfAgNfAE/RptTdCv0dYE/RptkZi4RTonbpHOiVuTtAsxSbsQk/RNHImJWyQmbpGYuLVI98CLdA/8hZm4Fz7ApF0IEhO3FsjMsxbpm7hFauBNauBNauBNugfepHvgX5KJ++hv0wYRGWuTGpjExC3SOXFrkxqYdE7cIp0Ttw7pmzgSE7d+SSbuo0F5SLsQh7QPTGLiFumcuHVAfuBNOiduk5i4TWLiNumcuH2BGnhfoAbeF6iBN4mJ26Rz4vZFauAgNTCJidskJm6TzonbJCZuk5i4HaBdiB2kBg7QbyF2gH4LsRvo12i7kRq4gb6J2w30Tdz+JZm4jxdDugdupHtgEhO3G6mBG6mBO+ibuN1B38TtDvombpPOidukc+I26Zy4TWLiNomJ2x30a7TdQd/EbdI5cTtBXohNYuJ2khqYxMRtEhO3k9TASWrgJDUw6Zy4TTonbpPOidskJm6TmLj9hZm4Fz7ApAYepH3gAfo98B6kb+JI58RtEhO3SUzcJjFxm8TEbRITt0lM3CYxcZvExG0SE7dJTNwmMXGbxMRtEhO3SUzcJjFxm8TEbRITt0lM3CYxcZvExO1N2gcmnRO3SefEbdI5cXuTGniTGpjExO1NamASE7dJTNwmnRO3SefEbdI5cZvExG0SE7dJTNw+pF2IQ9qFOKRdiANq4HOBGvhcoAY+F+ge+Fyge+Bzge6BD+mcuEM6J+5coHvgQ2LizkVqYBITd0hM3CExcYfExB0SE3dITNwhnRN3SOfEHdI5cYd0TtwhnRN3SOfEHdI5cYd0TtwhnRN3SOfEnUZq4EZq4EZqYNI5cYd0TtzppAbupAYmMXGnkxqYdE7c6aRdiA6ikg/pnLhDOifukM6JO6Rz4g6JiTukc+IOiYk7JCbukJi4Q2LiDomJOyQm7gzSPfAg3QMPUgMP0j3wIDUwiYk7JCbukM6JOyQm7pCYuENi4g6JiTskJu6QmLhDYuIOiYk7JCbukJi4Q2LiDomJOyQm7pCYuENi4g6JiTskJu6QmLizSA28SA28SPvAi7QPvEn7wCQm7pCYuENi4s4veU7cx4sh3QNvkB/4kM6JOyQm7mzQGRmHdE7cIZ0Td0jnxB0SE3d+SSbu42RI98CHtA9MOifuHNI98AHdA8d1gW6C79WAOvheDeg2+F4N6D74Xg3oRvheDehO+F4N6Fb4Xg2oie/VgKr4Xg2qiwO0JXyvBrQnfK8G9LXcvRrQHfG9GlQXB6qLSZDcvRrQzvC9GtCXc/dqQN/OxdVQXdxQXUw6Pu5eDeq++AvDci99ikH7E/dqQBsU92pAzoh7NaBN4ns1qC4mHSN3rwbVxaSD5O7VoO6LSdjcvZqBWg2qi0nk3L0a1B4FiZ2LiwTP3atB7Rcn6r44UffFvyRA94nVoPYoErVfnKguTtR9cYJ+PREXCaO7V4PqYhJId68GdV88UF08UF08UF1Mounu1aC6eKC6eKK6eKK6eKK6mMTU3atBdTGJqrtXg+riieriidqjmKg9ChJad68GtV+8UPvFC9XFC9XFC9XFJMDuXg3qdxQL9TsK0rlzcW1UF29UF5Mwu3s1qP1i0uFz92pQv6PYqC7eqC7eqPvijbovPqjv7ki83b0aVBcfVBeTjqG7V4O6Lz6oPQoSdXevBrVffEj7xXGR9osDxd3FRdovjou0R3F/BY3KhnRfHKQj6e7VkLo4SIfS3ash7VEE6Vi6ezWoLiYdTHevBtXFpKPp7tWgujhQXRyoLg5UF6O4uyAdUHevBtXFpCPq7tWguph0SN29GlQXo7i7aKguRnF3geLugnRU3b0aVBeTDqu7V4PqYhR3F6Tz6u7VoLoYxd1FR3VxR3VxoroYxd0F6di6ezWoLiYdXHevBtXFiepiFHcXKO4uSKfX3RttqC5GcXeB4u4Cxd0FirsLFHcXKO4uUNxdfGHubswPqxlzfLwauYvbHu9X0/t6YTXnvH/sdT7/un3M9+tuPyyhjU88tK14/7Jt9f75B8da71841hkvPPj68MrvIJ0fP/i79HRO8E2nF05PSE+ezbt9SG/n/nx6a71/7No/PPT9UjpnKclZykB8vP+5lglaizqO57Wv7x8749ovjeP2Yf61f4e/9tvpCekdp/f69GQU922nF5jRtDj3Dotz76ATwyc//JfZmf/tv8z++Qaj+g1m9Rt4disN4NmtpOfZLaSno9v/sp7dnEG4OYNQJ7Zf6G4dwn7pDarHm4xKv+0G8OxW0vPsVtI7mJ49nEF4OINQJ+Zf6O5TPd50rv2lNxhugNc3wPHsVtLz7FbS25yexQzCdmEGYdONBZ/v7na16jfo1W+QboBXN0C7PLuV9Dy7lfQWp2cxg7BdnEGoGyNe6O6oHm9RPd5kVcObbgBZLfG20/PsVtKbnJ7lDMLgDELd2PFCd7fq8daqx5usynjTDdA8u5X00ukJ6Q1MzzbOIGycQagbU17q7urx1qvHm6wqedMN0D27lfQ8u5X0EtOznTMIO2cQ6saal7q7erz16vGWZi6EBkjPbiU9z24lPQzZ0nRv0L9uKZxBmLO6u6vHW1aPtzRzITTA8OxW0vPsVtLDkC1tcAahLm361y2lmJZpo3q8jerxNsxcKA3g2S2kNz27lfQwZEvjeJIax5PUdE/SC909q8fbrB5v9hRJDeDZraTn2S2ktzhkC0f60zjSn7aqaZlqlU+rVvm0ZeZCaQDPbiU9z24lPQ7ZwpH+NI70p+1qWqZa5dOqVT5tm7kQGsCeIik9z24lPQ7ZwpH+NI70p51qWqZa5dOqVT5NVvm86Qawp0hKz7NbSY9DtnCkP40j/elXMS3Tq1U+vVrl0y8zF69vgH6l0xPS8+xW0sOQLZ0j/ekc6U+/immZXq3y6dUqnx5mLoQGsKdISi+dnpAehmzpHOlP50h/euzq7q4eb9Uqn97MXAgNYE+RlJ5nt5JeYnqWI/3pHOlPb6u6u6vHW7XKp3czF0ID2FMkpefZraSHIVs6R/rTOdKf3md1d1ePt2qVT+9mLoQGsKdISs+zW0kPQ7Z0jvSnc6Q/PYtpmV6t8unVKp+eZi6UBvDsFtKzp0hKD0O2dI70p3OkP12X/rzQ3dUqn16t8unDzIXSAJ7dSnqe3UJ6E0O2dI70p3OkP30W0zK9WuXTq1U+fZq5UBrAs1tJz7NbSY9DtnCkP50j/emrmpapVvn0apVPX2YuhAawp0hKz7NbSY9DtnCkP50j/em7mpapVvn0apVPl1U+b7oB7CmS0vPsVtLjkC0c6U/nSH/6qaZlqlU+vVrl04+ZC6EB7CmS0vPsVtLjkC0c6U/nSH/6KaZlslrlk9Uqn7zMXLy+AdKeIim9dHpCehiyJTnSn+RIf/La1d1dPd6qVT4ZZi6EBrCnSErPs1tJLzE9y5H+JEf6k7Gqu7t6vFWrfLKZuRAawJ4iKT3PbiU9DNmSHOlPcqQ/2WZ1d1ePt2qVTzYzF0ID2FMkpefZraSHIVuSI/1JjvQnezEtk9Uqn6xW+WQ3c6E0gGe3kJ49RVJ6GLIlOdKf5Eh/Upf+vNDd1SqfrFb5ZJq5UBrAs1tJz7NbSG9gyJbkSH+SI/3JUUzLZLXKJ6tVPjnMXCgN4NmtpOfZraSHIVuSI/1JjvQnZzEtk9Uqn6xW+eQ0cyE0gD1FUnqe3Up6GLIlOdKf5Eh/clXTMtUqn6xW+aSs8nnTDWBPkZSeZ7eSHods4Uh/kiP9yV1Ny1SrfLJa5ZPbzIXQAPYUSel5divpccgWjvQnOdKf3NW0TLXKJ6tVPnnMXAgNYE+RlF46PSE9DtnCkf4kR/qTp5qWqVb5jGqVz7jMXLy+AYY9RVJ6nt1Keknp2cGR/gyO9Gdcq7q7d/UbVI+3MHMhNIA9RVJ6nt1KehiyZXCkP4Mj/Rkxq7u7erxVq3xGmLkQGsCeIik9z24lPQzZMjjSn8GR/oxWTMuMapXPqFb5jGbmQmkAz24hPXuKpPQwZMvgSH8GR/ozdOnPC91drfIZ1Sqf0c1cKA3g2a2k59ktpJcYsmVwpD+DI/0ZWUzLjGqVz6hW+Yw0c6E0gGe3kp5nt5IehmwZHOnP4Eh/xiimZUa1ymdUq3zGMHMhNIA9RVJ6nt1KehiyZXCkP4Mj/RmzmJYZ1SqfUa3yGbLK5003gD1FUnqe3Up6GLJlcKQ/gyP9GaualqlW+Yxqlc9YZi6EBrCnSErPs1tJj0O2cKQ/gyP9GaualqlW+Yxqlc/YZi6EBrCnSEovnZ6QHods4Uh/Bkf6M3Y1LVOt8hnVKp9xzFwIDWBPkZSeZ7eSXmJ6liP9GRzpzzjVtEy1ymdUq3zmZebi9Q0w7SmS0vPsVtLDkC3zwgzCyZH+zGtWd/eqfoNd/QZmLoQGsKdISs+zW0kPQ7ZMjvRncqQ/M4ppmVmt8pnVKp8ZZi6UBvDsFtKzp0hKD0O2TI70Z3KkP1OX/rzQ3dUqn1mt8pnNzIXSAJ7dSnqe3UJ6HUO2TI70Z3KkP7MX0zKzWuUzq1U+s5u5UBrAs1tJz7NbSQ9DtkyO9GdypD8zi2mZWa3ymdUqn5lmLoQGsKdISs+zW0kPQ7ZMjvRncqQ/cxTTMrNa5TOrVT5TVvm86Qawp0hKz7NbSQ9DtkyO9GdypD9zFtMys1rlM6tVPnOauRAawJ4iKT3PbiU9DNkyOdKfyZH+zFlNy1SrfGa1ymcuMxdCA9hTJKWXTk9Ij0O2cKQ/kyP9maualqlW+cxqlc/cZi6EBrCnSErPs1tJLzE9y5H+TI70Z+5qWqZa5TOrVT7zmLkQGsCeIik9z24lPQ7ZwpH+TI70Z55qWqZa5TOrVT7zmLl4fQMse4qk9Dy7lfQwZMviSH/WhRmE6yqmZVa1ymdVq3zWZeZCaQDPbiE9e4qk9DBky+JIfxZH+rN06c8L3V2t8lnVKp8VZi6UBvDsVtLz7BbSaxiyZXGkP4sj/VmtmJZZ1SqfVa3yWc3MhdIAnt1Kep7dSnoYsmVxpD+LI/1ZvZiWWdUqn1Wt8lndzIXQAPYUSel5divpYciWxZH+LI70Z2UxLbOqVT6rWuWzZJXPm24Ae4qk9Dy7lfQwZMviSH8WR/qzRjEts6pVPqta5bOGmQuhAewpktLz7FbSw5AtiyP9WRzpzxrFtMyqVvmsapXPmmYuhAawp0hKL52ekB6GbFkc6c/iSH/W3NXdXT3eqlU+a5m5EBrAniIpPc9uJb3E9CxH+rM40p+1qmmZapXPqlb5rG3mQmgAe4qk9Dy7lfQ4ZAtH+rM40p+1q2mZapXPqlb5rG3mQmgAe4qk9Dy7lfQ4ZAtH+rM40p91qmmZapXPqlb5rGPmQmkAz+7Xp7ftKZLSw5AtmyP92Rzpz76ytrt3tcpnV6t89mXmQmkAz24lPc9uIb3AkC2bI/3ZHOnPjmJaZlerfHa1ymeHmQulATy7lfQ8u5X0MGTL5kh/Nkf6s1sxLbOrVT67WuWzm5kLoQHsKZLS8+xW0sOQLZsj/dkc6c/uxbTMrlb57GqVz5ZVPm+6AewpktLz7FbSw5AtmyP92Rzpz85iWmZXq3x2tcpnp5kLoQHsKZLS8+xW0sOQLZsj/dkc6c/OYlpmV6t8drXKZw8zF0ID2FMkpZdOT0gPQ7ZsjvRnc6Q/e+zq7q4eb9Uqnz3NXAgNYE+RlJ5nt5JeYnqWI/3ZHOnPnqu6u6vHW7XKZy8zF0ID2FMkpefZraTHIVs40p/Nkf7sVU3LVKt8drXKZy8zF0ID2FMkpefZraTHIVs40p/Nkf7sXU3LVKt8drXKZ28zF0oDeHYL6dlTJKXHIVs40p/Nkf5sXfrzQndXq3x2tcpnHzMXSgN4divpeXa/Pr1zYciWw5H+HI7051zFtMy5svoNRvUbmLlQGsCzW0nPs1tJD0O2HI7053CkPyeKaZlTrfI51SqfE2YuhAawp0hKz7NbSQ9DthyO9OdwpD+nFdMyp1rlc6pVPkdW+bzpBrCnSErPs1tJD0O2HI7053CkP6cX0zKnWuVzqlU+p5u5EBrAniIpPc9uJT0M2XI40p/Dkf6cXkzLnGqVz6lW+Zw0cyE0gD1FUnrp9IT0MGTL4Uh/Dkf6c3JXd3f1eKtW+Zxh5kJoAHuKpPQ8u5X0EtOzHOnP4Uh/zljV3V093qpVPmeauRAawJ4iKT3PbiU9DNlyONKfw5H+nDmru7t6vM3q8TbNXAgNYE+RlJ5nt5Ieh2zhSH8OR/pzVjUtU63yOdUqn7PMXCgN4NktpGdPkZQeh2zhSH8OR/pzdOnPC91drfI51Sqfs81cKA3g2a2k59ktpHc4ZAtH+nM40p9zqmmZapXPqVb5nGPmQmkAz24lPc9uJT0K2dIujPTnXgplEN5LqaVl7jfo1W+Q1W9g5uLVDXCn59mtpOfZraRHIVvupXAGIUb6cy8lirs7qsdbVI83WeXzphvAniIpPc9uJT0K2XIvhTMIMdKfdrWruLtb9Xhr1eOtmbkQGsCeIik9z24lPQrZci+FMwgx0p97Kae4u3v1eOvV462buRAawJ4iKb10ekJ6FLLlXgpnEGKkP/dSdnV3V4+3rB5vaeZCaAB7iqT0PLuV9BLTsxjpz70UziDMVd3d1eMtq8fbMHMhNIA9RVJ6nt1KehSy5V4KZxBipD/3UmZ1d1ePt1E93oaZC6EB7CmS0vPsVtKjkC33UjiDECP9uZcyirt7Vo+3WT3eppkLpQE8u4X07CmS0uOQLRjpz70UziDUpT8vdPeqHm+rerwtMxdKA3h2K+l5dgvpbQ7ZgpH+3EvhDMJdTcsUq3zuN6geb9vMhdIAnt1Kep7dSnocsgUj/bmXwhmEp5qWOdXjrVjlc7+BmQuhAewpktLz7FbS45AtHOlPcKQ/cRXTMlGt8olqlU9c6QZ4dQOEPUVSep7dSnoYsiU40p/gSH8iimmZqFb5RLXKJ8LMhdAA9hRJ6Xl2K+lhyJbgSH+CI/2JKKZlolrlE9Uqn2hmLoQGsKdISi+dnpAehmwJjvQnONKfaLu6u6vHW7XKJ7qZC6EB7CmS0vPsVtJLTM9ypD/Bkf5EX9XdXT3eqlU+kWYuhAawp0hKz7NbSQ9DtgRH+hMc6U/krO7u6vFWrfKJNHMhNIA9RVJ6nt1KehiyJTjSn+BIf2IU0zJRrfKJapVPDDMXSgN4dgvp2VMkpYchW4Ij/QmO9Cd06c8L3V2t8olqlU9MMxdKA3h2K+l5dgvpLQ7ZwpH+BEf6E6ualqlW+US1yieWmQulATy7lfQ8u5X0OGQLR/oTHOlP7GpaplrlE9Uqn9hmLoQGsKdISs+zW0mPQ7ZwpD/Bkf7EqaZlqlU+Ua3yCVnl86YbwJ4iKT3PbiU9DtnCkf4ER/rTrmJaplWrfFq1yqddZi5e3wDtSqcnpOfZraSHIVsaR/rTONKfdhXTMq1a5dOqVT4tzFwIDWBPkZReOj0hPQzZ0jjSn8aR/rTY1d1dPd6qVT6tmbkQGsCeIik9z24lvcT0LEf60zjSn9ZWdXdXj7dqlU/rZi6EBrCnSErPs1tJD0O2NI70p3GkP63P6u6uHm/VKp/WzVwIDWBPkZSeZ7eSHoZsaRzpT+NIf1oW0zKtWuXTqlU+Lc1cKA3g2S2kZ0+RlB6GbGkc6U/jSH+aLv15oburVT6tWuXThpkLpQE8u5X0PLuF9CaGbGkc6U/jSH/aLKZlWrXKp1WrfNo0c6E0gGe3kp5nt5Ieh2zhSH8aR/rTVjUtU63yadUqn7bMXAgNYE+RlJ5nt5Ieh2zhSH8aR/rTdjUtU63yadUqnyarfN50A9hTJKXn2a2kxyFbONKfxpH+tFNNy1SrfFq1yqcdMxdCA9hTJKXn2a2kxyFbONKfxpH+tFNMy/RqlU+vVvn0y8zF6xug21MkpZdOT0gPQ7Z0jvSnc6Q//drV3V093qpVPj3MXAgNYE+RlJ5nt5JeYnqWI/3pHOlPj1Xd3dXjrVrl05uZC6EB7CmS0vPsVtLDkC2dI/3pHOlPb7O6u6vHW7XKpzczF0ID2FMkpefZraSHIVs6R/rTOdKf3otpmV6t8unVKp/ezVwoDeDZLaRnT5GUHoZs6RzpT+dIf7ou/Xmhu6tVPr1a5dPTzIXSAJ7dSnqe3UJ6A0O2dI70p3OkP30U0zK9WuXTq1U+fZi5UBrAs1tJz7NbSQ9DtnSO9KdzpD99FtMyvVrl06tVPn2auRAawJ4iKT3PbiU9DNnSOdKfzpH+9FVNy1SrfHq1yqfLKp833QD2FEnpeXYr6XHIFo70p3OkP31X0zLVKp9erfLp28yF0AD2FEnpeXYr6XHIFo70p3OkP31X0zLVKp9erfLpx8yF0AD2FEnppdMT0uOQLRzpT+dIf/qppmWqVT5ZrfLJy8zF6xsg7SmS0vPsVtJLSs8mR/qTHOlPXqu6u3f1G1SPtzBzITSAPUVSep7dSnoYsiU50p/kSH8yZnV3V4+3apVPhpkLoQHsKZLS8+xW0sOQLcmR/iRH+pOtmJbJapVPVqt8spm5UBrAs1tIz54iKT0M2ZIc6U9ypD+pS39e6O5qlU9Wq3yym7lQGsCzW0nPs1tILzFkS3KkP8mR/mQW0zJZrfLJapVPppkLpQE8u5X0PLuV9DBkS3KkP8mR/uQopmWyWuWT1SqfHGYuhAawp0hKz7NbSQ9DtiRH+pMc6U/OYlomq1U+Wa3ySVnl86YbwJ4iKT3PbiU9DNmSHOlPcqQ/uappmWqVT1arfHKZuRAawJ4iKT3PbiU9DtnCkf4kR/qTq5qWqVb5ZLXKJ7eZC6EB7CmS0kunJ6THIVs40p/kSH9yV9My1SqfrFb55DFzITSAPUVSep7dSnqJ6VmO9Cc50p881bRMtconq1U+4zJz8foGGPYUSel5divpYciWcWEG4eBIf8Y1q7t7Vb/Brn4DMxdCA9hTJKXn2a2khyFbBkf6MzjSnxHFtMyoVvmMapXPCDMXSgN4dgvp2VMkpYchWwZH+jM40p+hS39e6O5qlc+oVvmMZuZCaQDPbiU9z24hvY4hWwZH+jM40p/Ri2mZUa3yGdUqn9HNXCgN4NmtpOfZraSHIVsGR/ozONKfkcW0zKhW+Yxqlc9IMxdCA9hTJKXn2a2khyFbBkf6MzjSnzGKaZlRrfIZ1SqfIat83nQD2FMkpefZraSHIVsGR/ozONKfMYtpmVGt8hnVKp8xzVwIDWBPkZSeZ7eSHoZsGRzpz+BIf8aspmWqVT6jWuUzlpkLoQHsKZLSS6cnpMchWzjSn8GR/oxVTctUq3xGtcpnbDMXQgPYUySl59mtpJeYnuVIfwZH+jN2NS1TrfIZ1SqfccxcCA1gT5GUnme3kh6HbOFIfwZH+jNONS1TrfIZ1SqfccxcvL4Bpj1FUnqe3Up6GLJlcqQ/88IMwnkV0zKzWuUzq1U+8zJzoTSAZ7eQnj1FUnoYsmVypD+TI/2ZuvTnhe6uVvnMapXPDDMXSgN4divpeXYL6TUM2TI50p/Jkf7MVkzLzGqVz6xW+cxm5kJpAM9uJT3PbiU9DNkyOdKfyZH+zF5My8xqlc+sVvnMbuZCaAB7iqT0PLuV9DBky+RIfyZH+jOzmJaZ1SqfWa3ymbLK5003gD1FUnqe3Up6GLJlcqQ/kyP9maOYlpnVKp9ZrfKZw8yF0AD2FEnpeXYr6WHIlsmR/kyO9GeOYlpmVqt8ZrXKZ04zF0ID2FMkpZdOT0gPQ7ZMjvRncqQ/c+7q7q4eb9Uqn7nMXAgNYE+RlJ5nt5JeYnqWI/2ZHOnPXNW0TLXKZ1arfOY2cyE0gD1FUnqe3Up6HLKFI/2ZHOnP3NW0TLXKZ1arfOY2cyE0gD1FUnqe3Up6HLKFI/2ZHOnPPNW0TLXKZ1arfOYxc6E0gGf369Nb9hRJ6WHIlsWR/iyO9GddWdvdq1rls6pVPusyc6E0gGe3kp5nt5BeYMiWxZH+LI70Z0UxLbOqVT6rWuWzwsyF0gCe3Up6nt1KehiyZXGkP4sj/VmtmJZZ1SqfVa3yWc3MhdAA9hRJ6Xl2K+lhyJbFkf4sjvRn9WJaZlWrfFa1ymfJKp833QD2FEnpeXYr6WHIlsWR/iyO9GdlMS2zqlU+q1rls9LMhdAA9hRJ6Xl2K+lhyJbFkf4sjvRnZTEts6pVPqta5bOGmQuhAewpktJLpyekhyFbFkf6szjSnzV2dXdXj7dqlc+aZi6EBrCnSErPs1tJLzE9y5H+LI70Z81V3d3V461a5bOWmQuhAewpktLz7FbS45AtHOnP4kh/1qqmZapVPqta5bOWmQuhAewpktLz7FbS45AtHOnP4kh/1q6mZapVPqta5bO2mQulATy7hfTsKZLS45AtHOnP4kh/li79eaG7q1U+q1rls46ZC6UBPLuV9Dy7X5/evjBky+ZIfzZH+rOvYlpmX1n9BqP6DcxcKA3g2a2k59mtpIchWzZH+rM50p8dxbTMrlb57GqVzw4zF0ID2FMkpefZraSHIVs2R/qzOdKf3YppmV2t8tnVKp8tq3zedAPYUySl59mtpIchWzZH+rM50p/di2mZXa3y2dUqn93NXAgNYE+RlJ5nt5IehmzZHOnP5kh/di+mZXa1ymdXq3x2mrkQGsCeIim9dHpCehiyZXOkP5sj/dm5q7u7erxVq3z2MHMhNIA9RVJ6nt1KeonpWY70Z3OkP3us6u6uHm/VKp89zVwIDWBPkZSeZ7eSHoZs2Rzpz+ZIf/ac1d1dPd6qVT57mrkQGsCeIik9z24lPQ7ZwpH+bI70Z69qWqZa5bOrVT57mblQGsCzW0jPniIpPQ7ZwpH+bI70Z+vSnxe6u1rls6tVPnubuVAawLNbSc+zW0jvcMgWjvRnc6Q/+1TTMtUqn12t8tnHzIXSAJ7dSnqe3Up6GLLlcKQ/hyP9OVcxLXOqVT7nyuo3MHPx+gY49hRJ6Xl2K+lhyJbDkf4cjvTnRDEtc6pVPqda5XNklc+bbgB7iqT0PLuV9DBky+FIfw5H+nNaMS1zqlU+p1rlc5qZC6EB7CmS0vPsVtLDkC2HI/05HOnPacW0zKlW+Zxqlc/pZi6EBrCnSEovnZ6QHoZsORzpz+FIf07f1d1dPd6qVT4nzVwIDWBPkZSeZ7eSXmJ6liP9ORzpz8lV3d3V461a5XOGmQuhAewpktLz7FbSw5AthyP9ORzpzxmzururx1u1yucMMxdCA9hTJKXn2a2khyFbDkf6czjSnzOLaZlTrfI51SqfM81cKA3g2S2kZ0+RlB6HbOFIfw5H+nN06c8L3V2t8jnVKp+zzFwoDeDZraTn2S2ktzlkC0f6czjSn7OraZlqlc+pVvmcbeZCaQDPbiU9z24lPQ7ZwpH+HI7055xqWqZa5XOqVT7nmLkQGsCeIik9z24lPQ7ZgpH+9Asj/bmXUkvL3G/Qqt+gV79BugFe2wB3ep7dSnqe3Up6FLLlXgplEN5L4QzCuIq7O6rHW1SPtzBzITSAPUVSep7dSnoUsuVeCmcQYqQ/91JOcXe36vHWqsdbM3MhNIA9RVJ66fSE9Chky70UziDESH/upezq7q4eb716vHUzF0ID2FMkpefZraSXmJ7FSH/upXAGYV/V3V093nr1eEszF0ID2FMkpefZraRHIVvupXAGIUb6cy9lVnd39XjL6vGWZi6EBrCnSErPs1tJj0K23EvhDEKM9Odeyiju7lE93kb1eBtmLpQG8OwW0rOnSEqPQrbcS+EMQoz0515KFnf3rB5vs3q8TTMXSgN4divpeXYL6S0O2YKR/txL4QzCVU3LFKt87jeoHm/LzIXSAJ7dSnqe3Up6HLIFI/25l8IZhLualtnV461Y5XO/gZkLoQHsKZLS8+xW0uOQLRjpT78w0p97KdW0zKkeb6d6vMkqnzfdAPYUSel5divpccgWjPTnXgpmEMZVTMtEtconqlU+cZm5eH0DxJVOT0jPs1tJD0O2BEf6ExzpT1zFtExUq3yiWuUTYeZCaAB7iqT00ukJ6WHIluBIf4Ij/YnY1d1dPd6qVT7RzFwIDWBPkZSeZ7eSXmJ6liP9CY70J9qq7u7q8Vat8olu5kJoAHuKpPQ8u5X0MGRLcKQ/wZH+RJ/V3V093qpVPtHNXAgNYE+RlJ5nt5IehmwJjvQnONKfyGJaJqpVPlGt8ok0c6E0gGe3kJ49RVJ6GLIlONKf4Eh/Qpf+vNDd1SqfqFb5xDBzoTSAZ7eSnme3kN7EkC3Bkf4ER/oTs5iWiWqVT1SrfGKauVAawLNbSc+zW0mPQ7ZwpD/Bkf7EqqZlqlU+Ua3yiWXmQmgAe4qk9Dy7lfQ4ZAtH+hMc6U/salqmWuUT1SqfkFU+b7oB7CmS0vPsVtLjkC0c6U9wpD9xqmmZapVPVKt84pi5EBrAniIpPc9uJT0O2cKR/gRH+hOnmJZp1SqfVq3yaZeZi9c3QLOnSEovnZ6QHoZsaRzpT+NIf9q1q7u7erxVq3xamLkQGsCeIik9z24lvcT0LEf60zjSnxarururx1u1yqc1MxdCA9hTJKXn2a2khyFbGkf60zjSn9ZmdXdXj7dqlU9rZi6EBrCnSErPs1tJD0O2NI70p3GkP60X0zKtWuXTqlU+rZu5UBrAs1tIz54iKT0M2dI40p/Gkf40XfrzQndXq3xatcqnpZkLpQE8u5X0PLuF9AaGbGkc6U/jSH/aKKZlWrXKp1WrfNowc6E0gGe3kp5nt5IehmxpHOlP40h/2iymZVq1yqdVq3zaNHMhNIA9RVJ6nt1KehiypXGkP40j/WmrmpapVvm0apVPk1U+b7oB7CmS0vPsVtLjkC0c6U/jSH/arqZlqlU+rVrl07aZC6EB7CmS0vPsVtLjkC0c6U/jSH/arqZlqlU+rVrl046ZC6EB7CmS0kunJ6THIVs40p/Gkf60U03LVKt8erXKp19mLl7fAN2eIik9z24lvaT0bOdIfzpH+tOvVd3du/oNqsdbmLkQGsCeIik9z24lPQzZ0jnSn86R/vSY1d1dPd6qVT49zFwIDWBPkZSeZ7eSHoZs6RzpT+dIf3orpmV6tcqnV6t8ejNzoTSAZ7eQnj1FUnoYsqVzpD+dI/3puvTnhe6uVvn0apVP72YulAbw7FbS8+wW0ksM2dI50p/Okf70LKZlerXKp1erfHqauVAawLNbSc+zW0kPQ7Z0jvSnc6Q/fRTTMr1a5dOrVT59mLkQGsCeIik9z24lPQzZ0jnSn86R/vRZTMv0apVPr1b5dFnl86YbwJ4iKT3PbiU9DNnSOdKfzpH+9FVNy1SrfHq1yqcvMxdCA9hTJKXn2a2kxyFbONKfzpH+9FVNy1SrfHq1yqdvMxdCA9hTJKWXTk9Ij0O2cKQ/nSP96bualqlW+fRqlU8/Zi6EBrCnSErPs1tJLzE9y5H+dI70p59qWqZa5dOrVT55mbl4fQOkPUVSep7dSnoYsiUvzCBMjvQnr1nd3av6DXb1G5i5EBrAniIpPc9uJT0M2ZIc6U9ypD8ZxbRMVqt8slrlk2HmQmkAz24hPXuKpPQwZEtypD/Jkf6kLv15oburVT5ZrfLJZuZCaQDPbiU9z24hvY4hW5Ij/UmO9Cd7MS2T1SqfrFb5ZDdzoTSAZ7eSnme3kh6GbEmO9Cc50p/MYlomq1U+Wa3yyTRzITSAPUVSep7dSnqfnt37/V/3E/n5f8vz4d/y/Kg62/n+5T853E57H/jJqbz8p+U8Z7y/Rmc16eU/OYTO+hDO2dLLf3Kw3FcsPlyx+6E/eoN/PuuT0yJa9PfPai994iM/zLsY8aOP2/Wpz+YP62lX359/8LvDHr9/8Dv7548f/M/FJ3nxeb3/4Lxb6ceLH/+Tk5//k5NfX3jxvb3/O9762h+vZ396PfNDMffrkqrhk715v+oPb5DSG3za5nK/6g9vsI70BvHpN9gfrsL9fa30Bp9uz3sL7cMbrOuj9vy0eCXmuD6M1KtT/w5/WupCWfwLf4c/7VQpXPxn/g7ff/jNn7/5wx+++a//+MO3v/31X7/59o9/effU693/+fQt0ec+jD9zl/OZZ/zcjctnnhGPn9EeP6M/fkY+fsZ4/Iz5+Bnr8TMeX/Px+JrPx9d8Pr7m8/E1n4+v+Xx8zefjaz4fX/P5+JrPx9d8Pr7m6/E1X4+v+Xp8zdfja74eX/P1+Jqvx9d8Pb7m6/E1X4+v+X58zffja74fX/P9+Jrvx9d8P77m+/E134+v+X58zffja34eX/Pz+Jqfx9f8PL7m5/E1P4+v+Xl8zc/ja34eX/Pz+JrHdT1/Sjx/Snv+lP78Kfn8KeP5U+bzp6znT9nPn/L86sfzqx/Pr348v/rx/OrH86sfz69+PL/68fzqx/OrH8+vfnt+9dvzq9+eX/32/Oq351e/Pb/67fnVb8+vfnt+9X/mx3Pxfjdj5/jpU37mF2OffUo8f0p79pT7D/Hugf1xBv3xX4B8/PnPxx//fPzpz8cf/nz82c/HH/18/MnPxx98b1p508qbVt608qaVN628aeVNK29aedPqK29aedPKm1betPKm1RvZtPrsU/rzq9+fX/3+/Or351e/P7/6/fnV78+vfn9+9Z9v18Xz/bp4vmEXz3fs4vmWXTzfs4vnm3bxfNcunm/bxfN9u3i+cRfPd+7i+dZdPN+7i+ebd/F89y6eb9/F8/27eL6BF8938OL5Fl4838OL55t48XwXL55v48Xzfbx4vpEXP3Oa3+e+evmZI+w++5T1/Cn72VPuP7R3D/QXI/5ixF+M+IsRfzHiL0b8xYi/GPEXI/5i5JPPeHzN/cWIvxjxFyP/n0/xFyP/3l+MfPa/3dvz33O29vwp/fEOQX/3wE8n/d/UEv2HZ8b6lBPpes8ir2g/fui7de3alz/6y/f3aoCV5ycv/+mr/fDl31+BNftPXz70l9/vpS3rrJ++fKt9+S6//G7zw8fzp5f201/bPXz59xD4HvOnLz/0l18f/nJ9HM78F778+cnn/v5Dvnugd0i8Q+IdEu+QeIfEOyTeIfEOiXdIvEPiHRLvkAB3SD7/FP909OlT/NPRp0/5t//p6OcJ8f38Kc9p93y4O3r/YXy3keEfh3jrw1sf3vrw1oe3Prz14a0Pb31468NbH976+MpbH9768NbHm9r6+PymBHLr4x/3n/7Pr//8za9/84ff/+V+xrv/8W9//O370wLuP/71//7p/f/y/jyBP/3529/+/nd/+/Pv350s8MOhAu8uVh9f5/huBN1/uC/G1/eKfpD23f+sja/7Dw9Y19exxgfo67sHnK/vp7x/wP3w++P5w2++3v3Dfr17iX98/1OSd8/J/vXoH56T7evI9WGL5rsHtK9H++EBcT9g3v/u97///wM=","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"63":{"source":"use dep::std;\nuse std::hash::poseidon2::Poseidon2::hash;\nuse trees::{\n    sparse_merkle::SparseMerkleTree,\n    types::{Calculator, SMT_Creator},\n};\n// use afk_common::verify_vote::{verify_vote};\n\n\nfn main(\n    root: pub Field,\n    secret: Field,\n    proposal_id: pub Field,\n    nullifier_default: pub Field,\n    leaf: [Field; 2],\n    siblings: [Field; 254],\n    // vote: pub Field,\n) -> pub Field {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // let mut tree = SparseMerkleTree::new(hash3, hash2);\n    // let mut tree = MerkleTree::new(hash2);\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n    let key = leaf[0];\n    let value = leaf[1];\n    let entry = (key, value);\n    // let note_commitment = std::hash::pedersen_hash([secret]);\n\n    let root_check = tree.calculate_root(entry, key, siblings);\n    std::println(\"root_check\");\n    std::println([root_check]);\n    std::println(\"root\");\n    std::println([root]);\n    assert(root_check == root);\n\n\n    // tree.add(entry, index, siblings);\n    // // Calculate and verify root\n    // tree.membership(entry, index, siblings);\n\n    // Verify nullifier\n    let computed_nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n    std::println(\"computed_nullifier\");\n    std::println([computed_nullifier]);\n    std::println(\"nullifier_default\");\n    std::println([nullifier_default]);\n    assert(computed_nullifier == nullifier_default);\n\n    // assert(U128::from_integer(vote) <= 1);\n\n    //  verify_vote(root_check, secret, proposal_id, vote, nullifier_default, leaf, siblings);\n\n    // Return the commitment\n    std::hash::pedersen_hash([root, secret, proposal_id])\n\n}\n\n#[test]\nfn test_valid_sparse_merkle_tree_membership() {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // Create a simple tree structure\n    let key = 12345;\n    let value = 999;\n    // let entry = (key, value);\n\n    // Initialize tree\n    // let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n    // Create siblings array with default values\n    let mut siblings = [0; 254];\n\n    // Calculate leaf hash\n    let leaf_hash = hash3([key, value, 0]);\n\n    // Calculate the first level sibling\n    siblings[0] = hash3([0, 0, 1]);\n\n    // Calculate intermediate nodes\n    let mut current_hash = leaf_hash;\n    for i in 0..3 {\n        // We'll create a small subtree for testing\n        current_hash = hash2([current_hash, siblings[i]]);\n        if i + 1 < 3 {\n            siblings[i + 1] = hash2([0, 0]); // Default sibling for next level\n        }\n    }\n\n    // The final hash becomes our root\n    let root = current_hash;\n\n    // Create vote parameters\n    let secret = 777;\n    let proposal_id = 1;\n    // let vote = 1;\n    let leaf = [key, value];\n\n    // Calculate nullifier\n    let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n\n    // Execute the main circuit\n    let result = main(\n        root,\n        secret,\n        proposal_id,\n        nullifier,\n        leaf,\n        siblings,\n        // vote,\n    );\n\n    // Calculate expected output\n    let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n    assert(result == expected_output);\n}\n\n\n#[test]\nfn test_vote_verification() {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // Create a different tree structure for testing\n    let key = 98765; // Different key\n    let value = 444; // Different value\n    // let entry = (key, value);\n\n    // Initialize tree\n    // let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n    // Create siblings array with default values\n    let mut siblings = [0; 254];\n\n    // Calculate leaf hash with different values\n    let leaf_hash = hash3([key, value, 0]); // Changed last param to 0 to match tree structure\n\n    // Calculate siblings with different values\n    siblings[0] = hash3([0, 0, 1]); // Match sibling format\n\n    // Calculate intermediate nodes with more levels\n    let mut current_hash = leaf_hash;\n    for i in 0..5 { // Keep consistent depth\n        current_hash = hash2([current_hash, siblings[i]]);\n        if i + 1 < 5 {\n            siblings[i + 1] = hash2([0, 0]); // Use consistent default siblings\n        }\n    }\n\n    // The final hash becomes our root\n    let root = current_hash;\n\n    // Create different vote parameters\n    let secret = 888; // Different secret\n    let proposal_id = 2; // Different proposal\n    // let vote = 0; // Different vote\n    let leaf = [key, value];\n\n    // Calculate nullifier\n    let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n\n    // Execute the main circuit\n    let result = main(\n        root,\n        secret,\n        proposal_id,\n        nullifier,\n        leaf,\n        siblings,\n        // vote,\n\n    );\n\n    // Calculate expected output\n    let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n    assert(result == expected_output);\n}\n\n// #[test]\n// fn test_valid_sparse_merkle_tree_membership() {\n//     // let poseidon2 = std::hash::poseidon2::Poseidon2 {};\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n//     // Let's use a dummy key-value pair\n//     let key = 12345;\n//     let value = 999;\n//     let leaf = [key, value];\n\n//     // Build the SMT\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n//     let entry = (key, value);\n\n//     // NOTE: tree.insert() must happen **outside ZK circuit** (trusted setup)\n//     // let siblings = tree.add(entry, key);\n\n//  let commitment_0 = std::hash::pedersen_hash([1]);\n//     let commitment_1 = std::hash::pedersen_hash([2]);\n\n//       let commitment_2 = std::hash::pedersen_hash([3]);\n//     let commitment_3 = std::hash::pedersen_hash([4]);\n\n//      let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     let vote = 1;\n//     let secret: Field = 1;\n//     let hash_path = [commitment_1, right_branch];\n//     let leaf = commitment_0;\n//     let mut siblings = [0; 254];\n//     siblings[0] = commitment_1;\n//     siblings[1] = right_branch;\n//     let root = tree.calculate_root(entry, key, siblings);\n\n//     // Create vote identity\n//     let secret = 777;\n//     let proposal_id = 1;\n//     let vote = 1;\n\n//     // Construct the nullifier (public) and return value\n//     let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n//     let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n//     // Now invoke the ZK function\n//     let result = main(\n//         root,\n//         0,\n//         secret,\n//         proposal_id,\n//         vote,\n//         nullifier,\n//         hash_path,\n//         siblings,\n//     );\n\n//     assert(result == expected_output);\n// }\n\n// // #[test]\n// fn test_valid_build_merkle_tree() {\n//     let commitment_0 = std::hash::pedersen_hash([1]);\n//     let commitment_1 = std::hash::pedersen_hash([2]);\n//     let commitment_2 = std::hash::pedersen_hash([3]);\n//     let commitment_3 = std::hash::pedersen_hash([4]);\n\n//     let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     let proposalId = 0;\n//     let vote = 1;\n//     let secret = 1;\n//     let index = 0;\n//     let hash_path = [commitment_1, right_branch];\n//     let leaf = commitment_0;\n//     let mut siblings = [0; 254];\n//     siblings[0] = commitment_1;\n//     siblings[1] = right_branch;\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n//     // Initialize the tree\n//     // let mut tree = MerkleTree::new(hash2);\n\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n//     let nullifier = main(\n//         root,\n//         index,\n//         hash_path,\n//         secret,\n//         proposalId,\n//         vote,\n//         proposalId,\n//         std::hash::pedersen_hash([secret, proposalId]),\n//         hash_path,\n//         siblings,\n//     );\n\n//     let expected_nullifier = std::hash::pedersen_hash([root, secret, proposalId]);\n\n//     std::println(\"Merkle Tree:\");\n//     std::println([root]);\n//     std::println([left_branch, right_branch]);\n//     std::println([commitment_0, commitment_1, commitment_2, commitment_3]);\n\n//     assert(nullifier == expected_nullifier);\n// }\n\n// fn main(root : pub Field, index : Field, hash_path : [Field; 2], secret: Field, priv_key: Field, proposalId: pub Field, vote: pub u8) -> pub Field {\n//     let note_commitment = std::hash::pedersen([priv_key, secret]);\n//     let nullifier = std::hash::pedersen([root, priv_key, proposalId]);\n\n//     let check_root = std::merkle::compute_merkle_root(note_commitment[0], index, hash_path);\n//     assert(root == check_root);\n\n//     // Originally contrained the vote to avoid front-running,\n//     // but including the vote as a public input is sufficient\n\n//     assert(vote <= 1);\n\n//     nullifier[0]\n// }\n\n// Helpers for getting note_commitments to build the merkle tree.\n// To view: nargo test --show-output\n\n// #[test]\n// fn test_build_merkle_tree() {\n//     let secret = 9;\n//     let commitment_0 = std::hash::pedersen_hash([0, secret]);\n//     let commitment_1 = std::hash::pedersen_hash([1, secret]);\n//     let commitment_2 = std::hash::pedersen_hash([2, secret]);\n//     let commitment_3 = std::hash::pedersen_hash([3, secret]);\n\n//     let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     std::println(\"Merkle Tree:\");\n//     std::println([root]);\n//     std::println([left_branch, right_branch]);\n//     std::println([commitment_0, commitment_1, commitment_2, commitment_3]);\n// }\n\n// #[test]\n// fn test_sparse_merkle_tree() {\n//     // Create hash functions for the tree\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n\n//     // Initialize the tree\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n//     // Create a leaf entry (commitment pair)\n//     let secret = 1;\n//     let value = 100;\n//     let entry = (secret, value);\n\n//     // Create proposal ID and hash path\n//     let proposal_id = 1;\n//     let hash_path = [secret, value];\n\n//     // Create siblings for the proof\n//     let mut siblings = [0; 254];\n\n//     // Calculate note commitment and root\n//     let note_commitment = std::hash::pedersen_hash([secret]);\n//     let root = std::merkle::compute_merkle_root(note_commitment, 0, hash_path);\n\n//     // Calculate nullifier as per main function\n//     let nullifier = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n//     // Test the main function with the same parameters as used in the original test\n//     let result = main(\n//         root, // root\n//         0, // index\n//         hash_path,\n//         secret,\n//         proposal_id,\n//         1, // vote\n//         proposal_id,\n//         nullifier,\n//         hash_path, // leaf\n//         siblings,\n//     );\n\n//     // The expected nullifier should match what we calculated\n//     assert(result == nullifier);\n// }\n","path":"/home/msg-encrypted/Documents/dev/privacy/afk-privacy/circuits/propose_vote/src/main.nr"},"72":{"source":"pub use crate::types::{Calculator, MembershipProver, Modifier, NonMembershipProver, SMT_Creator};\n\npub struct SparseMerkleTree<T> {\n    pub root: T,\n    pub leaf_hasher: fn([T; 3]) -> T,\n    pub hasher: fn([T; 2]) -> T,\n}\n\nimpl<T> SMT_Creator<T> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn default(root: T, leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self { root, leaf_hasher, hasher }\n    }\n\n    fn from(root: T, leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::default(root, leaf_hasher, hasher)\n    }\n\n    fn new(leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::from(T::default(), leaf_hasher, hasher)\n    }\n}\n\nimpl<T> MembershipProver<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn membership<let N: u32>(self, entry: (T, T), indexes: Field, hash_path: [T; N]) {\n        // membership proof: the root is calculated based on the entry, the siblings,\n        // and the path determined by the key of entry through consecutive hashing\n        assert(self.calculate_root(entry, indexes, hash_path) == self.root);\n    }\n}\n\nimpl<T> NonMembershipProver<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn non_membership<let N: u32>(self, matching_entry: (T, T), index: Field, siblings: [T; N]) {\n        if (self.root != T::default()) {\n            // non-membership proof: the root is calculated based on the matching_entry, the siblings\n            // and the path that is determined by the key of entry. This makes sure that matching_entry is in fact\n            // a matching entry for entry meaning that it shares the same first bits as path\n            let mut calculated_root = self.calculate_root(matching_entry, index, siblings);\n            assert(calculated_root == self.root);\n        }\n    }\n}\n\nimpl<T> Modifier<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn add<let N: u32>(&mut self, new_entry: (T, T), index: Field, hash_path: [T; N]) {\n        // if the root node is zero the first leaf is added to the tree in which case\n        // the new root equals H(k,v,T::default())\n        // otherwise the correctness of the old root is validated based on the siblings after which\n        // the new root is calculated and returned\n        if (self.root == T::default()) {\n            self.root = (self.leaf_hasher)([new_entry.0, new_entry.1, T::default()]);\n        } else {\n            let (old, new) = self.calculate_two_roots(new_entry, index, hash_path);\n            assert(old == self.root);\n            self.root = new;\n        }\n    }\n\n    fn delete<let N: u32>(&mut self, entry: (T, T), indexes: Field, hash_path: [T; N]) {\n        // proves membership of entry in the old root, then calculates and returns the new root\n        let (new, old) = self.calculate_two_roots(entry, indexes, hash_path);\n\n        assert(old == self.root);\n        self.root = new;\n    }\n\n    fn update<let N: u32>(\n        &mut self,\n        new_value: (T, T),\n        old_value: (T, T),\n        index: Field,\n        hash_path: [T; N],\n    ) {\n        let key = index;\n        // both the old entry and new entry share the same key that is used to calculate the path\n        let path: [u1; N] = key.to_be_bits();\n\n        // old_parent is a container to temporarily store the nodes that ultimately lead to the OLD root\n        let mut old_parent = (self.leaf_hasher)([old_value.0, old_value.1, T::default()]);\n        // new_parent is a container to temporarily store the nodes that ultimately lead to the NEW root\n        let mut new_parent = (self.leaf_hasher)([new_value.0, new_value.1, T::default()]);\n        // starting from the bottom of the tree, for each level it checks whether there is a sibling and if\n        // that is the case, it hashes the two containers with the sibling and updates the containers with the\n        // resulting hashes until the uppermost level is reached aka the root node\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if sibling != T::default() {\n                if path[i] != 0 {\n                    new_parent = (self.hasher)([sibling, new_parent]);\n                    old_parent = (self.hasher)([sibling, old_parent]);\n                } else {\n                    new_parent = (self.hasher)([new_parent, sibling]);\n                    old_parent = (self.hasher)([old_parent, sibling]);\n                }\n            }\n        }\n        assert(old_parent == self.root);\n        self.root = new_parent;\n    }\n}\n\nimpl<T> Calculator<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    /*\n     * Calculates the root for a given tree entry based on the passed array of siblings and the passed path.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @param path The position of the entry in the tree as represented by bits from bottom to top\n     * @returns The calculated root node\n     */\n    fn calculate_root<let N: u32>(self, entry: (T, T), indexes: Field, hash_path: [T; N]) -> T {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n\n        // serves as container for hashes and is initialized to be the leaf node\n        let mut node = (self.leaf_hasher)([entry.0, entry.1, T::default()]);\n        // iterates over the list of siblings until the first sibling is found\n        // arbitrarily assigns the sibling to be the left and the node to be the\n        // right element of the hashing pair unless the path indicates the opposite\n        // order in which case the order is changed. The new hash is stored in the container\n        // until the root node is reached and returned.\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if sibling != T::default() {\n                let mut left = sibling;\n                let mut right = node;\n                if index_bits[i] == 0 {\n                    left = node;\n                    right = sibling;\n                }\n                node = (self.hasher)([left, right]);\n            }\n        }\n        node\n    }\n\n    /*\n     * Calculates two roots for a given leaf entry based on the passed array of siblings: one root\n     * for if the leaf entry was included in the tree and one for if the leaf entry was not included\n     * in the tree. This is useful for efficiently proving the membership of leaf entries for a\n     * tree while simultaneously modifying the tree.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @returns Two root nodes: the first one doesn't include entry, the second does\n     */\n    fn calculate_two_roots<let N: u32>(\n        self,\n        entry: (T, T),\n        indexes: Field,\n        hash_path: [T; N],\n    ) -> (T, T) {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n\n        // root_with_leaf is a container for hashes to derive the root node for the tree that\n        // includes the entry\n        let mut root_with_leaf = (self.leaf_hasher)([entry.0, entry.1, T::default()]);\n        // root_without_leaf is a container for hashes to derive the root node for the tree that\n        // doesn't include the entry\n        let mut root_without_leaf = T::default();\n        // iterate over the levels of the tree from bottom to top\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            // After the first sibling is found, the processes are started to calculate the two root nodes.\n            // The calulcation of the root node that includes the entry is comparable to `calculate_root`.\n            // To calc the root node that doesn't include entry, the first sibling is put into the container\n            // and starting from each SUBSEQUENT iteration it is hashed with its sibling and the resulting hash\n            // again stored in the container until the root is reached\n            if sibling != T::default() {\n                if hash_path[i - 1] == T::default() {\n                    root_without_leaf = hash_path[i];\n                }\n\n                if index_bits[i] != 0 {\n                    root_with_leaf = (self.hasher)([sibling, root_with_leaf]);\n                    if (root_without_leaf != sibling) {\n                        root_without_leaf = (self.hasher)([sibling, root_without_leaf]);\n                    }\n                } else {\n                    root_with_leaf = (self.hasher)([root_with_leaf, sibling]);\n\n                    if (root_without_leaf != sibling) {\n                        root_without_leaf = (self.hasher)([root_without_leaf, sibling]);\n                    }\n                }\n            }\n        }\n\n        (root_without_leaf, root_with_leaf)\n    }\n}\n","path":"/home/msg-encrypted/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/merkle-trees-v0.0.1/packages/merkle-trees/src/sparse_merkle.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","decompose_hint","print_unconstrained","print_unconstrained","directive_to_radix","directive_invert"]}