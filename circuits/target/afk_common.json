{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":9575899178406864174,"abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"proposal_id","type":{"kind":"field"},"visibility":"public"},{"name":"vote","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_default","type":{"kind":"field"},"visibility":"public"},{"name":"leaf","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":254,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+2dB5gV1bK2u/fMMAwwgCTJQQyYe00ezCiKiooZM8MEFHPOiIpZzJgVRcWAGRUVFVRUDIhiwICKmCOKghH9q87uvrTYW5rdX7Fr/cx6nrqXu07fOhXW+urt3niO66TX8NaOc2Zx+s/5ZC5ZnvPv5fr/e3P/f3vJlinA+fIiwgX5bqiX8+2VuKHa/uX/uQn9H4VkTcmKyJqRNSdrQVZM1pKsFVlrslXI2pC1JWtH1p6sA9mqZB3JOpF1JutC1pWsG1l3sh5kPcl6ka1G1ptsdbI1yNYkW4usD9naZOuQrUu2Htn6ZBuQbUjmkRkyTqKUrIysnKyCrJKsiqyarC/ZRmQbk21CtinZZmSbk21B1o9sS7KtyPqTbU22DdkAsm3JtiPbnmwg2Q5kO5LtRDaIbGeyXch2JduNbHeyPcj2JBtMthfZ3mT7kO1Lth/Z/mQHkA0hqyEbSlZLVkdWT9ZANozsQLKDyIaTHUx2CNmhZIeRHU52BNmRZEeRHU12DNmxZMeRHU92AtmJZCeRnUx2CtmpZCPITiMbSXY62RlkZ5KNIjuL7Gyyc8jOJTuP7HyyC8guJBtNdhHZxWSXkF1KdhnZ5WRXkI0hu5LsKrKrya4hu5bsOrLryW4gu5FsLNlNZDeTjSO7hexWstvIxpPdTnYH2Z1kd5FNILub7B6ye8nuI7uf7AGyB8kmkj1E9jDZI2STyB4le4zscbLJZE+QPUn2FNkUsqlkT5M9Q/Ys2TSy58ieJ3uBbDrZi2Qvkb1M9grZDLJXyWaSvUb2OtkssjfI3iR7i+xtstlk75C9S/Ye2ftkc8g+IPuQ7COyuWQfk80j+4TsU7LPyD4n+4LsS7KvyL4m+4bsW7LvyL4nm0/2A9mPZAvIfiL7mWwh2SKyX8h+JfuN7HeyP8j+JFtM9hfZ32ROiu49WYosLxUSXtcXAXepvcKIvaYRe0URe80i9ppH7LWI2CuO2GsZsdcqYq91xN4qEXttIvbaRuy1i9hrH7HXIWJv1Yi9jhF7nSL2OkfsdYnY6xqx1y1ir3vEXo+IvZ4Re70i9laL2Osdsbd6xN4aEXtrRuytFbHXJ2Jv7Yi9dSL21o3YWy9ib/2IvQ0i9jaM2PMi9kzEXknEXmnEXlnEXnnEXkXEXmXEXlXEXnXEXt+IvY0i9jaO2NskYm/TiL3NIvY2j9jbImKvX8TelhF7W0Xs9Y/Y2zpib5uIvQERe9tG7G0Xsbd9xN7AiL0dIvZ2jNjbKWJvUMTezhF7u0Ts7Rqxt1vE3u4Re3tE7O0ZsTc4Ym+viL29I/b2idjbN2Jvv4i9/SP2DojYGxKxVxOxNzRirzZiry5irz5iryFib1jE3oERewdF7A2P2Ds4Yu+QiL1DI/YOi9g7PGLviIi9IyP2jorYOzpi75iIvWMj9o6L2Ds+Yu+EiL0TI/ZOitg7OWLvlIi9UyP2RkTsnRaxNzJi7/SIvTMi9s6M2BsVsXdWxN7ZEXvnROydG7F3XsTe+RF7F0TsXRixNzpi76KIvYsj9i6J2Ls0Yu+yiL3LI/auiNgbE7F3ZcTeVRF7V0fsXROxd23E3nURe9dH7N0QsXdjxN7YiL2bIvZujtgbF7F3S8TerRF7t0XsjY/Yuz1i746IvTsj9u6K2JsQsXd3xN49EXv3RuzdF7F3f8TeAxF7D0bsTYzYeyhi7+GIvUci9iZF7D0asfdYxN7jEXuTI/aeiNh7MmLvqYi9KRF7UyP2no7YeyZi79mIvWkRe89F7D0fsfdCxN70iL0XI/Zeith7OWLvlYi9GRF7r0bszYzYey1i7/WIvVkRe29E7L0ZsfdWxN7bEXuzI/beidh7N2LvvYi99yP25kTsfRCx92HE3kcRe3Mj9j6O2JsXsfdJxN6nEXufRex9HrH3RcTelxF7X0XsfR2x903E3rcRe99F7H0fsTc/Yu+HiL0fI/YWROz9FLH3c8Tewoi9RRF7v0Ts/Rqx91vE3u8Re39E7P0Zsbc4Yu+viL2/I/b+95FuqT03Yi8VsZfn74XX3/7/3tz/316y9Y8fUUq9irKy+sqSelNqaryS6qFV5V5Z+dCKKlNlyqvK60qqSkvrq8qqKquHVld61aastN40lFeXNvjO+JtjUl/1DelViPNV1xTnq7oI58s0g/mqN81hvmpNC5ivKlMM8+WZlihf9Z5phfJV65nWKF9VnlkF5YvudhuQr3ry1Rbkq5Z8tQP5qiJf7UG+WAs7YHzVs69VMb5q2VdHjK8q9tUJ4+t/s6MzxFf9/3x1gfiq/Z+vrhBfVf/z1Q3iKz1ruyN81ad99UD4qk376onwVZX21Qvhy2eT1QC+6nxfvQG+hvq+Vgf4qvR9rZHcV4nPX2bN5L5M4GutxL6qGgJffZL7Ghr4Wju5r4BXzTqJfVX+n691E/sq/z9f6yX2Zf7P1/pJfZX9H9+bDZL6Kl3ia8OkvswSX15CX/V1S3yZpL6WvA+ZkoS+6kK+ShP6GhryVZbQV2XIV3kyX17o/dFUJPJV1xD2VZnMV13YV1UyX9VhX9XJfIXft03fRL5q/+Fro0S+av7ha+NEvir+4WuTJL5K/vF9wmyaxJf5p6/NEvgqbfinr82T+Br6T19bJPH1z+85pl8CXyVL+doygS9vKV9bZe/Lq13KV/8Evpb6/mW2ztpXVcPSvrbJ3lfd0r4GZO+remlf22bva+nvhWa7rH1V/svX9ln7Kv+Xr4FZ+zL/8rVDlr4qGv71fdXsmK2v+n/72ilbX7X/9jUoW19V//a1c7a+/v092uySpa/yCF+7ZumrNMLXbtn5qmqI8LV7lr4ivt+bPbLzVRnla8/sfJVH+RqcnS8T5WuvrHzVRP3eYfbOyld1pK99svJVGelr36x8lUb62i8bX1WRvw+Z/bPxVRnt64BsfJVH+xqSjS8T7asmC18V0b+nmaFZ+CrP4Ks2C1+lGXzVLb+vyoYMvuqz8JXh90fTsPy+KjL5Grb8vsoy+Tpw+X15mXwdtNy+SjP9XmuGL7evkoy+Dl5uX15GX4csr6/K2oy+Dl1uXxl/3zaHLa+visy+Dl9eX2WZfR2xvL68zL6OXE5fdZn/PoA5ajl91f6Hr6OX01fNf/g6Zjl9VfyHr2OXz1fJf/z9CXPc8vky/+Xr+OXyVdLwX75OWD5fQ//L14nL5+u//r6JOWm5fJn/9HXy8viqbPhPX6csl6+h/+nr1OXyVfqfvkYsj6+K//Z12vL4KvtvXyOXx5f3375OXw5fpuq/fZ2xHL68Zfg6M76v2vpl+Bq1HL5qluHrrOXwVbIMX2fH9zV0Wb7Oie+relm+zo3vq3xZvs6L7ausblm+zo/tq3SZvi6I7css09eFcX1V1i3T1+jYvsqX6euiuL4qlu3r4ri+ypbt65K4vrxl+7o0pq+yqmX7uiymr9IYvi6P6cvE8HVFPF9eXQxfY2L6Ko/h68pYviob4vi6Kp6vuji+ro7nqzqOr2vi+TJxfF0by1dFLF/XxfJVFsvX9bF8ebF83RDHl1cVy9eNMXxVNsTzNTaOr7p4vm6K46s6nq+b4/gy8XyNi+GrIqavW2L4Kovp69YYvryYvm5btq/yqpi+xi/bV1lcX7cv21dJXF93LNNXTX1cX3cu21dFXF93LdNXdWxfE5bpqzK2r7uX6as0tq97luWrbGhsX/cuy1dpfF/3LcuXie/r/mX4Kq2L7+uBZfkqj+/rwWX4KlkOXxOX4ctbDl8P/aevsoba5fD18DJ8lS2Hr0f+21f98via9N++apfH16P/7atqeXw99t++vOXx9fh/+ipdLl+T/9OXWS5fT/yXr8q65fL15H/6Kl8uX0/9l6+K5fM15b98lS2fr6n/5ctbPl9P/4evmqrl8/XMf/iqXk5fz/6Hr8rl9DXtP3yVLqev5zL7qhq6nL6ez+yrcnl9vZDZV/ny+pqe2ZdZXl8vZvRlqpfX10sZfXnL7evlDL6qG+qX29crGX3VLLevGRl9lSy3r1cz+apffl8zM/mqXX5fr2XyVbX8vl7P5Mtbfl+zMviqysLXGxl8VWTh680Mvkqy8PVWtC+vJgtfb0f6KmnIxtfsaF912fh6J9pXdTa+3o32ZbLx9V6kL5OVr/ejfHkNWfmaE+lraFa+Poj0VZqVrw8jfNU1ZOfroyhfddn5mhvlqzo7Xx9H+TLZ+ZoX4as2S1+fRPiqydLXpxG+KrL09dm/fZn6LH19/m9fXra+vviXr4r6bH19+W9fNdn6+urfvkqy9fX1v3yVZ+3rm3/5Ks3a17dL+6pryNrXd//yVZm1r++X9lWbva/5S/uqyd7XD0v7qsje149L+Sqtz97XgqV8lSTw9dNSvrwEvn7+p6/S2gS+Fi7lqyyBr0X/9FWSxNcv//TlJfH16z98ldcm8fXbP32VJfH1+z98lSXy9cc/fJUk8vVnyFdJQ30iX4v/4asika+/wr7qk/n6O+yrNpkvJxXyVZXMlxv25SXzlQr5Mgl95YV8eQkX+3B9XyCfJvgvEUgt5bc0Wd5eOO+kvvJxNTROaGnOuQCcs9S5ccE1vK2V7H1BnMUCgbzHg/MOVr7iM94EeMaB58YAe2EkziDPuiapJT1e2c5NYeO5yapuPPAKV+Jz07Tx3GRVN2b+pivxuSlqPDdZ1Y3fO4tW4nPTrPHcZFU3/vbRbCU+N81XknMTLPR7+J8uzleLlO67wmelhcD7aHFKptdL3zsv2TLIe9cS6Ct877R9G7DlDN6uPG++Iy0F8r5D6FtQHjjOVkCNAPba3GHJnPoDOKdaK59TfFZaC9yVVYTmFPqutEnJ6KI2rbHl3NypPG8+120E8r7LktnSFnivgb02dyl/d+a/G9E2taQvNvS6XWOvs6ob/52adpb1uv1K0utgoZnxVyAzdlDOjHxWOgjMwFUtYcaOKRne0cYQtpybCcrz5nPdUSDvuy1hxk7Aew3stblbOUfw3xnuZBlHdG7sdVZ1479r3tmyXndp7HVWdeN/RqGLZb3uupL0Oljo94Ofge8H3ZS/H/BZ6SbAO90teT/oAXw/mAB8P7hbOSdLnZt7lOfN57qHQN73WvJ+0BN4r4G9Nvcq5wj+ZzB7WsYRvRp7nVXd+J/d7WVZr1dbSXodLDQz/ghkxt7KmZHPSm+BGbi6Jcy4BpAZ72mllyFsOTf3Kc+bz/UaAnnfbwkzrgm818Bem/stmS0/AGfLWspnC5+VtQTuSh9LZsvaKRld1KY1tpybB5Tnzed6bYG8H7RktqwDvNfAXpsHLZkt84GzZV3ls4XPyroCd2U9S2bL+ikZXdSmNbacm4nK8+Zzvb5A3g9ZMls2AN5rYK/NQ8q/f/J/1uMGqSV9saHXGzb2Oqu68X9G6IaW9dpbSXodLDQzfgtkRqOcGfmsGIEZWGIJM5amZHhHG0PYcm4eVp43n+tSgbwfsYQZy4D3Gthr84gls+Ub4GwpVz5b+KyUC9yVCktmS2VKRhe1aY0t52aS8rz5XFcK5P2oJbOlCnivgb02j1oyW74GzpZq5bOFz0q1wF3pa8ls2Sglo4vatMaWc/OY8rz5XG8kkPfjlsyWjYH3Gthr87jy75/83ym1cWpJX2zo9SaNvc6qbvzfRbaJZb3edCXpdbDQzPgFkBk3U86MfFY2E5iBm1vCjFukZHhHG0PYcm4mK8+bz/UWAnk/YQkz9gPea2CvzRPKOYL/u1b7WcYRW64kvQ4WmiM+A3LEVso5gs/KVgK62N8Sjtg6JTMDtc0VW87Nk8rz5nO9tUDeT1nCEdsA7zWw1+YpS2bLp8DZMkD5bOGzMkDgrmxryWzZLiWji9q0xpZzM0V53nyutxPIe6ols2V74L0G9tpMtWS2fAKcLQOVzxY+KwMF7soOlsyWHVMyuqhNa2w5N08rz5vP9Y4CeT9jyWzZCXivgb02zyj//jmPHO6UWtIXG3o9qLHXWdXtY3I4yLJe79zY66zqNpcc7mxZr3dp7HVWdfuIHO5iWa93XUl6HSz0u+CHwHfB3ZS/C/JZ2U2AbXe35F1wD+C74NPAd8FnlL8TSZ2bZ5Xnzed6D4G8p1nyLrgn8F4De22mKeeID8jhnpZxxODGXmdVtznkcLBlvd5rJel1sNDM+D6QGfdWzox8VvYWmIH7WMKM+6ZkeEcbQ9hybp5Tnjef630F8n7eEmbcD3ivgb02z1syW94Dzpb9lc8WPiv7C9yVAyyZLUNSMrqoTWtsOTcvKM+bz/UQgbynWzJbaoD3GthrM135O+q75LAmtaQvNvR6aGOvs6rbO+RwqGW9rm3sdVZ1m00Oay3rdd1K0utgod8P3ga+H9Qrfz/gs1IvwDsNlrwfDAO+H7wAfD+YrpyTpc7Ni8rz5nM9TCDvlyx5PzgQeK+BvTYvWTJb3gLOloOUzxY+KwcJ3JXhlsyWg1MyuqhNa2w5Ny8rz5vP9cECeb9iyWw5BHivgb02ryh/R32THB6SWtIXG3p96ErS62ChOeINIEccppwj+KwcJqCLh1vCEUekZGagtrliy7mZoTxvPtdHCOT9qiUccSTwXgN7bV5VzhGzyOGRlnHEUY29zqpur5PDoyzr9dGNvc6qbq+Rw6Mt6/Uxjb3Oqm4zyeExlvX62MZeZ8dj5PBYy3p9XGOvs3vnIIfHWdbr4xt7nd17NTk83rJen7CS9DpY6O95LwO/552o/Hsen5UTBb5PnJSS6TX6rpwM/J43A/g971Xl37Wkzs1M5XnzuT5ZIO/XLPmedwrwXgN7bV5TzhEvkcNTLOOIU1eSXgcLzREvAjlihHKO4LMyQkAXT7OEI0amZGagtrliy7l5XXnefK5HCuQ9yxKOOB14r4G9NrOUc8R0cni6ZRxxRmOvs/tnGMjhGZb1+syVpNfBQjPj80BmHKWcGfmsjBKYgWdZwoxnp2R4RxtD2HJu3lCeN5/rswXyftMSZjwHeK+BvTZvWjJbngPOlnOVzxY+K+cK3JXzLJkt56dkdFGb1thybt5Snjef6/MF8n7bktlyAfBeA3tt3lb+jjqNHF6QWtIXG3p94UrS62ChOeJZIEeMVs4RfFZGC+jiRZZwxMUpmRmoba7Ycm5mK8+bz/XFAnm/YwlHXAK818Bem3csmS3PAGfLpcpnC5+VSwXuymWWzJbLUzK6qE1rbDk37yrPm8/15QJ5v2fJbLkCeK+BvTbvWTJbngbOljHKZwuflTECd+VKS2bLVSkZXdSmNbacm/eV583n+iqBvOdYMluuBt5rYK/NHOXfP6eSw6tTS/piQ6+vaex1VnWbQg6vsazX1zb2Oqu6PUUOr7Ws19c19jqruj1JDq+zrNfXryS9Dhb6XfAJ4LvgDcrfBfms3CDAtjda8i44Fvgu+D7wXXCO8nciqXPzgfK8+VyPFcj7Q0veBW8C3mtgr82HyjliMjm8yTKOuHkl6XWw0BzxOJAjxinnCD4r4wR08RZLOOLWlMwM1DZXbDk3HynPm8/1rQJ5z7WEI24D3mtgr81c5RzxGDm8zTKOGN/Y66zq9ig5HG9Zr29v7HVWdZtEDm+3rNd3NPY6q7o9Qg7vsKzXdzb2Oqu6PUwO77Ss13etJL0OFvq9/yHge/8E5e/9fFYmCLzH3J2S6TX6rtwDfO//CPjeP1f5+6/UuflYed58ru8RyHueJe/99wLvNbDXZp5yjphIDu+1jCPua+x1VnV7kBzeZ1mv72/sdVZ1e4Ac3m9Zrx9YSXodLPT7wf3A94MHlb8f8Fl5UIB3JlryfvAQ8P3gY+D7wTzlnCx1bj5Rnjef64cE8v7UkveDh4H3Gthr86lyjriPHD5sGUc8spL0OlhojrgXyBGTlHMEn5VJArr4qCUc8VhKZgZqmyu2nJvPlOfN5/oxgbw/t4QjHgfea2CvzeeWzJZ7gLNlsvLZwmdlssBdecKS2fJkSkYXtWmNLefmC+V587l+UiDvLy2ZLU8B7zWw1+ZL5e+od5PDp1JL+mJDr6esJL0OFpojJgA5YqpyjuCzMlVAF5+2hCOeScnMQG1zxZZz85XyvPlcPyOQ99eWcMSzwHsN7LX52pLZchdwtkxTPlv4rEwTuCvPWTJbnk/J6KI2rbHl3HyjPG8+188L5P2tJbPlBeC9BvbafKv8HfVOcvhCaklfbOj19JWk18FCc8QdQI54UTlH8Fl5UUAXX7KEI15OycxAbXPFlnPznfK8+Vy/LJD395ZwxCvAew3stfnektlyO3C2zFA+W/iszBC4K69aMltmpmR0UZvW2HJu5ivPm8/1TIG8f7BktrwGvNfAXpsflL+jjieHr6WW9MWGXr++kvQ6WGiOuA3IEbOUcwSflVkCuviGJRzxZkpmBmqbK7acmx+V583n+k2BvBdYwhFvAe81sNdmgXKOuJUcvmUZR7zd2Ous6nYLOXzbsl7Pbux1VnUbRw5nW9brdxp7nVXdbiaH71jW63cbe51V3W4ih+9a1uv3GnudVd3GksP3LOv1+ytJr4OF/sZzI/Abzxzl33j4rMwReGf9ICXTa/Rd+RD4jedH4DeeBcq/dUidm5+U583n+kOBvH+25BvPR8B7Dey1+dmS2XIDcLbMVT5b+KzMFbgrH1syW+alZHRRm9bYcm4WKs+bz/U8gbwXWTJbPgHea2CvzSLl76jXk8NPUkv6YkOvP23sdVZ1u44cfmpZrz9r7HVWdbuWHH5mWa8/b+x1VnW7hhx+blmvv2jsdVZ1u5ocfmFZr79s7HVWdbuKHH5pWa+/Wkl6HSz0N54rgd94vlb+jYfPytcC76zfpGR6jb4r3wK/8SwEfuNZpPxbh9S5+UV53nyuvxXI+1dLvvF8B7zXwF6bX5VzxBhy+J1lHPH9StLrYKE54gogR8xXzhF8VuYL6OIPlnDEjymZGahtrthybn5Tnjef6x8F8v7dEo5YALzXwF6b35VzxOXkcIFlHPHTStLrYKE54jIgR/ysnCP4rPwsoIsLLeGIRSmZGahtrthybv5Qnjef60UCef9pCUf8ArzXwF6bPy2ZLZcCZ8uvymcLn5VfJd41LJktv6dkdFGb1thybhYrz5vP9e8Cef9lyWz5A3ivgb02fyl/R72EHP6RWtIXG3r9Z2Ovs6rbxeTwT8t6vbix11nV7SJyuNiyXv/V2Ous6jaaHP5lWa//Xkl6HSz0u+CFwHdBbq7m881nhWNE+3XzZHqNviupPJn3GG3vBracm7+V583nOiWQt9PajtmSB7zXfyPnQWvdOnsBOczLW9IXG3qdv5L0OlhojjgfyBEFyjmCz0qBgC42sYQjCvNkZqC2uWLLuXGV583nulAg75QlHNEUeK+BvTYpS2bLecDZUqR8tvBZKRK4K80smS3N82R0UZvW2HJu8pTnzee6uUDe+ZbMlhbAew3stcm3ZLacC5wtxcpnC5+VYoG70tKS2dIqT0YXtWmNLeemQHnefK5bSbznWzJbWgPvNbDXpony75/nkMPWln3/XGUl6XWw0BxxNpAj2ijnCD4rbQR0sa0lHNEuT2YGapsrtpybQuV587luJ5B3U0s4oj3wXgN7bZoq54izyGF7yziiQ2Ovs6rbKHLYwbJer7qS9DpYaGY8E8iMHZUzI5+VjgIzsJMlzNg5T4Z3tDGELeemSHnefK47S/wOaAkzdgHea2CvTTPlHHEGOexiGUd0XUl6HSw0R5wO5IhuyjmCz0o3AV3sbglH9MiTmYHa5oot56a58rz5XPcQyLuFJRzRE3ivgb02LZRzxEhy2NMyjujV2Ous6nYaOexlWa9Xa+x1VnUbQQ5Xs6zXvRt7nVXdTiWHvS3r9eqNvc6qbqeQw9Ut6/UaK0mvg4V+7z8Z+N6/pvL3fj4rawq8x6xlyXt/H+B7f3Pge38L5e+/UuemWHnefK77SPxdb0ve+9cG3mtgr01LS2bLScDZso7y2cJnZR2Bu7KuJbNlvTwZXdSmNbacm1bK8+ZzvZ5A3q0tmS3rA+81sNemtfJ31BPJ4fqWvaNu0NjrrOp2AjncwLJeb7iS9DpYaGY8HsiMnnJm5LPiCcxAYwkzluTJ8I42hrDl3KyiPG8+1yUCebexhBlLgfca2GvTxpLZchxwtpQpny18VsoE7kq5JbOlIk9GF7VpjS3npq3yvPlcVwjk3c6S2VIJvNfAXpt2lsyWY4GzpUr5bOGzUiVwV6otmS1982R0UZvW2HJu2ivPm891X4G8O1gyWzYC3mtgr00HS2bLMcDZsrHy2cJnZWOBu7KJJbNl0zwZXdSmNbacm1WV583nelOBvDtaMls2A95rYK9NR0tmy9HA2bK58tnyv7MicFe2sGS29MuT0UVtWmPLuemkPG8+1/0E8u5syWzZEnivgb02nVvr1tmjyOGWlv29ja1Wkl4HC80RRwI5or9yjuCz0l9AF7e2hCO2yZOZgdrmii3npovyvPlcbyOQd1dLOGIA8F4De226KueII8jhAMs4YtvGXmdVt8PJ4baW9Xq7xl5nVbfDyOF2lvV6+8ZeZ1W3Q8nh9pb1euBK0utgod8FDwG+C+6g/F2Qz8oOAmy7oyXvgjsB3wW7AN8Fuyp/J5I6N92U583neieBvLtb8i44CHivgb023ZVzxMHkcJBlHLFzY6+zqttwcrizZb3eZSXpdbDQzHgQkBl3Vc6MfFZ2FZiBu1nCjLvnyfCONoaw5dz0UJ43n+vdBfLuaQkz7gG818Bem57KOeJAcriHZRyxZ2Ovs6rbMHK4p2W9HtzY66zq1kAOB1vW670ae51V3erJ4V6W9XrvlaTXwUK/C9YB3wX3Uf4uyGdlHwG23deSd8H9gO+CPYDvgj2VvxNJnZteyvPmc72fQN6rWfIuuD/wXgN7bVazZLbUAmfLAcpnC5+VAwTuyhBLZktNnowuatMaW85Nb+V587muEch7dUtmy1DgvQb22qxuyWwZCpwttcpnC5+VWoG7UmfJbKnPk9FFbVpjy7lZQ3nefK7rBfJe05LZ0gC818BemzUtmS01wNkyTPls4bMyTOCuHGjJbDkoT0YXtWmNLedmLeV587k+SCDvPpbMluHAew3stenTWrfODiGHwy37be3gxl5n962SHB5sWa8PWUl6HSw0M+4PZMZDlTMjn5VDBWbgYZYw4+F5MryjjSFsOTdrK8+bz/XhAnmvYwkzHgG818Bem3UsmS37AWfLkcpnC5+VIwXuylGWzJaj82R0UZvW2HJu1lWeN5/rowXyXs+S2XIM8F4De23WU/6Oui85PMayd9RjV5JeBwvNEfsAOeI45RzBZ+U4AV083hKOOCFPZgZqmyu2nJv1lefN5/oEgbw3sIQjTgTea2CvzQaWzJa9gbPlJOWzhc/KSQJ35WRLZsspeTK6qE1rbDk3GyrPm8/1KQJ5e5bMllOB9xrYa+NZMlv2As6WEcpnC5+VEQJ35TRLZsvIPBld1KY1tpwbozxvPtcjBfIusWS2nA6818Bem5LWunV2MDk83bLvn2c09jq7/5wfcniGZb0+cyXpdbDQzLgHkBlHKWdGPiujBGbgWZYw49l5MryjjSFsOTelyvPmc322QN5lljDjOcB7Dey1KVPOEbuTw3Ms44hzV5JeBwvNEbsBOeI85RzBZ+U8AV083xKOuCBPZgZqmyu2nJty5Xnzub5AIO8KSzjiQuC9BvbaVFgyW3YFzpbRymcLn5XRAnflIktmy8V5MrqoTWtsOTeVyvPmc32xQN5VlsyWS4D3GthrU2XJbNkFOFsuVT5b+KxcKnBXLrNktlyeJ6OL2rTGlnNTrTxvPteXC+Td15LZcgXwXgN7bfq21q2zO5PDKyz7/jmmsddZ1W0QORxjWa+vbOx1VnXbiRxeaVmvr2rsdVZ125EcXmVZr69eSXodLPS74A7Ad8FrlL8L8lm5RoBtr7XkXfA64LtgNfBdsK/ydyKpc7OR8rz5XF8nkPfGlrwLXg+818Bem42Vc8RAcni9ZRxxQ2Ovs6rb9uTwBst6feNK0utgoZlxOyAzjlXOjHxWxgrMwJssYcab82R4RxtD2HJuNlGeN5/rmwXy3tQSZhwHvNfAXptNlXPEtuRwnGUccUtjr7Oq2wByeItlvb61sddZ1W0bcnirZb2+bSXpdbDQ7wdbA98Pxit/P+CzMl6Ad2635P3gDuD7wSbA94NNlXOy1LnZTHnefK7vEMh7c0veD+4E3mtgr83myjmiPzm80zKOuGsl6XWw0ByxFZAjJijnCD4rEwR08W5LOOKePJkZqG2u2HJutlCeN5/rewTy7mcJR9wLvNfAXpt+yjliS3J4r2UccV9jr7O7y+TwPst6fX9jr7ObV+Twfst6/UBjr7NjMnL4gGW9fnAl6XWw0O+CmwHfBScqfxfkszJRgG0fsuRd8GHgu+AWwHfBfsrfiaTOzZbK8+Zz/bBA3ltZ8i74CPBeA3tttrJktmwKnC2TlM8WPiuTBO7Ko5bMlsfyZHRRm9bYcm76K8+bz/VjAnlvbclseRx4r4G9NltbMls2Ac6WycpnC5+VyQJ35QlLZsuTeTK6qE1rbDk32yjPm8/1kwJ5D7BktjwFvNfAXpsBlsyWjYGzZYry2cJnZYrAXZlqyWx5Ok9GF7VpjS3nZlvlefO5flog7+0smS3PAO81sNdmO0tmy0bA2fKs8tnCZ+VZgbsyzZLZ8lyejC5q0xpbzs32yvPmc/2cQN4DLZktzwPvNbDXZmBr3Trblxw+b9nf23ihsdfZ/eeDkcMXLOv19MZeZ1W3KnI43bJev9jY66zqVkkOX7Ss1y+tJL0OFvpdsAL4Lviy8ndBPisvC7DtK5a8C84AvgtuD3wXHKj8nUjq3OygPG8+1zME8t7RknfBV4H3Gthrs6Mls6UcOFtmKp8tfFZmCtyV1yyZLa/nyeiiNq2x5dzspDxvPtevC+Q9yJLZMgt4r4G9NoMsmS1lwNnyhvLZwmflDYG78qYls+WtPBld1KY1tpybnZXnzef6LYG8d7FktrwNvNfAXptdLJktpcDZMlv5bOGzMlvgrrxjyWx5N09GF7VpjS3nZlflefO5flcg790smS3vAe81sNdmN0tmSwlwtryvfLbwWXlf4K7MsWS2fJAno4vatMaWc7O78rz5XH8gkPcelsyWD4H3Gthrs0dr3TpryOGHlv29jY9Wkl4HC80RHpAj5irnCD4rcwV08WNLOGJenswM1DZXbDk3eyrPm8/1PIG8B1vCEZ8A7zWw12awco7YkBx+YhlHfLqS9DpYaI7YAMgRnynnCD4rnwno4ueWcMQXeTIzUNtcseXc7KU8bz7XXwjkvbclHPEl8F4De232tmS2rA+cLV8pny18Vr4SuCtfWzJbvsmT0UVtWmPLudlHed58rr8RyHtfS2bLt8B7Dey12Vf5O+p65PBby95Rv2vsdVZ1W5ccfmdZr79fSXodLDQzrgNkxvnKmZHPynyBGfiDJcz4Y54M72hjCFvOzX7K8+Zz/aNA3vtbwowLgPca2Guzv3KOWJscLrCMI35q7HVWdetDDn+yrNc/ryS9DhaaGdcCMuNC5czIZ2WhwAxcZAkz/pInwzvaGMKWc3OA8rz5XP8ikPcQS5jxV+C9BvbaDLFktqwJnC2/KZ8tfFZ+E7grv1syW/7Ik9FFbVpjy7mpUZ43n+s/BPIeasls+RN4r4G9NkMtmS1rAGfLYuWzhc/KYoG78pcls+XvPBld1KY1tpybWuV587n+WyDvOktmi5OPu9fAXps6S2bL6sDZ4ubrni18VjhGtN9Uvh2zJS9fRhe1aY0t56Zeed58rvME8m6wZLbkA+81sNemwZLZ0hs4WwqUzxY+KwUCd6WJJbOlMF9GF7VpjS3nZpjyvPlcFwrkfaAls6Up8F4De20OtGS2rAacLUXKZwuflSKBu9LMktnSPF9GF7VpjS3n5iDlefO5bi6Q93BLZksL4L0G9toMb61bZ3uRQ66ds5RfL+GS7HVxY6+zqltPclhsWa9bNvY6q7r1IIctLet1q8ZeZ1W37uSwlWW9bt3Y66zq1o0ctras16s09jqrunUlh6tY1us2jb3Oqm5dyGEby3rdtrHXWdWtMzlsa1mv2zX2Oqu6dSKH7SzrdfvGXmdVt47ksL1lve7Q2Ous6rYqOexgWa9Xbex1dneEHK5qWa87NvY6u9lHDjta1utOjb3OjmnJYSfLet25sdfZvauSw86W9bpLY6+z+wZFDrtY1uuujb3O7tsyOexqWa+7NfY6u9+MyGE3y3rdvbHX2f0WTA67W9brHo29zu7veJDDHpb1umdjr7P7u1vksKdlve7V2Ovs/k4mOexlWa9Xa+x1dn9fnRyuZlmvezf2Oru/a04Oe1vW69Ube53dPydEDle3rNdrNPY6u392hhyuYVmv12zsdXb/7DI5XNOyXq+1kvQ6WClw/ZoA//nRPsr/+VE+K30E/nm4tS3550fXAf7zowcB//lR9D9PuPQd8ZItE5wblD8+L+tE6Gzi/3ye0IL/d0vly8wD+H/fWfZxli69wbG1IcsPxVpA9pf/5yahP3N9gj+v5/85+P9bn/6wAdmGZF5+ej/fP6eu8++1dE28ZMsU4nx54XhNvmDAJh/vtyQfe9kk8i4RAjD0RStIpWNFiy37RcVYmi9bQy/ZMplqiOgNylcZGG7Q54XvDDJGFutSAUgsz9cNOVzHUnAdywTqWGEJiFRmH2fJ0htRIFIeAo6K/GgQqVwKRKroD9Vkfck2ygGINHVkQGTjfMGANxYAkU2UgwjnvckKAhEv2TKpVDpW9NtyCjhEkf3eVPlAZuFHgjb7qhIAzSpgjJsJgybiLEfdES/ZMuE74iVbUE3cXDls/W8QAu8xa8JmArC1hQV1ROrh/+6xQB37AesYBYNbhKCvX0wY3JL+sBVZf7KtcwCDRQ62JsHaJl8w4G0EYHCAchjkvAdYAoNuKh0rGgZdIAwi+72tchjcxB9MqHzZ35YCMLglMMbtlMNgpjviJVvGTenUxO2VQwzrKzBGw5qwnQDEDLSgjkg95BpuL1DHHYRhcGAI+naICYM70h92IhtEtnMOYLCZg61JsHbJFwx4FwEY3FU5DHLeu1oCg3x6dxWAQQcIg8h+76YcBgf4gwmVL/vbUQAGdwTGuLtyGMx0R7xkyzgpnZq4h3KIYX0FxmhYE3YXgJg9LagjUg+5hnsI1HGwMAzuGYK+wTFhcC/6w95k+5DtmwMYbO5gaxKs/fIFA95PAAb3Vw6DnPf+lsDg3246Vvh/UTXwL9Aj+32Achjc1R9MqHzZ314CMLgXMMYhymEw0x3xki0TviNesgXVxBrlEMP6CozRsCYMEYCYoRbUEamHXMMagTrWCsPg0BD01caEwTr6Qz1ZA9mwHMBgCwdbk2AdmC8Y8IECMHiQchjkvA+yBAb/ctOxomHwLyAMIvs9XDkM7u8PJlS+7K9OAAbrgDEerBwGM90RL9kyf7k6NfEQ5RDD+gqM0bAmHCwAMYdaUEekHnINDxGo42HCMHhoCPoOiwmDh9MfjiA7kuyoHMBgsYOtSbCOzhcM+GgBGDxGOQxy3sdYAoOL3XSsaBhcDIRBZL+PVQ6DB/mDCZUv+ztcAAYPB8Z4nHIYzHRHvGTLLHZ1auLxyiGG9RUYo2FNOE4AYk6woI5IPeQaHi9QxxOFYfCEEPSdGBMGT6I/nEx2CtmpOYDBlg62JsEakS8Y8AgBGDxNOQxy3qetIBhM/J9PnErHCn/rTOFiHKlcVI/xhwkqX/Z3kkBPTgLGeLowwHnJlsl0rhH3BeXrDOUvJqxjyBj5Hp8uAAtnKtcHriNQwwzX8AyBOo4Shq4zQ3A1KiZ0nUV/OJvsHLJzcwBdrRxsTYJ1Xr5gwOcJQNf5yqGL8z7fEuhqnUrHihaa1sDhdIFyUT3NHyaofNnfWQI9OQsY44XKoSvTuUbcF5Sv0cqhi3UMGSPf4wsFYOEi5frAdQRqmOEajhao48XC0HVRCK4ujgldl9AfLiW7jOzyHEBXawdbk2BdkS8Y8BUC0DVGOXRx3mNWEHR5yZb53U3Hiv7Z83fgz57Ifl+pfNCd7w8mVL7s7xIBgLsEGONVwgCHOMtRd8RLtszvrk5NvFo5xLC+AmM0rAlXCUDMNRbUEamHXMOrBep4rTAMXhOCvmtjwuB19IfryW4guzEHMLiKg61JsMbmCwY8VgAGb1IOg5z3TZbA4G9uOlY0DP4GhEFkv29WDoNj/MGEypf9XScAg9cBYxynHAYz3REv2TK/uTo18RblEMP6CozRsCaME4CYWy2oI1IPuYa3CNTxNmEYvDUEfbfFhMHx9Ifbye4guzMHMNjGwdYkWHflCwZ8lwAMTlAOg5z3hBUEg0nz75BKx4oWmg7An63uVi6qN/nDBJUv+xsv0JPxwBjvUf5zbKZzjbgvKF/3Kn8xYR1Dxsj3+B4BWLhPuT5wHYEaZriG9wrU8X5h6LovBFf3x4SuB+gPD5JNJHsoB9DV1sHWJFgP5wsG/LAAdD2iHLo470cs+QL3i5uOFf0F7hfgFzhkvycpH3QT/MGEypf9PSAAcA8AY3xU+Re4THfES7bML65OTXxMOcSwvgJjNKwJjwpAzOMW1BGph1zDxwTqOFkYBh8PQd/kmDD4BP3hSbKnyKbkAAbbOdiaBGtqvmDAUwVg8GnlMMh5P20JDC5y07GiYXAREAaR/X5GOQw+4g8mVL7s7wkBGHwCGOOzymEw0x3xki2zyNWpidOUQwzrKzBGw5rwrADEPGdBHZF6yDWcJlDH54Vh8LkQ9D0fEwZfoD9MJ3uR7KUcwGB7B1uTYL2cLxjwywIw+IpyGOS8X7EEBhe66VjRMLgQCIPIfs9QDoNP+4MJlS/7e0EABl8AxviqchjMdEe8ZMssdHVq4kzlEMP6CozRsCa8KgAxr1lQR6Qecg1nCtTxdWEYfC0Efa/HhMFZ9Ic3yN4keysHMNjBwdYkWG/nCwb8tgAMzlYOg5z37BUEg0nz75ZKx4oWGvaLivEd5aL6ij9MUPmyv1kCPZkFjPFdYYDzki2T6Vwj7gvK13vKX0xYx5Ax8j1+VwAW3leuD1xHoIYZruF7AnWcIwxd74fgak5M6PqA/vAh2Udkc3MAXas62JoE6+N8wYA/FoCuecqhi/OeZ8kXuJ/cdKzoL3A/Ab/AIfv9ifJBN9sfTKh82d8HAgD3ATDGT5V/gct0R7xky/zk6tTEz5RDDOsrMEbDmvCpAMR8bkEdkXrINfxMoI5fCMPg5yHo+yImDH5Jf/iK7Guyb3IAgx0dbE2C9W2+YMDfCsDgd8phkPP+zhIYXOCmY0XD4AIgDCL7/b1yGJznDyZUvuzvSwEY/BIY43zlMJjpjnjJllng6tTEH5RDDOsrMEbDmjBfAGJ+tKCOSD3kGv4gUMcFwjD4Ywj6FsSEwZ/oDz+TLSRblAMY7ORgaxKsX/IFA/5FAAZ/VQ6DnPevKwgGk+bfO5WOFS00vYE/W/2mXFS/84cJKl/295NAT34Cxvi78p9jM51rxH1B+fpD+YsJ6xgyRr7HvwvAwp/K9YHrCNQwwzX8Q6COi4Wh688QXC2OCV1/0R/+5v+jgP71ghUPXZ0dbE2ClSoQDJido/3mFeiGLs47r2BJgUF+RaBrrVQ6VrTQrAUcTvkFukX1V3+YoPJlf38JQNdfwBgLCmTPtZdsmUznGnFfUL6a4GooAl2sY8gY+R4XFOA1rFC5PnAdgRpmuIZNBOrYtAALGEtDF/cpgKumBfGgq4iea0bWnKxFDqCri4OtSbCKCwQDLhaArpbKoYvzbmkJdK2bSseKFpp1gcOplXJRzfOHCSpf9lck0JMiYIytlUNXpnONuC8oX6sohy7WMWSMfI9bC8BCG+X6wHUEapjhGq4iUMe2wtDVJgRabWNCVzt6rj1ZB7JVcwBdXR1sTYLVsUAw4I4C0NVJOXRx3p1WEHR5yZb53k3Hiv67Zt8D/64Zst+dlQ+6lv5gQuXL/toJAFw7YIxdhAEOcZaj7oiXbJnvXZ2a2FU5xLC+AmM0rAldBCCmmwV1ROoh17CrQB27C8NgtxAAdo8Jgz3ouZ5kvchWywEMdnOwNQlW7wLBgHsLwODqymGQ817dEhj8zk3HiobB74AwiOz3GsphsJM/mFD5sr8eAjDYAxjjmsphMNMd8ZIt852rUxPXUg4xrK/AGA1rwpoCENPHgjoi9ZBruJZAHdcWhsE+IQBcOyYMrkPPrUu2Htn6OYDB7g62JsHaoEAw4A0EYHBD5TDIeW9oyc+xJpWOFS00BvizladcVFf3hwkqX/a3jkBP1gHGaJT/HJvpXCPuC8pXifIXE9YxZIx8j40ALJQq1weuI1DDDNewRKCOZcLQVRoCrbKY0FVOz1WQVZJV5QC6ejjYmgSrukAw4GoB6OqrHLo4776WQFd5Kh0rWmjKgcNpI+WiuqE/TFD5sr9yiZ4AY9xYOXRlOteI+4LytYly6GIdQ8bI93hjAVjYVLk+cB2BGma4hpsI1HEzYejaNARam8WErs3puS3I+pFtmQPo6ulgaxKsrQoEA95KALr6K4cuzru/JdBVnUrHihaaauBw2lq5qPb1hwkq3/+9VAj0ZHNgjNsoh65M5xpxX1C+BiiHrp7kAxkj3+NtBGBhW+X6wHUEapjhGg4QqON2wtC1bQi0tosJXdvTcwPJdiDbMQfQ1cvB1iRYOxUIBryTAHQNUg5dnPegFQRdXrJlvnLTsaL/rtlXwL9rhuz3zsoHXX9/MKHyZX/bCwDc9sAYdxEGOMRZjrojXrJlvnJ1auKuyiGG9RUYo2FN2EUAYnazoI5IPeQa7ipQx92FYXC3EADuHhMG96Dn9iQbTLZXDmBwNQdbk2DtXSAY8N4CMLiPchjkvPexBAa/dNOxomHwSyAMIvu9r3IYHOQPJlS+7G8PARjcAxjjfsphMNMd8ZIt86WrUxP3Vw4xrK/AGA1rwn4CEHOABXVE6iHXcH+BOg4RhsEDQgA4JCYM1tBzQ8lqyepyAIO9HWxNglVfIBhwvQAMNiiHQc67wZKfYzdLpWNFC81mwJ+thikX1X38YYLKl/3VCPSkBhjjgcp/js10rhH3BeXrIOUvJqxjyBj5Hh8oAAvDlesD1xGoYYZreJBAHQ8Whq7hIdA6OCZ0HULPHUp2GNnhOYCu1R1sTYJ1RIFgwEcIQNeRyqGL8z7Ski9wn7vpWNFf4D4HfoFD9vso5YOuwR9MqHzZ3yECAHcIMMajlX+By3RHvGTLfO7q1MRjlEMM6yswRsOacLQAxBxrQR2Resg1PEagjscJw+CxIQA8LiYMHk/PnUB2ItlJOYDBNRxsTYJ1coFgwCcLwOApymGQ8z7Fki9wW6XSsaKFZivgl4pTlYvqkf4wQeXL/o4X6MnxwBhHKP8Cl+lcI+4Lytdpyl9MWMeQMfI9HiEACyOV6wPXEahhhmt4mkAdTxeGrpEh0Do9JnSdQc+dSTaK7KwcQNeaDrYmwTq7QDDgswWg6xzl0MV5n2MJdA1IpWNFC80A4HA6V7monuIPE1S+7O8MgZ6cAYzxPOXQlelcI+4Lytf5yqGLdQwZI9/j8wRg4QLl+sB1BGqY4RqeL1DHC4Wh64IQaF0YE7pG03MXkV1MdkkOoGstB1uTYF1aIBjwpQLQdZly6OK8L7MEugam0rGihWYgcDhdrlxUz/GHCSpf9jdaoCejgTFeoRy6Mp1rxH1B+RqjHLpYx5Ax8j2+QgAWrlSuD1xHoIYZruEYgTpeJQxdV4ZA66qY0HU1PXcN2bVk1+UAuvo42JoE6/oCwYCvF4CuG5RDF+d9wwqCLi/ZMvPcdKzov2s2D/h3zZD9vlH5oLvMH0yofNnf1QIAdzUwxrHCAIc4y1F3xEu2zDxXpybepBxiWF+BMRrWhLECEHOzBXVE6iHX8CaBOo4ThsGbQwA4LiYM3kLP3Up2G9n4HMDg2g62JsG6vUAw4NsFYPAO5TDIed9hCQx+7KZjRcPgx0AYRPb7TuUweIM/mFD5sr9bBGDwFmCMdymHwUx3xEu2zMeuTk2coBxiWF+BMRrWhLsEIOZuC+qI1EOu4QSBOt4jDIN3hwDwnpgweC89dx/Z/WQP5AAG13GwNQnWgwWCAT8oAIMTlcMg5z3REhic66ZjRcPgXCAMIvv9kHIYvMMfTKh82d+9AjB4LzDGh5XDYKY74iVbZq6rUxMfUQ4xrK/AGA1rwsMCEDPJgjoi9ZBr+IhAHR8VhsFJIQB8NCYMPkbPPU42meyJHMDgug62JsF6skAw4CcFYPAp5TDIeT9lCQx+5KZjRcPgR0AYRPZ7inIYnOgPJlS+7O8xARh8DBjjVOUwmOmOeMmW+cjVqYlPK4cY1ldgjIY1YaoAxDxjQR2Resg1fFqgjs8Kw+AzIQB8NiYMTqPnniN7nuyFHMDgeg62JsGaXiAY8HQBGHxROQxy3i+uIBhM/F9pk0rHihYa9ouK8SXlovqUP0xQ+bK/aQI9mQaM8WVhgPOSLZPpXCPuC8rXK8pfTFjHkDHyPX5ZABZmKNcHriNQwwzX8BWBOr4qDF0zQqD1akzomknPvUb2OtmsHEDX+g62JsF6o0Aw4DcEoOtN5dDFeb9pyRe4D9x0rOgvcB8Av8Ah+/2W8kH3oj+YUPmyv5kCADcTGOPbyr/AZbojXrJlPnB1auJs5RDD+gqM0bAmvC0AMe9YUEekHnINZwvU8V1hGHwnBIDvxoTB9+i598nmkH2QAxjcwMHWJFgfFggG/KEADH6kHAY5748sgcE5bjpWNAzOAcIgst9zlcPgm/5gQuXL/t4TgMH3gDF+rBwGM90RL9kyc1ydmjhPOcSwvgJjNKwJHwtAzCcW1BGph1zDeQJ1/FQYBj8JAeCnMWHwM3ruc7IvyL7MAQxu6GBrEqyvCgQD/koABr9WDoOc99eW/By7dyodK1po9gb+bPWNclH9yB8mqHzZ32cCPfkMGOO3yn+OzXSuEfcF5es75S8mrGPIGPkefysAC98r1weuI1DDDNfwO4E6zheGru9DoDU/JnT9QM/9SLaA7KccQJfnYGsSrJ8LBAP+WQC6FiqHLna60BLo2j+VjhUtNPsDh9Mi5aL6tT9MUPmyvx8EevIDMMZflENXpnONuC8oX78qhy5uDDJGvse/CMDCb8r1gZ0CNcxwDX8VqOPvwtD1Wwi0fo8JXX/Qc3+SLebncwBdxsHWJFh/FwgG/LcAdDlNdEPX/xSwyZICg/yKxPqum44V/bPnu8CfPZH9dpvoHnQL/cGEypf9/SEAcH8AY0w1kb0jiLMcdUe8ZMu86+rUxLwmuiGGLx4wRsOawGcQfW7yLagjUg+5hnkCdSxoggWfpWGQ+xRAX0GTeDDYhJ4rJGtKVtRkxcNgiYOtSbCaNREMuFkTvN/mymGQ825uCQy+46ZjRcPgO0AYRPa7hXIYdPzBBDvfTdLChY6zCTDGYuUwmOmOeMmWecfVqYktlUMM6yswRsOaUCwAMa0sqCNSD7mGLQXq2FoYBluFALB1TBhchZ5rQ9aWrF0OYLDUwdYkWO2bCAbcXgAGOyiHQc67gyUwONtNx4qGwdlAGET2e1XlMNjcH0yofNnfKgIwuAowxo7KYTDTHfGSLTPb1amJnZRDDOsrMEbDmtBRAGI6W1BHpB5yDTsJ1LGLMAx2DgFgl5gw2JWe60bWnaxHDmCwzMHWJFg9mwgG3FMABnsph0HOu9cKgsGk+den0rGihYb9omJcTbmodvCHCSpf9tdVoCddgTH2FgY4L9kymc414r6gfK2u/MWEdQwZI9/j3gKwsIZyfeA6AjXMcA1XF6jjmsLQtUYItNaMCV1r0XN9yNYmWycH0FXuYGsSrHWbCAa8rgB0raccujjv9SyBroNS6VjRQnMQcDitr1xUe/nDBJUv+1tLoCdrAWPcQDl0ZTrXiPuC8rWhcuhiHUPGyPd4AwFY8JTrA9cRqGGGa7ihQB2NMHR5IdAyMaGrhJ4rJSsjK88BdFU42JoEq6KJYMAVAtBVqRy6OO9KS372fNNNx4r+2fNN4M+eyH5XKR906/mDCZUv+ysRALgSYIzVyn/2zHRHvGTLvOnq1MS+yiGG9RUYo2FNqBaAmI0sqCNSD7mGfQXquLEwDG4UAsCNY8LgJvTcpmSbcWw5gMFKB1uTYG3RRDDgLQRgsJ9yGOS8+1nyBe6wVDpWtNAcBvxSsaVyUa30hwkqX/a3iUBPNgHGuJXyL3CZzjXivqB89Vf+YsI6hoyR7/FWArCwtXZ9IB9ADTNcw/4CddxGGLq2DoHWNjGhawA9ty3ZdmTb5wC6qhxsTYI1sIlgwAMFoGsH5dDFee9gyRe4WW46VvQXuFnAL3DIfu+ofND18wcTKl/2N0AA4AYAY9xJ+Re4THfES7bMLFenJg5SDjGsr8AYDWvCTgIQs7MFdUTqIddwkEAddxGGwZ1DALhLTBjclZ7bjWx3sj1yAIPVDrYmwdqziWDAewrA4GDlMMh5D7YEBl9307GiYfB1IAwi+72XchjcwR9MqHzZ364CMLgrMMa9lcNgpjviJVvmdVenJu6jHGJYX4ExGtaEvQUgZl8L6ojUQ67hPgJ13E8YBvcNAeB+MWFwf3ruALIhZDU5gMG+DrYmwRraRDDgoQIwWKscBjnvWktg8DU3HSsaBl8DwiCy33XKYXCwP5hQ+bK//QVgcH9gjPXKYTDTHfGSLfOaq1MTG5RDDOsrMEbDmlAvADHDLKgjUg+5hg0CdTxQGAaHhQDwwJgweBA9N5zsYLJDcgCDGznYmgTr0CaCAR8qAIOHKYdBzvswS2BwppuOFQ2DM4EwiOz34cphsNYfTKh82d9BAjB4EDDGI5TDYKY74iVbZqarUxOPVA4xrK/AGA1rwhECEHOUBXVE6iHX8EiBOh4tDINHhQDw6JgweAw9dyzZcWTH5wAGN3awNQnWCU0EAz5BAAZPVA6DnPeJlsDgq246VjQMvgqEQWS/T1IOg4f5gwmVL/s7RgAGjwHGeLJyGMx0R7xky7zq6tTEU5RDDOsrMEbDmnCyAMScakEdkXrINTxFoI4jhGHw1BAAjogJg6fRcyPJTic7IwcwuImDrUmwzmwiGPCZAjA4SjkMct6jLIHBGW46VjQMzgDCILLfZymHwRP9wYTKl/2dJgCDpwFjPFs5DGa6I16yZWa4OjXxHOUQw/oKjNGwJpwtADHnWlBHpB5yDc8RqON5wjB4bggAz4sJg+fTcxeQXUg2OgcwuKmDrUmwLmoiGPBFAjB4sXIY5LwvtgQGX3HTsaJh8BUgDCL7fYlyGBzlDyZUvuzvfAEYPB8Y46XKYTDTHfGSLfOKq1MTL1MOMayvwBgNa8KlAhBzuQV1ROoh1/AygTpeIQyDl4cA8IqYMDiGnruS7Cqyq3MAg5s52JoE65omggFfIwCD1yqHQc772hUEg4m/HKXSscK/cKVwMV6nXFQv9ocJKl/2N0agJ2OAMV4vDHBesmUynWvEfUH5ukH5iwnrGDJGvsfXC8DCjcr1gesI1DDDNbxBoI5jhaHrxhBojY0JXTfRczeTjSO7JQfQtbmDrUmwbpWCrs1952i/tymHLvZzmyVf4F5y07Giv8C9BPwCh+z3eOWD7lp/MKHyZX83CQDcTcAYb1f+BS7THfGSLfOSq1MT71AOMewHGKNhTbhdAGLutKCOSD3kGt4hUMe7hGHwzhAA3hUTBifQc3eT3UN2bw5gcAsHW5Ng3ddEMOD7BGDwfuUwyHnfb8kXuBGpdKxooRkB/FLxgHJRvc0fJqh82d8EgZ5MAMb4oPIvcJnONeK+oHxNVP5iwjqGjJHv8YMCsPCQcn3gOgI1zHANJwrU8WFh6HooBFoPx4SuR+i5SWSPkj2WA+jq52BrEqzHmwgG/LgAdE1WDl2c92RLvsBNd9Oxor/ATQd+gUP2+wnlg+5+fzCh8mV/jwgA3CPAGJ9U/gUu0x3xki0z3dWpiU8phxjWV2CMhjXhSQGImWJBHZF6yDV8SqCOU4VhcEoIAKfGhMGn6blnyJ4lm5YDGNzSwdYkWM81EQz4OQEYfF45DHLez1sCgy+46VjRMPgCEAaR/X5BOQxO9gcTKl/297QADD4NjHG6chjMdEe8ZMu84OrUxBeVQwzrKzBGw5owXQBiXrKgjkg95Bq+KFDHl4Vh8KUQAL4cEwZfoedmkL1KNjMHMLiVg61JsF5rIhjwawIw+LpyGOS8X7fk59hRqXSsaKEZBfzZapZyUX3eHyaofNnfKwI9eQUY4xvKf47NdK4R9wXl603lLyasY8gY+R6/IQALbynXB64jUMMM1/BNgTq+LQxdb4VA6+2Y0DWbnnuH7F2y93IAXf0dbE2C9X4TwYDfF4CuOcqhi/OeYwl0nZtKx4oWmnOBw+kD5aL6uj9MUPmyv9kCPZkNjPFD5dCV6Vwj7gvK10fKoYt1DBkj3+MPBWBhrnJ94DoCNcxwDT8SqOPHwtA1NwRaH8eErnn03Cdkn5J9lgPo2trB1iRYnzcRDPhzAej6Qjl0cd5fWPKz5zQ3HSv6Z89pwJ89kf3+Uvmgm+MPJlS+7G+eAMDNA8b4lfKfPTPdES/ZMtNcnZr4tXKIYX0FxmhYE74SgJhvLKgjUg+5hl8L1PFbYRj8JgSA38aEwe/oue/J5pP9kAMY3MbB1iRYPzYRDPhHARhcoBwGOe8FlnyBG51Kx4oWmtHALxU/KRfVL/xhgsqX/X0n0JPvgDH+rPwLXKZzjbgvKF8Llb+YsI4hY+R7/LMALCxSrg9cR6CGGa7hQoE6/iIMXYtCoPVLTOj6lZ77jex3sj9yAF0DHGxNgvVnE8GA/xSArsXKoYvzXmwJdF2aSseKFppLgcPpL+WiusAfJqh82d+vAj35FRjj38qhK9O5RtwXlC+nUDd0sY4hY+R7/LcALLiFuvWB6wjUMMM15L6g65gqxALG0tDFfQrgKlUYD7ry6Ll8sgKyJoUrHrq2dbA1CVZhoWDAhYV4v00LdUMX5920cEmBQX5FoGtMKh0rWmjGAIdTkXJRXewPE1S+7C9PoCd5wHvTrFD2XHvJlsl0rhH3BeWruXLoYh1Dxsj3uJkALLRQrg9cR6CGGa5hc4E6FgtDV4sQaBXHhK6W9FwrstZkq+QAurZzsDUJVptCwYDbCEBXW+XQxXm3XUHQ5SVbZqqbjhX9d82mAv+uGbLf7ZQPuqb+YELly/5aCgBcS2CM7YUBDnGWo+6Il2yZqa5OTeygHGJYX4ExGtaE9gIQs6oFdUTqIdewg0AdOwrD4KohAOwYEwY70XOdybqQdc0BDG7vYGsSrG6FggF3E4DB7sphkPPubgkMTnHTsaJhcAoQBpH97qEcBtv6gwmVL/vrJACDnYAx9lQOg5nuiJdsmSmuTk3spRxiWF+BMRrWhJ4CELOaBXVE6iHXsJdAHXsLw+BqIQDsHRMGV6fn1iBbk2ytHMDgQAdbk2D1KRQMuI8ADK6tHAY577UtgcGn3HSsaBh8CgiDyH6voxwGu/uDCZUv+1tdAAZXB8a4rnIYzHRHvGTLPOXq1MT1lEMM6yswRsOasK4AxKxvQR2Resg1XE+gjhsIw+D6IQDcICYMbkjPeWSGrCQHMLiDg61JsEoLBQMuFYDBMuUwyHmXWQKDT7rpWNEw+CQQBpH9LlcOg2v7gwmVL/vbUAAGNwTGWKEcBjPdES/ZMk+6OjWxUjnEsL4CYzSsCRUCEFNlQR2Resg1rBSoY7UwDFaFALA6Jgz2pec2ItuYbJMcwOCODrYmwdq0UDDgTQVgcDPlMMh5b7aCYDBp/jek0rGihYb9omLcXLmolvnDBJUv++sr0JO+wBi3EAY4L9kymc414r6gfPVT/mLCOoaMke/xFgKwsKVyffjf4AbWkWvYT6COWwlD15Yh0NoqJnT1p+e2JtuGbEAOoGsnB1uTYG1bKBjwtgLQtZ1y6OK8t7PkC9xkNx0r+gvcZOAXOGS/t1c+6DbzBxMqX/bXXwDg+gNjHKj8C1ymO+IlW2ayq1MTd1AOMayvwBgNa8JAAYjZ0YI6IvWQa7iDQB13EobBHUMAuFNMGBxEz+1MtgvZrjmAwUEOtibB2q1QMODdBGBwd+UwyHnvbskXuHGpdKxooRkH/FKxh3JR3c4fJqh82d8ggZ4MAsa4p/IvcJnONeK+oHwNVv5iwjqGjJHv8Z4CsLCXcn3gOgI1zHANBwvUcW9h6NorBFp7x4Sufei5fcn2I9s/B9C1s4OtSbAOKBQM+AAB6BqiHLo47yGWfIF7zE3Hiv4C9xjwCxyy3zXKB93u/mBC5cv+9hEAuH2AMQ5V/gUu0x3xki3zmKtTE2uVQwzrKzBGw5owVABi6iyoI1IPuYa1AnWsF4bBuhAA1seEwQZ6bhjZgWQH5QAGd3GwNQnW8ELBgIcLwODBymGQ8z7YEhh81E3HiobBR4EwiOz3IcphcIg/mFD5sr8GARhsAMZ4qHIYzHRHvGTLPOrq1MTDlEMM6yswRsOacKgAxBxuQR2Resg1PEygjkcIw+DhIQA8IiYMHknPHUV2NNkxOYDBXR1sTYJ1bKFgwMcKwOBxymGQ8z7OEhic5KZjRcPgJCAMIvt9vHIYPNgfTKh82d+RAjB4JDDGE5TDYKY74iVbZpKrUxNPVA4xrK/AGA1rwgkCEHOSBXVE6iHX8ESBOp4sDIMnhQDw5JgweAo9dyrZCLLTcgCDuznYmgRrZKFgwCMFYPB05TDIeZ9uCQw+4qZjRcPgI0AYRPb7DOUweJw/mFD5sr9TBGDwFGCMZyqHwUx3xEu2zCOuTk0cpRxiWF+BMRrWhDMFIOYsC+qI1EOu4SiBOp4tDINnhQDw7JgweA49dy7ZeWTn5wAGd3ewNQnWBYWCAV8gAIMXKodBzvtCS2DwYTcdKxoGHwbCILLfo5XD4On+YELly/7OEYDBc4AxXqQcBjPdES/ZMg+7OjXxYuUQw/oKjNGwJlwkADGXWFBHpB5yDS8WqOOlwjB4SQgAL40Jg5fRc5eTXUE2JgcwuIeDrUmwriwUDPhKARi8SjkMct5XrSAYTJr/hFQ6VrTQsF9UjFcrF9UL/WGCypf9XSbQk8uAMV4jDHBesmUynWvEfUH5ulb5iwnrGDJGvsfXCMDCdcr1gesI1DDDNbxWoI7XC0PXdSHQuj4mdN1Az91INpbsphxA154OtibBurlQMOCbBaBrnHLo4rzHWfIFbqKbjhX9BW4i8Ascst+3KB90V/mDCZUv+7tBAOBuAMZ4q/IvcJnuiJdsmYmuTk28TTnEsL4CYzSsCbcKQMx4C+qI1EOu4W0CdbxdGAbHhwDw9pgweAc9dyfZXWQTcgCDgx1sTYJ1d6FgwHcLwOA9ymGQ877HEhh80E3HiobBB4EwiOz3vcphcJw/mFD5sr87BGDwDmCM9ymHwUx3xEu2zIOuTk28XznEsL4CYzSsCfcJQMwDFtQRqYdcw/sF6vigMAw+EALAB2PC4ER67iGyh8keyQEM7uVgaxKsSYWCAU8SgMFHlcMg5/2oJTD4gJuOFQ2DDwBhENnvx5TD4D3+YELly/4mCsDgRGCMjyuHwUx3xEu2zAOuTk2crBxiWF+BMRrWhMcFIOYJC+qI1EOu4WSBOj4pDINPhADwyZgw+BQ9N4VsKtnTOYDBvR1sTYL1TKFgwM8IwOCzymGQ8352BcFg4reuVDpWtNCwX1SM05SL6qP+MEHly/6eEujJU8AYnxMGOC/ZMpnONeK+oHw9r/zFhHUMGSPf4+cEYOEF5frAdQRqmOEaPi9Qx+nC0PVCCLSmx4SuF+m5l8heJnslB9C1j4OtSbBmFAoGPEMAul5VDl2c96uWfIG7z03Hiv4Cdx/wCxyy3zOVD7pn/cGEypf9vSgAcC8CY3xN+Re4THfES7bMfa5OTXxdOcSwvgJjNKwJrwlAzCwL6ojUQ67h6wJ1fEMYBmeFAPCNmDD4Jj33FtnbZLNzAIP7OtiaBOudQsGA3xGAwXeVwyDn/a4lX+AmpdKxooVmEvBLxXvKRfVVf5ig8mV/bwr05E1gjO8r/wKX6Vwj7gvK1xzlLyasY8gY+R6/LwALHyjXB64jUMMM13COQB0/FIauD0Kg9WFM6PqInptL9jHZvBxA134OtibB+qRQMOBPBKDrU+XQxXl/agl0TU6lY0ULzWTgcPpMuai+6w8TVL7s7yOBnnwEjPFz5dCV6Vwj7gvK1xfKoYt1DBkj3+PPBWDhS+X6wHUEapjhGn4hUMevhKHryxBofRUTur6m574h+5bsuxxA1/4OtibB+r5QMODvBaBrvnLo4rznW/Kz591uOlb0z553A3/2RPb7B+WD7lN/MKHyZX9fCwDc18AYf1T+s2emO+IlW+ZuV6cmLlAOMayvwBgNa8KPAhDzkwV1ROoh13CBQB1/FobBn0IA+HNMGFxIzy0i+4Xs1xzA4AEOtibB+q1QMODfBGDwd+UwyHn/bskXuKmpdKxooZkK/FLxh3JRne8PE1S+7G+hQE8WAmP8U/kXuEznGnFfUL4WK38xYR1Dxsj3+E8BWPhLuT5wHYEaZriGiwXq+LcwdP0VAq2/Y0KX05T2yVJkeU1XPHQNcbA1CVZ+U8GA2Tnab0FT3dDFeRc0XVJgkF8R6JqWSseKFpppwOHUpKluUf3dHyaofP8H7AI9cYD3prCp7Ln2ki2T6Vwj7gvKV9OmwN4KnOshfAyBMfI9LmyK17Ai5frAdQRqmOEaNhWoY7OmWMBYGrq4TwFcNWsaD7qa03MtyIrJWuYAumocbE2C1aqpYMCtBKCrtXLo4rxbryDo8pItc6ebjhX9s+edwJ89kf1eRfmgK/AHEypf9tdcAOCaA2NsIwxwiLMcdUe8ZMvc6erUxLbKIYb1FRijYU1oIwAx7SyoI1IPuYZtBerYXhgG24UAsH1MGOxAz61K1pGsUw5gcKiDrUmwOjcVDLizAAx2UQ6DnHcXS77AvZhKx4oWmheBXyq6KhfV1v4wQeXL/joI9KQDMMZuyr/AZTrXiPuC8tVd+YsJ6xgyRr7H3QRgoYdyfeA6AjXMcA27C9SxpzB09QiBVs+Y0NWLnluNrDfZ6jmArloHW5NgrdFUMOA1BKBrTeXQxXmvaQl0zUilY0ULzQzgcFpLuah28YcJKl/210ugJ72AMfZRDl2ZzjXivqB8ra0culjHkDHyPe4jAAvrKNcHriNQwwzXcG2BOq4rDF3rhEErJnStR8+tT7YB2YY5gK46B1uTYHlNBQP2BKDLKIcuzttY8rPneDcdK/pnz/HAnz2R/S5RPujW9AcTKl/2t54AwK0HjLFU+c+eme6Il2yZ8a5OTSxTDjGsr8AYDWtCqQDElFtQR6Qecg3LBOpYIQyD5SEArIgJg5X0XBVZNVnfHMBgvYOtSbA2aioY8EYCMLixchjkvDe25AvcrFQ6VrTQzAJ+qdhEuagaf5ig8mV/lQI9qQTGuKnyL3CZzjXivqB8bab8xYR1DBkj3+NNBWBhc+X6wHUEapjhGm4mUMcthKFr8xBobRETuvrRc1uSbUXWPwfQ1eBgaxKsrZsKBry1AHRtoxy6OO9tLPkCd6ubjhX9Be5W4Bc4ZL8HKB90G/uDCZUv++snAHD9gDFuq/wLXKY74iVb5lZXpyZupxxiWF+BMRrWhG0FIGZ7C+qI1EOu4XYCdRwoDIPbhwBwYEwY3IGe25FsJ7JBOYDBYQ62JsHaualgwDsLwOAuymGQ897FEhi8xU3HiobBW4AwiOz3rsphcBt/MKHyZX87CMDgDsAYd1MOg5nuiJdsmVtcnZq4u3KIYX0FxmhYE3YTgJg9LKgjUg+5hrsL1HFPYRjcIwSAe8aEwcH03F5ke5PtkwMYPNDB1iRY+zYVDHhfARjcTzkMct77WQKD49x0rGgYHAeEQWS/91cOg7v4gwmVL/sbLACDg4ExHqAcBjPdES/ZMuNcnZo4RDnEsL4CYzSsCQcIQEyNBXVE6iHXcIhAHYcKw2BNCACHxoTBWnqujqyerCEHMHiQg61JsIY1FQx4mAAMHqgcBjnvAy2BwZvddKxoGLwZCIPIfh+kHAb38wcTKl/2VysAg7XAGIcrh8FMd8RLtszNrk5NPFg5xLC+AmM0rAnDBSDmEAvqiNRDruHBAnU8VBgGDwkB4KExYfAweu5wsiPIjswBDA53sDUJ1lFNBQM+SgAGj1YOg5z30ZbA4E1uOlY0DN4EhEFkv49RDoMH+oMJlS/7O0wABg8DxnischjMdEe8ZMvc5OrUxOOUQwzrKzBGw5pwrADEHG9BHZF6yDU8TqCOJwjD4PEhADwhJgyeSM+dRHYy2Sk5gMGDHWxNgnVqU8GATxWAwRHKYZDzHmEJDI5107GiYXAsEAaR/T5NOQwe7Q8mVL7s70QBGDwRGONI5TCY6Y54yZYZ6+rUxNOVQwzrKzBGw5owUgBizrCgjkg95BqeLlDHM4Vh8IwQAJ4ZEwZH0XNnkZ1Ndk4OYPAQB1uTYJ3bVDDgcwVg8DzlMMh5n7eCYDBp/nNS6VjRQsN+UTGer1xUR/jDBJUv+xsl0JNRwBgvEAY4L9kymc414r6gfF2o/MWEdQwZI9/jCwRgYbRyfeA6AjXMcA0vFKjjRcLQNToEWhfFhK6L6blLyC4luywH0HWog61JsC5vKhjw5QLQdYVy6OK8r7AEuuam0rGihWYucDiNUS6q5/nDBJUv+7tYoCcXA2O8Ujl0ZTrXiPuC8nWVcuhiHUPGyPf4SgFYuFq5PnAdgRpmuIZXCdTxGmHoujoEWtfEhK5r6bnryK4nuyEH0HWYg61JsG5sKhjwjQLQNVY5dHHeYy352fN6Nx0r+mfP64E/eyL7fZPyQXeFP5hQ+bK/awUA7lpgjDcr/9kz0x3xki1zvatTE8cphxjWV2CMhjXhZgGIucWCOiL1kGs4TqCOtwrD4C0hALw1JgzeRs+NJ7ud7I4cwODhDrYmwbqzqWDAdwrA4F3KYZDzvssSGLzOTceKhsHrgDCI7PcE5TA41h9MqHzZ320CMHgbMMa7lcNgpjviJVvmOlenJt6jHGJYX4ExGtaEuwUg5l4L6ojUQ67hPQJ1vE8YBu8NAeB9MWHwfnruAbIHySbmAAaPcLA1CdZDTQUDfkgABh9WDoOc98OWwOC1bjpWNAxeC4RBZL8fUQ6Dd/mDCZUv+7tfAAbvB8Y4STkMZrojXrJlrnV1auKjyiGG9RUYo2FNmCQAMY9ZUEekHnINHxWo4+PCMPhYCAAfjwmDk+m5J8ieJHsqBzB4pIOtSbCmNBUMeIoADE5VDoOc91RLYPAaNx0rGgavAcIgst9PK4fBh/3BhMqX/U0WgMHJwBifUQ6Dme6Il2yZa1ydmviscohhfQXGaFgTnhGAmGkW1BGph1zDZwXq+JwwDE4LAeBzMWHweXruBbLpZC/mAAaPcrA1CdZLTQUDfkkABl9WDoOc98uWwODVbjpWNAxeDYRBZL9fUQ6DU/3BhMqX/T0vAIPPA2OcoRwGM90RL9kyV7s6NfFV5RDD+gqM0bAmzBCAmJkW1BGph1zDVwXq+JowDM4MAeBrMWHwdXpuFtkbZG/mAAaPdrA1CdZbTQUDfksABt9WDoOc99uWwOBVbjpWNAxeBYRBZL9nK4fBl/3BhMqX/b0uAIOvA2N8RzkMZrojXrJlrnJ1auK7yiGG9RUYo2FNeEcAYt6zoI5IPeQavitQx/eFYfC9EAC+HxMG59BzH5B9SPZRDmDwGAdbk2DNbSoY8FwBGPxYOQxy3h+vIBhMmv/XqXSsaKFhv6gY5ykX1bf9YYLKl/3NEejJHGCMnwgDnJdsmUznGnFfUL4+Vf5iwjqGjJHv8ScCsPCZcn3gOgI1zHANPxWo4+fC0PVZCLQ+jwldX9BzX5J9RfZ1DqDrWAdbk2B901Qw4G8EoOtb5dDFeX9ryRe4MW46VvQXuDHAL3DIfn+nfNB97A8mVL7s7wsBgPsCGOP3yr/AZbojXrJlxrg6NXG+cohhfQXGaFgTvheAmB8sqCNSD7mG8wXq+KMwDP4QAsAfY8LgAnruJ7KfyRbmAAaPc7A1CdaipoIBLxKAwV+UwyDn/YslX+Dmp9KxooVmPvBLxa/KRfVbf5ig8mV/CwR6sgAY42/Kv8BlOteI+4Ly9bvyFxPWMWSMfI9/E4CFP5TrA9cRqGGGa/i7QB3/FIauP0Kg9WdM6FrMz5H9zfO0aMVD1/EOtib/F2eRYMDsHO03VaQbujjvVNGSAoP8isR6uZuOFf0F7nLgFzhkv/OKdA+6X/zBhMqX/S0WALjFwBjzi2TvCOIsR90RL9kyl7s6NbGgSDfEsL4CYzSsCflF+HPTxII6IvWQa1ggUMfCIiz4LA2D3KcA+gqL4sFgU3quiKwZWfMcwOAJDrYmwWpRJBhwCwEYLFYOg5x38QqCwaT5/5xKx4oWmp+BXypaKhfVlD9MUPmyv6YCPWkKjLGVMMB5yZbJdK4R9wXlq7XyFxPWMWSMfI9bCcDCKsr1gesI1DDDNWwtUMc2wtC1Sgi02sSErrb0XDuy9mQdcgBdJzrYmgRr1SLBgFcVgK6OyqGL8+5oCXT9mkrHihaaX4HDqZNyUS32hwkqX/bXVqAnbYExdlYOXZnONeK+oHx1UQ5drGPIGPkedxaAha7K9YHrCNQwwzXsIlDHbsLQ1TUEWt1iQld3eq4HWU+yXjmArpMcbE2CtVqRYMCrCUBXb+XQxXn3tuRnz0vcdKzonz0vAf7siez36soHXUd/MKHyZX/dBQCuOzDGNZT/7JnpjnjJlrnE1amJayqHGNZXYIyGNWENAYhZy4I6IvWQa7imQB37CMPgWiEA7BMTBtem59YhW5dsvRzA4MkOtibBWr9IMOD1BWBwA+UwyHlvYAkMXuymY0XD4MVAGET2e0PlMNjbH0yofNnf2gIwuDYwRk85DGa6I16yZS52dWqiUQ4xrK/AGA1rgicAMSUW1BGph1xDI1DHUmEYLAkBYGlMGCyj58rJKsgqcwCDpzjYmgSrqkgw4CoBGKxWDoOcd7UlMHiRm44VDYMXAWEQ2e++ymFwA38wofJlf2UCMFgGjHEj5TCY6Y54yZa5yNWpiRsrhxjWV2CMhjVhIwGI2cSCOiL1kGu4sUAdNxWGwU1CALhpTBjcjGMi24KsXw5g8FQHW5NgbVkkGPCWAjC4lXIY5Ly3sgQGR7vpWNEwOBoIg8h+91cOg9X+YELly/42E4DBzYAxbq0cBjPdES/ZMqNdnZq4jXKIYX0FxmhYE7YWgJgBFtQRqYdcw20E6ritMAwOCAHgtjFhcDt6bnuygWQ75AAGRzjYmgRrxyLBgHcUgMGdlMMg573TCoLBxPnnpWNFCw37RcU4SLmobuUPE1S+7G87gZ5sB4xxZ2GA85Itk+lcI+4Lytcuyl9MWMeQMfI93lkAFnZVrg9cR6CGGa7hLgJ13E0YunYNgdZuMaFrd3puD7I9yQbnALpOc7A1CdZeRYIB7yUAXXsrhy7Oe29LvsBd4KZjRX+BuwD4BQ7Z732UD7qd/MGEypf97S4AcLsDY9xX+Re4THfES7bMBa5OTdxPOcSwvgJjNKwJ+wpAzP4W1BGph1zD/QTqeIAwDO4fAsADYsLgEHquhmwoWW0OYHCkg61JsOqKBAOuE4DBeuUwyHnXW/IFriAvHStaaAqAXyoalIvq3v4wQeXL/oYI9GQIMMZhyr/AZTrXiPuC8nWg8heTkeQDGSPf42ECsHCQcn3gOgI1zHANDxSo43Bh6DooBFrDY0LXwfTcIWSHkh2WA+g63cHWJFiHFwkGfLgAdB2hHLo47yMsga6ivHSsaKEpAg6nI5WLar0/TFD5sr+DBXpyMDDGo5RDV6ZzjbgvKF9HK4cu1jFkjHyPjxKAhWOU6wPXEahhhmt4tEAdjxWGrmNCoHVsTOg6jp47nuwEshNzAF1nONiaBOukIsGATxKArpOVQxfnfbIl0FWcl44VLTTFwOF0inJRPcIfJqh82d9xAj05DhjjqcqhK9O5RtwXlK8RyqGLdQwZI9/jUwVg4TTl+sB1BGqY4RqOEKjjSGHoOi0EWiNjQtfp9NwZZGeSjcoBdJ3pYGsSrLOKBAM+SwC6zlYOXZz32SsIurxky5zjpmNF/12zc4B/1wzZ73OUD7qT/cGEypf9nS4AcKcDYzxXGOAQZznqjnjJljnH1amJ5ymHGNZXYIyGNeFcAYg534I6IvWQa3ieQB0vEIbB80MAeEFMGLyQnhtNdhHZxTmAwVEOtibBuqRIMOBLBGDwUuUwyHlfaskXuDZ56VjRQtMG+KXiMuWierY/TFD5sr8LBXpyITDGy5V/gct0rhH3BeXrCuUvJqxjyBj5Hl8uAAtjlOsD1xGoYYZreIVAHa8Uhq4xIdC6MiZ0XUXPXU12Ddm1OYCusxxsTYJ1XZFgwNcJQNf1yqGL877eki9wZ7npWNFf4M4CfoFD9vsG5YPuUn8wofJlf1cJANxVwBhvVP4FLtMd8ZItc5arUxPHKocY1ldgjIY14UYBiLnJgjoi9ZBrOFagjjcLw+BNIQC8OSYMjqPnbiG7ley2HMDg2Q62JsEaXyQY8HgBGLxdOQxy3rdbAoOj3HSsaBgcBYRBZL/vUA6D1/uDCZUv+xsnAIPjgDHeqRwGM90RL9kyo1ydmniX9i/e5AMYo2FNuFMAYiZYUEekHnIN7xKo493CMDghBIB3x4TBe+i5e8nuI7s/BzB4joOtSbAeKBIM+AEBGHxQOQxy3g9a8nNsx7x0rGih6Qj82WqiclG93R8mqHzZ3z0CPbkHGONDyn+OzXSuEfcF5eth5S8mrGPIGPkePyQAC48o1weuI1DDDNfwYYE6ThKGrkdCoDUpJnQ9Ss89RvY42eQcQNe5DrYmwXqiSDDgJwSg60nl0MV5P2nJF7gz3HSs6C9wZwC/wCH7/ZTyQfegP5hQ+bK/RwUA7lFgjFOUf4HLdEe8ZMuc4erUxKnKIYb1FRijYU2YIgAxT1tQR6Qecg2nCtTxGWEYfDoEgM/EhMFn6blpZM+RPZ8DGDzPwdYkWC8UCQb8ggAMTlcOg5z3dEu+wHXLS8eKFppuwC8VLyoX1Sf9YYLKl/09K9CTZ4ExvqT8C1ymc424LyhfLyt/MWEdQ8bI9/glAVh4Rbk+cB2BGma4hi8L1HGGMHS9EgKtGTGh61V6bibZa2Sv5wC6znewNQnWrCLBgGcJQNcbyqGL837Dki9wI910rOgvcCOBX+CQ/X5T+aCb7g8mVL7s71UBgHsVGONbyr/AZbojXrJlRro6NfFt5RDD+gqM0bAmvCUAMbMtqCNSD7mGbwvU8R1hGJwdAsB3YsLgu/Tce2Tvk83JAQxe4GBrEqwPigQD/kAABj9UDoOc94eWwOBpbjpWNAyeBoRBZL8/Ug6Db/iDCZUv+3tXAAbfBcY4VzkMZrojXrJlTnN1auLHyiGG9RUYo2FNmCsAMfMsqCNSD7mGHwvU8RNhGJwXAsBPYsLgp/TcZ2Sfk32RAxi80MHWJFhfFgkG/KUADH6lHAY5768sgcERbjpWNAyOAMIgst9fK4fBD/3BhMqX/X0qAIOfAmP8RjkMZrojXrJlRrg6NfFb5RDD+gqM0bAmfCMAMd9ZUEekHnINvxWo4/fCMPhdCAC/jwmD8+m5H8h+JFuQAxgc7WBrEqyfigQD/kkABn9WDoOc98+WwOCpbjpWNAyeCoRBZL8XKofBr/zBhMqX/c0XgMH5wBgXKYfBTHfES7bMqa5OTfxFOcSwvgJjNKwJiwQg5lcL6ojUQ67hLwJ1/E0YBn8NAeBvMWHwd3ruD7I/yRbnAAYvcrA1CdZfRYIB/yUAg38rh0HO+29LYPAUNx0rGgZPAcIgtN/NdMPgz/5gQuXL/n4XgMHfgTG6zWTvCOIs/y0Ag6e4OjUx1Uw3xLC+ppD3mHzxGUSfmzwL6ojUQ65hSqCO+c2w4LM0DHKfAujLbxYPBgvouSZkhWRNm614GLzYwdYkWEXNBAMuaob326yZbhjkvJs1W1JgkF+RQbdmXjpWtNCsCfynG5srF1UexC7wTLK/AoGeFABjbCEMcF6yZTKda8R9QfkqVv5iwjqGjJHvcQsBWGipXB+4jkANM1zDYoE6thKGrpYh0GoVE7pa03OrkLUha5sD6LrEwdYkWO2aCQbcTgC62iuHLs67vSXQtU5eOla00KwDHE4dlItqM3+YoPJlf60FetIaGOOqyqEr07lG3BeUr47KoYt1DBkj3+NVBWChk3J94DoCNcxwDTsK1LGzMHR1CoFW55jQ1YWe60rWjax7DqDrUgdbk2D1aCYYcA8B6OqpHLo4754rCLq8ZMuc6KZjRf/seSLwZ09kv3spH3Tt/cGEypf9dREAuC7AGFdT/rNnpjviJVvmRFenJvZWDjGsr8AYDWvCagIQs7oFdUTqIdewt0Ad1xCGwdVDALhGTBhck55bi6wP2do5gMHLHGxNgrVOM8GA1xGAwXWVwyDnva4lMHiCm44VDYMnAGEQ2e/1lMNgT38wofJlf2tK/KwNjHF95TCY6Y54yZY5wdWpiRsohxjWV2CMhjVhfQGI2dCCOiL1kGu4gUAdPWEY3DAEgF5MGDT0XAlZKVlZDmDwcgdbk2CVNxMMuFwABiuUwyDnXWHJz7FeXjpWtNB4wJ+tKpWL6rr+MEHly/6MQE8MMMYq5T/HZjrXiPuC8lWt/MWEdQwZI9/jKgFY6KtcH7iOQA0zXMNqgTpuJAxdfUOgtVFM6NqYntuEbFOyzXIAXVc42JoEa/NmkgELQNcWyqGL897CEugqy0vHihaaMuBw6qdcVCv8YYLKl/1tLNCTjYExbqkcujKda8R9QfnaSjl0sY4hY+R7vKUALPRXrg9cR6CGGa7hVgJ13FoYuvqHQGvrmNC1DT03gGxbsu1yAF1jHGxNgrV9M8GAtxeAroHKoYvzHmgJdFXlpWNFC00VcDjtoFxUt/CHCSpf9reNQE+2Aca4o3LoynSuEfcF5Wsn5dDFOoaMke/xjgKwMEi5PnAdgRpmuIY7CdRxZ2HoGhQCrZ1jQtcu9NyuZLuR7Z4D6LrSwdYkWHs0Ewx4DwHo2lM5dHHee1oCXRvnpWOFf1UBDqfBykV1oD9MUPmyv10EerILMMa9lENXpnONuC8oX3srhy7WMWSMfI/3EoCFfZTrA9cRqGGGa7i3QB33FYaufUKgtW9M6NqPntuf7ACyITmArqscbE2CVdNMMOAaAegaqhy6OO+hlkDX5nnpWNFCszlwONUqF9U9/WGCypf97SfQk/2AMdYph65M5xpxX1C+6pVDF+sYMka+x3UCsNCgXB+4jkANM1zDeoE6DhOGroYQaA2LCV0H0nMHkQ0nOzgH0HW1g61JsA5pJhjwIQLQdahy6OK8D11B0OUlW+YoNx0r+p+qPAr4T1Ui+32Y8kE31B9MqHzZ34ECAHcgMMbDhQEOcZaj7oiXbJmjXJ2aeIRyiGF9BcZoWBMOF4CYIy2oI1IPuYZHCNTxKGEYPDIEgEfFhMGj6bljyI4lOy4HMHiNg61JsI5vJhjw8QIweIJyGOS8T7DkC1z/vHSsaKHpD/xScaJyUT3UHyaofNnf0QI9ORoY40nKv8BlOteI+4LydbLyFxPWMWSMfI9PEoCFU5TrA9cRqGGGa3iyQB1PFYauU0KgdWpM6BpBz51GNpLs9BxA17UOtibBOqOZYMBnCEDXmcqhi/M+05IvcEe46VjRX+COAH6BQ/Z7lPJBd4I/mFD5sr8RAgA3AhjjWcq/wGW6I16yZY5wdWri2cohhvUVGKNhTThLAGLOsaCOSD3kGp4tUMdzhWHwnBAAnhsTBs+j584nu4DswhzA4HUOtibBGt1MMODRAjB4kXIY5LwvsgQGD3fTsaJh8HAgDCL7fbFyGDzTH0yofNnfeQIweB4wxkuUw2CmO+IlW+ZwV6cmXqocYlhfgTEa1oRLBCDmMgvqiNRDruGlAnW8XBgGLwsB4OUxYfAKem4M2ZVkV+UABq93sDUJ1tXNBAO+WgAGr1EOg5z3NZbA4GFuOlY0DB4GhEFkv69VDoMX+YMJlS/7u0IABq8AxnidchjMdEe8ZMsc5urUxOuVQwzrKzBGw5pwnQDE3GBBHZF6yDW8XqCONwrD4A0hALwxJgyOpeduIruZbFwOYPAGB1uTYN3STDDgWwRg8FblMMh532oJDB7qpmNFw+ChQBhE9vs27X8fyh9MqHzZ31gBGBwLjHG8chjMdEe8ZMsc6urUxNuVQwzrKzBGw5owXgBi7rCgjkg95BreLlDHO4Vh8I4QAN4ZEwbvoucmkN1Ndk8OYPBGB1uTYN3bTDDgewVg8D7lMMh537eCYDDxf+BuXjpWtNDsAPwL7fcrF9Vb/WGCypf93SXQk7uAMT4gDHBesmUynWvEfUH5elD5iwnrGDJGvscPCMDCROX6wHUEapjhGj4oUMeHhKFrYgi0HooJXQ/Tc4+QTSJ7NAfQNdbB1iRYjzUTDPgxAeh6XDl0cd6PW/IF7mA3HSv6C9zBwC9wyH5PVj7o7vMHEypf9vewAMA9DIzxCeVf4DLdES/ZMge7OjXxSeUQw/oKjNGwJjwhADFPWVBHpB5yDZ8UqOMUYRh8KgSAU2LC4FR67mmyZ8iezQEM3uRgaxKsac0EA54mAIPPKYdBzvs5S2BwuJuOFQ2Dw4EwiOz388ph8HF/MKHyZX9TBWBwKjDGF5TDYKY74iVbZrirUxOnK4eYm8gHMEbDmvCCAMS8aEEdkXrINZwuUMeXhGHwxRAAvhQTBl+m514hm0H2ag5g8GYHW5NgzWwmGPBMARh8TTkMct6vWfJz7K556VjRQrMr8Ger15WL6nP+MEHly/5eFujJy8AYZyn/OTbTuUbcF5SvN5S/mLCOIWPkezxLABbeVK4PXEeghhmu4RsCdXxLGLreDIHWWzGh6216bjbZO2Tv5gC6xjnYmgTrvWaCAb8nAF3vK4cuzvt9S77AHeimY0V/gTsQ+AUO2e85ygfda/5gQuXL/t4WALi3gTF+oPwLXKY74iVb5kBXpyZ+qBxiWF+BMRrWhA8EIOYjC+qI1EOu4YcCdZwrDIMfhQBwbkwY/Jiem0f2CdmnOYDBWxxsTYL1WTPBgD8TgMHPlcMg5/25JTA4zE3HiobBYUAYRPb7C+Uw+L4/mFD5sr+PBWDwY2CMXyqHwUx3xEu2zDBXpyZ+pRxiWF+BMRrWhC8FIOZrC+qI1EOu4VcCdfxGGAa/DgHgNzFh8Ft67juy78nm5wAGb3WwNQnWD80EA/5BAAZ/VA6DnPePlsBgg5uOFQ2DDUAYRPZ7gXIY/NwfTKh82d+3AjD4LTDGn5TDYKY74iVbpsHVqYk/K4cY1ldgjIY14ScBiFloQR2Resg1/FmgjouEYXBhCAAXxYTBX+i5X8l+I/s9BzB4m4OtSbD+aCYY8B8CMPinchjkvP+0BAbr3XSsaBisB8Igst+LlcPgj/5gQuXL/n4RgMFfgDH+pRwGM90RL9ky9a5OTfxbOcSwvgJjNKwJfwlAjNNcfx2Resg1/Fugjm5zLPgsDYPcpwD63ObxYDBFz+WR5ZMVNF/xMDjewdYkWE2aCwbMztF+C5vrhkHOu7D5kgKD/IoMun3y0rGihWYf4F9ob6pcVP/0hwkqX/aXEuhJCnhviprLnmsv2TKZzjXivqB8NcPVUOTFhHUMGSPf46LmeA1rrlwfuI5ADTNcw2YCdWwhDF3NQ6DVIiZ0FdNzLclakbXOAXTd7mBrEqxVmgsGvIoAdLVRDl2cdxtLoOuAvHSsaKE5ADic2ioX1UJ/mKDyZX/FAj0pBsbYTjl0ZTrXiPuC8tVeOXSxjiFj5HvcTgAWOijXB64jUMMM17C9QB1XFYauDiHQWjUmdHWk5zqRdSbrkgPousPB1iRYXZsLBtxVALq6KYcuzrubJdBVm5eOFS00tcDh1F25qLbxhwkqX/bXUaAnHYEx9lAOXZnONeK+oHz1VA5drGPIGPke9xCAhV7K9YHrCNQwwzXsKVDH1YShq1cItFaLCV296bnVydYgWzMH0HWng61JsNZqLhjwWgLQ1Uc5dHHefSyBrmF56VjRQjMMOJzWVi6q3fxhgsqX/fUW6ElvYIzrKIeuTOcacV9QvtZVDl2sY8gY+R6vIwAL6ynXB64jUMMM13BdgTquLwxd64VAa/2Y0LUBPbchmUdmcgBddznYmgSrpLlgwCUC0FWqHLo479IVBF1esmWGuOlY0X/BfwjwL/gj+12mfND18QcTKl/2t4EAwG0AjLFcGOAQZznqjnjJlhni6tTECuUQw/oKjNGwJpQLQEylBXVE6iHXsEKgjlXCMFgZAsCqmDBYTc/1JduIbOMcwOAEB1uTYG3SXDDgTQRgcFPlMMh5b2oJDB7gpmNFw+ABQBhE9nsz5TBY6g8mVL7sr1oABquBMW6uHAYz3REv2TIHuDo1cQvlEMP6CozR/E8TBCCmnwV1ROoh13ALgTpuKQyD/UIAuGVMGNyKnutPtjXZNjmAwbsdbE2CNaC5YMADBGBwW+UwyHlva8nPsYfmpWNFC82hwJ+ttlMuqpv6wwSVL/vbSqAnWwFj3F75z7GZzjXivqB8DVT+YsI6hoyR7/H2ArCwg3J94DoCNcxwDQcK1HFHYejaIQRaO8aErp3ouUFkO5PtkgPousfB1iRYuzYXDHhXAejaTTl0cd67WQJdR+alY0ULzZHA4bS7clHd1h8mqHzZ304CPdkJGOMeyqEr07lG3BeUrz2VQxfrGDJGvsd7CMDCYOX6wHUEapjhGu4pUMe9hKFrcAi09ooJXXvTc/uQ7Uu2Xw6g614HW5Ng7d9cMOD9BaDrAOXQxXkfYMnPnvu66VjRP3vuC/zZE9nvIcoH3W7+YELly/72FgC4vYEx1ij/2TPTHfGSLbOvq1MThyqHGNZXYIyGNaFGAGJqLagjUg+5hkMF6lgnDIO1IQCsiwmD9fRcA9kwsgNzAIP3OdiaBOug5oIBHyQAg8OVwyDnPdySL3DH5aVjRQvNccAvFQcrF9UD/GGCypf91Qv0pB4Y4yHKv8BlOteI+4LydajyFxPWMWSMfI8PEYCFw5TrA9cRqGGGa3ioQB0PF4auw0KgdXhM6DqCnjuS7Ciyo3MAXfc72JoE65jmggEfIwBdxyqHLs77WEug66S8dKxooTkJOJyOUy6qw/1hgsqX/R0h0JMjgDEerxy6Mp1rxH1B+TpBOXSxjiFj5Ht8vAAsnKhcH7iOQA0zXMMTBOp4kjB0nRgCrZNiQtfJ9NwpZKeSjcgBdD3gYGsSrNOaCwZ8mgB0jVQOXZz3SEuga0ReOla00IwADqfTlYvqsf4wQeXL/k4W6MnJwBjPUA5dmc414r6gfJ2pHLpYx5Ax8j0+QwAWRinXB64jUMMM1/BMgTqeJQxdo0KgdVZM6DqbnjuH7Fyy83IAXQ862JoE6/zmggGfLwBdFyiHLs77ghUEXV6yZQa76VjRf9dsMPDvmiH7faHyQTfSH0yofNnf2QIAdzYwxtHCAIc4y1F3xEu2zGBXpyZepBxiWF+BMRrWhNECEHOxBXVE6iHX8CKBOl4iDIMXhwDwkpgweCk9dxnZ5WRX5AAGJzrYmgRrTHPBgMcIwOCVymGQ877SEhjc003HiobBPYEwiOz3Vcph8AJ/MKHyZX+XCsDgpcAYr1YOg5nuiJdsmT1dnZp4jXKIYX0FxmhYE64WgJhrLagjUg+5htcI1PE6YRi8NgSA18WEwevpuRvIbiQbmwMYfMjB1iRYNzUXDPgmARi8WTkMct43W/Jz7Ki8dKxooRkF/NlqnHJRvdIfJqh82d/1Aj25HhjjLcp/js10rhH3BeXrVuUvJqxjyBj5Ht8iAAu3KdcHriNQwwzX8FaBOo4Xhq7bQqA1PiZ03U7P3UF2J9ldOYCuhx1sTYI1oblgwBMEoOtu5dDFed9tyRe43d10rOgvcLsDv8Ah+32P8kF3sz+YUPmyv9sFAO52YIz3Kv8Cl+mOeMmW2d3VqYn3KYcY1ldgjIY14V4BiLnfgjoi9ZBreJ9AHR8QhsH7QwD4QEwYfJCem0j2ENnDOYDBRxxsTYL1SHPBgB8RgMFJymGQ855kyRe48/LSsaKF5jzgl4pHlYvq3f4wQeXL/h4U6MmDwBgfU/4FLtO5RtwXlK/Hlb+YsI4hY+R7/JgALExWrg9cR6CGGa7h4wJ1fEIYuiaHQOuJmND1JD33FNkUsqk5gK5JDrYmwXq6uWDATwtA1zPKoYvzfsYS6Bqdl44VLTSjgcPpWeWiOskfJqh82d+TAj15EhjjNOXQlelcI+4LytdzyqGLdQwZI9/jaQKw8Lx2fSAfQA0zXMPnBOr4gjB0PR8CrRdiQtd0eu5FspfIXs4BdD3qYGsSrFeaCwb8igB0zVAOXZz3DEug69K8dKxoobkUOJxeVS6qz/jDBJUv+5su0JPpwBhnKoeuTOcacV9Qvl5TDl2sY8gY+R7PFICF15XrA9cRqGGGa/iaQB1nCUPX6yHQmhUTut6g594ke4vs7RxA12MOtibBmt1cMODZAtD1jnLo4rzfWUHQ5SVbZmc3HSv675rtDPy7Zsh+v6t80M3wBxMqX/b3hgDAvQGM8T1hgEOc5ag74iVbZmdXpya+rxxiWF+BMRrWhPcEIGaOBXVE6iHX8H2BOn4gDINzQgD4QUwY/JCe+4hsLtnHOYDBxx1sTYI1r7lgwPMEYPAT5TDIeX9iCQwOctOxomFwEBAGkf3+VDkMvuMPJlS+7O9DARj8EBjjZ8phMNMd8ZItM8jVqYmfK4cY1ldgjIY14TMBiPnCgjoi9ZBr+LlAHb8UhsEvQgD4ZUwY/Iqe+5rsG7JvcwCDkx1sTYL1XXPBgL8TgMHvlcMg5/29JTC4k5uOFQ2DOwFhENnv+cph8BN/MKHyZX9fCcDgV8AYf1AOg5nuiJdsmZ1cnZr4o3KIYX0FxmhYE34QgJgFFtQRqYdcwx8F6viTMAwuCAHgTzFh8Gd6biHZIrJfcgCDTzjYmgTr1+aCAf8qAIO/KYdBzvs3S2BwRzcdKxoGdwTCILLfvyuHwe/9wYTKl/39LACDPwNj/EM5DGa6I16yZXZ0dWrin8ohhvUVGKNhTfhDAGIWW1BHpB5yDf8UqONfwjC4OASAf8WEwb95vregf40s1WLFw+CTjgwM5rXw/yARMDtH+81voRsGOe/8FksKDPIrMuiuyUvHihaaa4B/ob2ghW5R/c0fJqh82d/fAgD3NzDGJi1kz7WXbJlM5xpxX1C+CnE1FHkxYR1Dxsj3uEkLvIY1Va4PXEeghhmuYaFAHYtaYAFjaejiPgVwVdQiHnQ1o+eak7UgK84BdD3lYGsSrJYtBANuKQBdrZRDF+fdagVBl5dsmYFuOlb0F7iBwC9wyH63Vj7o8v3BhMqX/TUTgOpmwBhXEQY4xFmOuiNesmUGujo1sY1yiGF9BcZoWBNWEYCYthbUEamHXMM2AnVsJwyDbUMA2C4mDLan5zqQrUrWMQcwOMXB1iRYnVoIBtxJAAY7K4dBzruzJTC4vZuOFQ2D2wNhENnvLsphsJU/mFD5sr/2AjDYHhhjV+UwmOmOeMmW2d7VqYndlEMM6yswRsOa0FUAYrpbUEekHnINuwnUsYcwDHYPAWCPmDDYk57rRbYaWe8cwOBUB1uTYK3eQjDg1QVgcA3lMMh5r2HJz7Fj89KxooVmLPBnqzWVi2pnf5ig8mV/PQV60hMY41rKf47NdK4R9wXlq4/yF5Op5AMZI9/jtQRgYW3l+sB1BGqY4Rr2EajjOsLQtXYItNaJCV3r0nPrka1PtkEOoOtpB1uTYG3YQjDgDQWgy1MOXZy3Z8kXuG3ddKzoL3DbAr/AIfttlA+6NfzBhMqX/a0rAHDrAmMsUf4FLtMd8ZIts62rUxNLlUMM6yswRsOaUCIAMWUW1BGph1zDUoE6lgvDYFkIAMtjwmAFPVdJVkVWnQMYfMbB1iRYfVsIBtxXAAY3Ug6DnPdGlsDgADcdKxoGBwBhENnvjZXDoOcPJlS+7K9CAAYrgDFuohwGM90RL9kyA1ydmripcohhfQXGaFgTNhGAmM0sqCNSD7mGmwrUcXNhGNwsBICbx4TBLei5fmRbkm2VAxh81sHWJFj9WwgG3F8ABrdWDoOc99aWwOA2bjpWNAxuA4RBZL+3UQ6DG/mDCZUv+9tCAAa3AMY4QDkMZrojXrJltnF1auK2yiGG9RUYo2FNGCAAMdtZUEekHnINtxWo4/bCMLhdCAC3jwmDA+m5Hch2JNspBzA4zcHWJFiDWggGPEgABndWDoOc984rCAaT5j8+Lx0rWmjGA/8O0y7KRXVrf5ig8mV/AwV6MhAY467CAOclWybTuUbcF5Sv3ZS/mLCOIWPke7yrACzsrlwfuI5ADTNcw90E6riHMHTtHgKtPWJC15703GCyvcj2zgF0PedgaxKsfVoIBryPAHTtqxy6OO99LfkC199Nx4r+Atcf+AUO2e/9lA+6nf3BhMqX/e0pAHB7AmPcX/kXuEx3xEu2TH9XpyYeoBxiWF+BMRrWhP0FIGaIBXVE6iHX8ACBOtYIw+CQEADWxITBofRcLVkdWX0OYPB5B1uTYDW0EAy4QQAGhymHQc57mCVf4CbkpWNFC80E4JeKA5WL6r7+MEHly/6GCvRkKDDGg5R/gct0rhH3BeVruPIXE9YxZIx8jw8SgIWDlesD1xGoYYZrOFygjocIQ9fBIdA6JCZ0HUrPHUZ2ONkROYCuFxxsTYJ1ZAvBgI8UgK6jlEMX532UJV/gtnTTsaK/wG0J/AKH7PfRygfdMH8wofJlf4cKANyhwBiPUf4FLtMd8ZIts6WrUxOPVQ4xrK/AGA1rwjECEHOcBXVE6iHX8FiBOh4vDIPHhQDw+JgweAI9dyLZSWQn5wAGpzvYmgTrlBaCAZ8iAIOnKodBzvtUS2Cwn5uOFQ2D/YAwiOz3COUweJQ/mFD5sr8TBGDwBGCMpymHwUx3xEu2TD9XpyaOVA4xrK/AGA1rwmkCEHO6BXVE6iHXcKRAHc8QhsHTQwB4RkwYPJOeG0V2FtnZOYDBFx1sTYJ1TgvBgM8RgMFzlcMg532uJTC4hZuOFQ2DWwBhENnv85TD4Kn+YELly/7OFIDBM4Exnq8cBjPdES/ZMlu4OjXxAuUQw/oKjNGwJpwvADEXWlBHpB5yDS8QqONoYRi8MASAo2PC4EX03MVkl5BdmgMYfMnB1iRYl7UQDPgyARi8XDkMct6XWwKDm7vpWNEwuDkQBpH9vkI5DJ7rDyZUvuzvIgEYvAgY4xjlMJjpjnjJltnc1amJVyqHGNZXYIyGNWGMAMRcZUEdkXrINbxSoI5XC8PgVSEAvDomDF5Dz11Ldh3Z9TmAwZcdbE2CdUMLwYBvEIDBG5XDIOd94wqCwaT5T8xLx4oWmonAv9A+VrmoXu4PE1S+7O8agZ5cA4zxJmGA85Itk+lcI+4LytfNyl9MWMeQMfI9vkkAFsYp1weuI1DDDNfwZoE63iIMXeNCoHVLTOi6lZ67jWw82e05gK5XHGxNgnVHC8GA7xCArjuVQxfnfacl0DUpLx0rWmgmAYfTXcpF9UZ/mKDyZX+3CvTkVmCME5RDV6ZzjbgvKF93K4cu1jFkjHyPJwjAwj3K9YHrCNQwwzW8W6CO9wpD1z0h0Lo3JnTdR8/dT/YA2YM5gK4ZDrYmwZrYQjDgiQLQ9ZBy6OK8H7IEuibnpWNFC81k4HB6WLmo3ukPE1S+7O8+gZ7cB4zxEeXQlelcI+4Lytck5dDFOoaMke/xIwKw8KhyfeA6AjXMcA0nCdTxMWHoejQEWo/FhK7H6bnJZE+QPZkD6HrVwdYkWE+1EAz4KQHomqIcujjvKZZA15S8dKxooZkCHE5TlYvqQ/4wQeXL/h4X6MnjwBifVg5dmc414r6gfD2jHLpYx5Ax8j1+WgAWnlWuD1xHoIYZruEzAnWcJgxdz4ZAa1pM6HqOnnue7AWy6TmArpkOtibBerGFYMAvCkDXS8qhi/N+yRLoejYvHStaaJ4FDqeXlYvqFH+YoPJlf88J9OQ5YIyvKIeuTOcacV9QvmYohy7WMWSMfI9fEYCFV5XrA9cRqGGGazhDoI4zhaHr1RBozYwJXa/Rc6+TzSJ7IwfQ9ZqDrUmw3mwhGPCbAtD1lnLo4rzfWkHQ5SVbpq+bjhX9T1X2Bf5Tlch+v6180L3kDyZUvuzvNQGAew0Y42xhgEOc5ag74iVbpq+rUxPfUQ4xrK/AGA1rwmwBiHnXgjoi9ZBr+I5AHd8ThsF3QwD4XkwYfJ+em0P2AdmHOYDB1x1sTYL1UQvBgD8SgMG5ymGQ855rCQxWu+lY0TBYDYRBZL8/Vg6Db/mDCZUv+3tfAAbfB8Y4TzkMZrojXrJlql2dmviJcohhfQXGaFgT5glAzKcW1BGph1zDTwTq+JkwDH4aAsDPYsLg5/TcF2Rfkn2VAxic5WBrEqyvWwgG/LUADH6jHAY5728sgcEqNx0rGgargDCI7Pe3ymFwrj+YUPmyv88FYPBzYIzfKYfBTHfES7ZMlatTE79XDjGsr8AYDWvCdwIQM9+COiL1kGv4vUAdfxCGwfkhAPwhJgz+SM8tIPuJ7OccwOAbDrYmwVrYQjDghQIwuEg5DHLeiyyBwUo3HSsaBiuBMIjs9y/KYfAbfzCh8mV/PwrA4I/AGH9VDoOZ7oiXbJlKV6cm/qYcYlhfgTEa1oRfBSDmdwvqiNRDruFvAnX8QxgGfw8B4B8xYfBPem4xP0v2dw5g8E0HW5P/W8WCAbNztF+3WDcMct5u8ZL6gvyKDLqX89KxooXmZeBfaE8V6xbVRf4wQeXL/v4UALg/gTHmFcueay/ZMpnONeK+oHzl42oo8mLCOoaMke9xXjFewwqU6wPXEahhhmuYL1DHJsVYwFgaurhPAVw1KY4HXYX0XFOyIrJmxSseut5ysDUJVvNiwYCbC0BXC+XQxXm3sAS6ZualY0ULzUzgcCpWLqquP0xQ+bK/QoGeFAJjbKkcujKda8R9QflqpRy6WMeQMfI9bikAC62V6wPXEahhhmvYSqCOqwhDV+sQaK0SE7ra0HNtydqRtc8BdL3tYGsSrA7FggF3EICuVZVDF+e9qiXQ9UZeOlb4J3XgcOqoXFRb+MMElS/7ayPQkzbAGDsph65M5xpxX1C+OiuHLtYxZIx8jzsJwEIX5frAdQRqmOEadhaoY1dh6OoSAq2uMaGrGz3XnawHWc8cQNdsB1uTYPUqFgy4lwB0raYcujjv1SyBrtl56VjRQjMbOJx6KxfVVf1hgsqX/XUT6Ek3YIyrK4euTOcacV9QvtZQDl2sY8gY+R6vLgALayrXB64jUMMM13ANgTquJQxda4ZAa62Y0NWHnlubbB2ydXMAXe842JoEa71iwYDXE4Cu9ZVDF+e9viXQ9X5eOla00LwPHE4bKBfV1fxhgsqX/fUR6EkfYIwbKoeuTOcacV9Qvjzl0MU6hoyR7/GGArBglOsD1xGoYYZr6AnUsUQYukwItEpiQlcpPVdGVk5WkQPoetfB1iRYlcWCAVcKQFeVcujivKtWEHR5yZYxbjpW9D9VaYD/VCWy39XKB936/mBC5cv+SgUArhQYY19hgEOc5ag74iVbxrg6NXEj5RDD+gqM0bAm9BWAmI0tqCNSD7mGGwnUcRNhGNw4BICbxITBTem5zTgusi1yAIPvOdiaBKtfsWDA/QRgcEvlMMh5b2nJF7i5eelY0UIzF/ilYivlolrlDxNUvuxvU4GebAqMsb/yL3CZzjXivqB8ba38xYR1DBkj3+P+ArCwjXJ94DoCNcxwDbcWqOMAYejaJgRaA2JC17b03HZk25MNzAF0ve9gaxKsHYoFA95BALp2VA5dnPeOlnyB29BNx4r+Arch8Ascst87KR90W/qDCZUv+9tWAOC2BcY4SPkXuEx3xEu2zIauTk3cWTnEsL4CYzSsCYMEIGYXC+qI1EOu4c4CddxVGAZ3CQHgrjFhcDd6bneyPcj2zAEMznGwNQnW4GLBgAcLwOBeymGQ897Lki9wn+WlY0ULzWfALxV7KxfVHf1hgsqX/e0m0JPdgDHuo/wLXKZzjbgvKF/7Kn8xYR1Dxsj3eB8BWNhPuT5wHYEaZriG+wrUcX9h6NovBFr7x4SuA+i5IWQ1ZENzAF0fONiaBKu2WDDgWgHoqlMOXZx3nSXQ9VVeOla00HwFHE71ykV1L3+YoPJlfwcI9OQAYIwNyqEr07lG3BeUr2HKoYt1DBkj3+MGAVg4ULk+cB2BGma4hsME6niQMHQdGAKtg2JC13B67mCyQ8gOzQF0fehgaxKsw4oFAz5MALoOVw5dnPfhlvzsuZ6bjhX9s+d6wJ89kf0+Qvmgq/MHEypf9jdcAOCGA2M8UvnPnpnuiJdsmfVcnZp4lHKIYX0FxmhYE44UgJijLagjUg+5hkcJ1PEYYRg8OgSAx8SEwWPpuePIjic7IQcw+JGDrUmwTiwWDPhEARg8STkMct4nWQKD67rpWNEwuC4QBpH9Plk5DB7uDyZUvuzvWAEYPBYY4ynKYTDTHfGSLbOuq1MTT1UOMayvwBgNa8IpAhAzwoI6IvWQa3iqQB1PE4bBESEAPC0mDI6k504nO4PszBzA4FwHW5NgjSoWDHiUAAyepRwGOe+zLPk5dn5eOla00MwH/mx1tnJRPckfJqh82d9IgZ6MBMZ4jvKfYzOda8R9Qfk6V/mLyVzygYyR7/E5ArBwnnJ94DoCNcxwDc8VqOP5wtB1Xgi0zo8JXRfQcxeSjSa7KAfQ9bGDrUmwLi4WDPhiAei6RDl0cd6XWPIFbm03HSv6C9zawC9wyH5fqnzQneUPJlS+7O8CAYC7ABjjZcq/wGW6I16yZdZ2dWri5cohhvUVGKNhTbhMAGKusKCOSD3kGl4uUMcxwjB4RQgAx8SEwSvpuavIria7JgcwOM/B1iRY1xYLBnytAAxepxwGOe/rLIHBPm46VjQM9gHCILLf1yuHwUv8wYTKl/1dKQCDVwJjvEE5DGa6I16yZfq4OjXxRuUQw/oKjNGwJtwgADFjLagjUg+5hjcK1PEmYRgcGwLAm2LC4M303DiyW8huzQEMfuJgaxKs24oFA75NAAbHK4dBznu8JT/HLsxLx4oWmoXAn61uVy6q1/nDBJUv+7tZoCc3A2O8Q/nPsZnONeK+oHzdqfzFhHUMGSPf4zsEYOEu5frAdQRqmOEa3ilQxwnC0HVXCLQmxISuu+m5e8juJbsvB9D1qYOtSbDuLxYM+H4B6HpAOXRx3g9YAl2/5aVjRQvNb8Dh9KByUR3vDxNUvuzvboGe3A2McaJy6Mp0rhH3BeXrIeXQxTqGjJHv8UQBWHhYuT5wHYEaZriGDwnU8RFh6Ho4BFqPxISuSfTco2SPkT2eA+j6zMHWJFiTiwUDniwAXU8ohy7O+wlLoGtxXjpWtNAsBg6nJ5WL6gP+MEHly/4mCfRkEjDGp5RDV6ZzjbgvKF9TlEMX6xgyRr7HTwnAwlTl+sB1BGqY4RpOEajj08LQNTUEWk/HhK5n6LlnyaaRPZcD6PrcwdYkWM8XCwb8vAB0vaAcujjvFyyBLjc/HStaaNgvKsbpykX1CX+YoPJlf88I9OQZYIwvKoeuTOcacV9Qvl5SDl2sY8gY+R6/KAALLyvXB64jUMMM1/AlgTq+IgxdL4dA65WY0DWDnnuVbCbZazmAri8cbE2C9XqxYMCvC0DXLOXQxXnPsgS6CvLTsaKFpgA4nN5QLqov+MMElS/7myHQkxnAGN9UDl2ZzjXivqB8vaUculjHkDHyPX5TABbeVq4PXEeghhmu4VsCdZwtDF1vh0Brdkzoeoeee5fsPbL3cwBdXzrYmgRrTrFgwHMEoOsD5dDFeX9gCXQV5adjRQtNEXA4fahcVGf5wwSVL/t7R6An7wBj/Eg5dGU614j7gvI1Vzl0sY4hY+R7/JEALHysXB+4jkANM1zDuQJ1nCcMXR+HQGteTOj6hJ77lOwzss9zAF1fOdiaBOuLYsGAvxCAri+VQxfn/eUKgi4v2TK93HSs6P8oi17A/ygLZL+/Uj7oPvAHEypf9veJAMB9Aozxa2GAQ5zlqDviJVuml6tTE79RDjGsr8AYDWvC1wIQ860FdUTqIdfwG4E6ficMg9+GAPC7mDD4PT03n+wHsh9zAINfO9iaBGtBsWDACwRg8CflMMh5/2QJDPZ007GiYbAnEAaR/f5Z+1cPfzCh8mV/3wvA4PfAGBcqh8FMd8RLtkxPV6cmLlIOMayvwBgNa8JCAYj5xYI6IvWQa7hIoI6/CsPgLyEA/DUmDP5Gz/1O9gfZnzmAwW8cbE2CtbhYMODFAjD4l3IY5Lz/sgQGe7jpWNEw2AMIg8h+/60cBn/yBxMqX/b3mwAM/oa8gy11w2CmO+IlW6aHq1MT3Za6IYb1FRijYU3gM4g+NykL6gjVw5bpvqDrmNcSCz5LwyD3KYC+vJbxYDCfnisga0JW2HLFw+C3DrYmwWraUjDgpi0F/t5NS90wyHkXtVxSYJBfkVi7u+lY0TDYHQiDyH43Aw4R9oEW6L/8wYTKl/2xcKHjzAfG2Fw5DGa6I16yZbq7OjWxhXKIYX0FxmhYE5oLQEyxBXVE6iHXsIVAHVsKw2BxCABbxoTBVvRca7JVyNrkAAa/c7A1CVbbloIBtxWAwXbKYZDzbmcJDHZz07GiYbAbEAaR/W6vHAaL/MGEypf9tRKAwVbAGDsoh8FMd8RLtkw3V6cmrqocYlhfgTEa1oQOAhDT0YI6IvWQa7iqQB07CcNgxxAAdooJg53puS5kXcm65QAGv3ewNQlW95aCAXcXgMEeymGQ8+5hCQx2ddOxomGwKxAGkf3uqRwG2/mDCZUv++ssAIOdgTH2Ug6Dme6Il2yZrq5OTVxNOcSwvgJjNKwJvQQgprcFdUTqIddwNYE6ri4Mg71DALh6TBhcg55bk2wtsj45gMH5DrYmwVq7pWDAawvA4DrKYZDzXscSGOzipmNFw2AXIAwi+72uchjs4Q8mVL7sbw0BGFwDGON6ymEw0x3xki3TxdWpiesrhxjWV2CMhjVhPQGI2cCCOiL1kGu4vkAdNxSGwQ1CALhhTBj06DlDVkJWmgMY/MHB1iRYZS0FAy4TgMFy5TDIeZdbAoOd3XSsaBjsDIRBZL8rlMPgOv5gQuXL/jwBGPSAMVYqh8FMd8RLtkxnV6cmVimHGNZXYIyGNaFSAGKqLagjUg+5hlUCdewrDIPVIQDsGxMGN6LnNibbhGzTHMDgjw62JsHarKVgwJsJwODmymHwf42yBAY7uelY0TDYCQiDyH5voRwGy/3BhMqX/W0kAIMbAWPspxwGM90RL9kynVydmrilcohhfQXGaFgT+glAzFYW1BGph1zDLQXq2F8YBrcKAWD/mDC4NT23DdkAsm1zAIMLHGxNgrVdS8GAtxOAwe2VwyDnvb0lMNjRTceKhsGOQBhE9nugchjc3B9MqHzZ39YCMLg1MMYdlMNgpjviJVumo6tTE3dUDjGsr8AYDWvCDgIQs5MFdUTqIddwR4E6DhKGwZ1CADgoJgzuTM/tQrYr2W45gMGfHGxNgrV7S8GAdxeAwT2UwyDnvYclMLiqm44VDYOrAmEQ2e89lcPg9v5gQuXL/nYWgMGdgTEOVg6Dme6Il2yZVV2dmriXcohhfQXGaFgTBgtAzN4W1BGph1zDvQTquI8wDO4dAsB9YsLgvvTcfmT7kx2QAxj82cHWJFhDWgoGPEQABmuUwyDnXWMJDHZw07GiYbADEAaR/R6qHAb38AcTKl/2t68ADO4LjLFWOQxmuiNesmU6uDo1sU45xLC+AmM0rAm1AhBTb0EdkXrINawTqGODMAzWhwCwISYMDqPnDiQ7iGx4DmBwoYOtSbAObikY8MECMHiIchjkvA+xBAbbu+lY0TDYHgiDyH4fqhwGa/zBhMqX/Q0TgMFhwBgPUw6Dme6Il2yZ9q5OTTxcOcSwvgJjNKwJhwlAzBEW1BGph1zDwwXqeKQwDB4RAsAjY8LgUfTc0WTHkB2bAxhc5GBrEqzjWgoGfJwADB6vHAY57+MtgcF2bjpWNAy2A8Igst8nKIfBQ/zBhMqX/R0lAINHAWM8UTkMZrojXrJl2rk6NfEk5RDD+gqM0bAmnCgAMSdbUEekHnINTxKo4ynCMHhyCABPiQmDp9JzI8hOIxuZAxj8xcHWJFintxQM+HQBGDxDOQxy3mdYAoNt3XSsaBhsC4RBZL/PVA6Dx/uDCZUv+ztVAAZPBcY4SjkMZrojXrJl2ro6NfEs5RDD+gqM0bAmjBKAmLMtqCNSD7mGZwnU8RxhGDw7BIDnxITBc+m588jOJ7sgBzD4q4OtSbAubCkY8IUCMDhaOQxy3qMtgcE2bjpWNAy2AcIgst8XKYfBM/zBhMqX/Z0rAIPnAmO8WDkMZrojXrJl2rg6NfES5RDD+gqM0bAmXCwAMZdaUEekHnINLxGo42XCMHhpCAAviwmDl9NzV5CNIbsyBzD4m4OtSbCuaikY8FUCMHi1chjkvK+2BAZXcdOxomFwFSAMIvt9jXIYHO0PJlS+7O9yARi8HBjjtcphMNMd8ZIts4qrUxOvUw4xrK/AGA1rwrUCEHO9BXVE6iHX8DqBOt4gDIPXhwDwhpgweCM9N5bsJrKbcwCDvzvYmgRrXEvBgMcJwOAtymGQ877FEhhs7aZjRcNgayAMIvt9q3IYvNofTKh82d+NAjB4IzDG25TDYKY74iVbprWrUxPHK4cY1ldgjIY14TYBiLndgjoi9ZBrOF6gjncIw+DtIQC8IyYM3knP3UU2gezuHMDgHw62JsG6p6VgwPcIwOC9ymGQ877XEhhs5aZjRcNgKyAMIvt9n3IYvMUfTKh82d+dAjB4JzDG+5XDYKY74iVbppWrUxMfUA4xrK/AGA1rwv0CEPOgBXVE6iHX8AGBOk4UhsEHQwA4MSYMPkTPPUz2CNmkHMDgnw62JsF6tKVgwI8KwOBjymGQ837MEhhs6aZjRcNgSyAMIvv9uHIYvNcfTKh82d9DAjD4EDDGycphMNMd8ZIt09LVqYlPKIcY1ldgjIY1YbIAxDxpQR2Resg1fEKgjk8Jw+CTIQB8KiYMTqHnppI9TfZMDmBwsYOtSbCebSkY8LMCMDhNOQxy3tMsgcFiNx0rGgaLgTCI7PdzymHwMX8wofJlf1MEYHAKMMbnlcNgpjviJVum2NWpiS8ohxjWV2CMhjXheQGImW5BHZF6yDV8QaCOLwrD4PQQAL4YEwZfoudeJnuFbEYOYPAvB1uTYL3aUjDgVwVgcKZyGOS8Z1oCgy3cdKxoGGwBhEFkv19TDoPT/MGEypf9vSQAgy8BY3xdOQxmuiNesmVauDo1cZZyiGF9BcZoWBNeF4CYNyyoI1IPuYazBOr4pjAMvhECwDdjwuBb9NzbZLPJ3skBDP7tYGsSrHdbCgb8rgAMvqccBjnv9yyBweZuOlY0DDYHwiCy3+8rh8GZ/mBC5cv+3hKAwbeAMc5RDoOZ7oiXbJnmrk5N/EA5xLC+AmM0rAlzBCDmQwvqiNRDruEHAnX8SBgGPwwB4EcxYXAuPfcx2TyyT3IAg46LrUmwPm0pGPCnAjD4mXIYZIefWQKDzfxY0TDYDAiDyH5/rhwG3/MHEypf9jdXAAbnAmP8QjkMZrojXrJlmrk6NfFL5RDDDQbGaFgTvhCAmK8sqCNSD7mGXwrU8WthGPwqBIBfx4TBb+i5b8m+I/s+BzDoCsHg/JaCAc8XgMEflMMg5/2DJTBY5MeKhsEiIAwi+/2jchj8zB9MqHzZ3zcCMPgNMMYFymEw0x3xki1T5OrUxJ+UQwzrKzBGw5qwQABifragjkg95Br+JFDHhcIw+HMIABfGhMFF9NwvZL+S/ZYDGEwJweDvLQUD/l0ABv9QDoOc9x+WwGBTP1Y0DDYFwiCy338qh8Ef/MGEypf9LRKAwUXAGBcrh8FMd8RLtkxTV6cm/qUcYlhfgTEa1oTFAhDztwV1ROoh1/AvgTo6rWRh8O8QAPK/VxwYdOm5FFkeWX6rFQ+DeUIwWNBKMGB2jvbbpJVuGOS8m7RaUmCQX5FYC/1Y0TBYCIRBZL8LccIiAoN/+IMJlS/7+59wgeN0gT1p2kr2jiDOctQd8ZItU+jq1MSiVrohhvUVGKNhTWjaSuCvF1hQR6Qecg2LBOrYXBgGm4UAsHlMGGxBzxWTtSRrlQMYzBeCwdatBANuLQCDqyiHQc57lRUEg0nz75OfjhUtNOwXFWMb5aLaxB8mqHzZXwuBnrQAxthWGOC8ZMtkOteI+4Ly1U75iwnrGDJGvsdtBWChvXJ94DoCNcxwDdsJ1LGDMHS1D4FWh5jQtSo915GsE1nnVkv20T1axT+bqFqyv1UF9AeZ86rAfof7vPSC/zU8nC8vFYqzi89sXVstlQD6K4ALPBBd4h/a2mX4Ml0tPRApR+ZAdPMPQnfpA5ECHohuwAPRHTwRmpIVher4f76rSusrq42pqyot96orK0qqKYKKyvJS01BrymtrGuoqq2uqqofW19cOLa2u9kobKqrLK0tqK0orGspqymv+WsqfqalsKK9vqKmpq2woJQcl5TXVpqqh1KutraqrLC0tbaitrRlaSf9ybbXXYMrq6qvM0Nra8pKqhurq0vK6v7D99f514MvLamqqKmoqS2uHVtWUlpWXlNeXDx1aX1dRX1Y6tMaY6qr6qgqvobyhtLrcK6moaqg0dQ1l5dVmaF19mVeydHwlXnVdbcPQhhL6H+WVDdUNFV4ZVaasrtLU1FY01DRUVZbQv2VDbWWZV1nrldUPrSgxNRUlVZW1NbWmpEI635K6hqqh1WVefXlVtVdfRsexsrLeKy+tLG2oqa+orjF1leVl1NPS8noqSpU3tKKiorqssoz6X1JbV/uvfpTU19ZVVdWZ8uqKyqG15aVDq6qoNiX1Xp2pqKqoMJRr7dCKmprakrrShqry+hLKs7K+vmFoSa2ppsMmkW8T3xf/uUuIbrqG/twt9Ofu/p+BcZSg82J/PSjOnmS9lhJBNNnk4+I2PSwdZEBf/xhkq/m96y09yJAHYjXgIOstMMhahOr4f74bB9n/14PM1JaVNZTUlJfQv3uVoWNXU1VKAZTTKaytrxpKp9N4JWVcAPpjlakeOrSupqG8pqSmrqaK5lnVv+Irrampry+tqK8oKymhMeiZalNRWkK5lldX19RX1w+lQ1FLU6uypqq2usSrqSmlQ1Q1tKq6tryB/s0bB3fyfJv6vvjPq4UGdO/Qn3M00EslBvrqFOcaZGsuY6B7yZYpAP59kNXB+v1/Q91d0vsCJw1xhc6SF5VmZM2dtNYXk/Hf9+aytSZbxUl/4mpL1o6sPVkHslXJOpJ1IuvMZ4fPDJ8VPiNkPch6kvXi88bnjHtCtgbZmmRrkfUhW5tsHbJ1ydYjW59sA7INuQZkPGxLuLZkZWTlZBVklWRVZNVkfck2ItuYbBOyTck283u8BVk/si3JtiLrT7Y12TZkA8i2JduObHuygWQ7kO1IthPZILKdyXYh25VsN7LdyfYg25NsMNleZHuT7UO2L9l+ZPuTHUA2hKyGbChZLVkdWT1ZA9kwsgPJDiIbTnYw2SFkh5IdRnY42RFkR5IdRXY02TFkx5IdR3Y82QlkJ5KdRHYy2Slkp5KNIDuNbCTZ6WRnkJ1JNorsLLKzyc4hO5fsPLLzyS4gu5BsNNlFZBeTXUJ2KdllZJeTXUE2huxKsqvIria7huxasuvIrie7gexGsrFkN5HdTDaO7BayW8luIxtPdjvZHWR3kt1FNoHsbrJ7yO4lu4/sfrIHyB4km0j2ENnDZI+QTSJ7lOwxssfJJpM9QfYk2VNkU8imkj1N9gzZs2TTyJ4je57sBbLpZC+SvUT2MtkrZDPIXiWbSfYa2etks8jeIHuT7C2yt8lmk71D9i7Ze2Tvk80h+4DsQ7KPyOaSfUw2j+wTsk/JPiP7nOwLsi/JviL7muwbsm/JviP7nmw+2Q9kP5ItIPuJ7GeyhWSLyH4h+5XsNzL+L9nm/25F/q/U4f8kddY//s9N4gvPd5//ciz/nQj+RB9oAi/WQmbjfGcJ5BeE3gACbl7d/99Fof8/3/3/ntnc/7+9ZMsUhfyi/Vd5ZZXhjzIC8ZcW+T4l6xP4FPDvFfp+thq5xP/SufAq9v/v8Mti8P/DMyX454X4z61D/z+8+od8u0v9a1tH/PtK5kxnojzwny/gn1ZJ24j480O58dpypPN/K8t/X7P0RnO//t19f3kRcbhLxZTnZO65E7HnRvhJLfWsm+HfP5x3nvPvHmSKLaqOTsReVGx5y4gtPyK2pf2m/iOPTP8+4ZiC+hQ7/661u9S/FhU79zU4N/kj//mvb+7vewkWvd783/tRnu+/wPn3OQj/+xcs9Xxv//9uFoo/XIvNs4yzobLGNJTWNNDbYl1dWW1Nm6X8O6F6cp1W8f8c1KvAwdeLV+C/iYz//5uLhTL+Swudf6/w3v/1N/Tv7yz15yCmoqVqDo61xo2IL2+pf8+lYww/s7Rm8Eot9X8v/fN7Xoxnl/73C/9rrSPiW/r/rygi1vBecLaKnX+vpfsSvOsXZPBVGPrXw88XLvWsVA/bRsTkZvj3bi8Tw//dqXYy/r2oO9U+9Od2S+UZPlebg2II/AVnoMD590ot9a8FzzZdKj4XH59ZOpYofQlWcGbahfaCev4/LkEi4NLnDQA=","debug_symbols":"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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use dep::std;\nuse std::hash::poseidon2::Poseidon2::hash;\nuse trees::merkle::MerkleTree;\nuse trees::{sparse_merkle::{SparseMerkleTree, Modifier}, types::{Calculator, MembershipProver, SMT_Creator}};\n\nfn hasher(leaves: [Field; 2]) -> Field {\n    hash(leaves, 2)\n}\n\nfn leaf_hasher(leaves: [Field; 3]) -> Field {\n    hash(leaves, 3)\n}\n\n// fn main(\n//     root: pub Field,\n//     secret: Field,\n//     proposal_id: pub Field,\n//     vote: pub Field,\n//     nullifier_default: pub Field,\n//     leaf: [Field; 2],\n//     siblings: [Field; 254],\n// ) -> pub Field {\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n//     let key = leaf[0];\n//     let value = leaf[1];    \n//     let entry = (key, value);\n//     // let note_commitment = std::hash::pedersen_hash([secret]);\n//     let nullifier = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n\n//     // Calculate and verify root\n//     // tree.membership(entry, key, siblings);\n   \n//     let root_check = tree.calculate_root(entry, key, siblings);\n//     assert(root_check == root);\n\n//     let entry = (leaf[0], leaf[1]);\n//     let calculated_root = tree.calculate_root(entry, leaf[0], siblings);\n//     assert(calculated_root == root);\n\n\n//     // 2. Verify nullifier is correct (prevents double voting)\n//     let expected_nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n//     assert(expected_nullifier == nullifier);\n\n\n//     // 3. Verify vote is valid (e.g., 0 or 1 for yes/no)\n//     // assert(vote == 0 || vote == 1);\n\n//     // Verify nullifier\n//     let computed_nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n//     assert(computed_nullifier == nullifier);\n\n//     // Return the commitment\n//     std::hash::pedersen_hash([root, secret, proposal_id])\n// }\n\n\nfn main(\n    root: pub Field,\n    secret: Field,\n    proposal_id: pub Field,\n    vote: pub Field,\n    nullifier_default: pub Field,\n    leaf: [Field; 2],\n    siblings: [Field; 254],\n) -> pub Field {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n    let key = leaf[0];\n    let value = leaf[1];    \n    let entry = (key, value);\n    // let note_commitment = std::hash::pedersen_hash([secret]);\n    // let nullifier = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n\n    // Calculate and verify root\n    // tree.membership(entry, key, siblings);\n   \n    let root_check = tree.calculate_root(entry, key, siblings);\n    assert(root_check == root);\n\n    // Verify nullifier\n    let computed_nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n    assert(computed_nullifier == nullifier_default);\n\n    // Return the commitment\n    std::hash::pedersen_hash([root, secret, proposal_id])\n}\n\n#[test]\nfn test_valid_sparse_merkle_tree_membership() {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // Create a simple tree structure\n    let key = 12345;\n    let value = 999;\n    let entry = (key, value);\n    \n    // Initialize tree\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n    \n    // Create siblings array with default values\n    let mut siblings = [0; 254];\n    \n    // Calculate leaf hash\n    let leaf_hash = hash3([key, value, 0]);\n    \n    // Calculate the first level sibling\n    siblings[0] = hash3([0, 0, 1]);\n    \n    // Calculate intermediate nodes\n    let mut current_hash = leaf_hash;\n    for i in 0..3 {  // We'll create a small subtree for testing\n        current_hash = hash2([current_hash, siblings[i]]);\n        if i + 1 < 3 {\n            siblings[i + 1] = hash2([0, 0]);  // Default sibling for next level\n        }\n    }\n    \n    // The final hash becomes our root\n    let root = current_hash;\n    \n    // Create vote parameters\n    let secret = 777;\n    let proposal_id = 1;\n    let vote = 1;\n    let leaf = [key, value];\n    \n    // Calculate nullifier\n    let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n    // Execute the main circuit\n    let result = main(\n        root,\n        secret,\n        proposal_id,\n        vote,\n        nullifier,\n        leaf,\n        siblings\n    );\n    \n    // Calculate expected output\n    let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n    assert(result == expected_output);\n}\n\n// #[test]\n// fn test_valid_sparse_merkle_tree_membership() {\n//     // let poseidon2 = std::hash::poseidon2::Poseidon2 {};\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n//     // Let's use a dummy key-value pair\n//     let key = 12345;\n//     let value = 999;\n//     let leaf = [key, value];\n\n//     // Build the SMT\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n//     let entry = (key, value);\n\n//     // NOTE: tree.insert() must happen **outside ZK circuit** (trusted setup)\n//     // let siblings = tree.add(entry, key);\n\n//  let commitment_0 = std::hash::pedersen_hash([1]);\n//     let commitment_1 = std::hash::pedersen_hash([2]);\n    \n//       let commitment_2 = std::hash::pedersen_hash([3]);\n//     let commitment_3 = std::hash::pedersen_hash([4]);\n\n//      let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     let vote = 1;\n//     let secret: Field = 1;\n//     let hash_path = [commitment_1, right_branch];\n//     let leaf = commitment_0;\n//     let mut siblings = [0; 254];\n//     siblings[0] = commitment_1;\n//     siblings[1] = right_branch;\n//     let root = tree.calculate_root(entry, key, siblings);\n\n//     // Create vote identity\n//     let secret = 777;\n//     let proposal_id = 1;\n//     let vote = 1;\n\n//     // Construct the nullifier (public) and return value\n//     let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n//     let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n//     // Now invoke the ZK function\n//     let result = main(\n//         root,\n//         0,\n//         secret,\n//         proposal_id,\n//         vote,\n//         nullifier,\n//         hash_path,\n//         siblings,\n//     );\n\n//     assert(result == expected_output);\n// }\n\n\n\n// // #[test]\n// fn test_valid_build_merkle_tree() {\n//     let commitment_0 = std::hash::pedersen_hash([1]);\n//     let commitment_1 = std::hash::pedersen_hash([2]);\n//     let commitment_2 = std::hash::pedersen_hash([3]);\n//     let commitment_3 = std::hash::pedersen_hash([4]);\n\n//     let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     let proposalId = 0;\n//     let vote = 1;\n//     let secret = 1;\n//     let index = 0;\n//     let hash_path = [commitment_1, right_branch];\n//     let leaf = commitment_0;\n//     let mut siblings = [0; 254];\n//     siblings[0] = commitment_1;\n//     siblings[1] = right_branch;\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n//     // Initialize the tree\n//     // let mut tree = MerkleTree::new(hash2);\n\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n//     let nullifier = main(\n//         root,\n//         index,\n//         hash_path,\n//         secret,\n//         proposalId,\n//         vote,\n//         proposalId,\n//         std::hash::pedersen_hash([secret, proposalId]),\n//         hash_path,\n//         siblings,\n//     );\n\n//     let expected_nullifier = std::hash::pedersen_hash([root, secret, proposalId]);\n\n//     std::println(\"Merkle Tree:\");\n//     std::println([root]);\n//     std::println([left_branch, right_branch]);\n//     std::println([commitment_0, commitment_1, commitment_2, commitment_3]);\n\n//     assert(nullifier == expected_nullifier);\n// }\n\n// fn main(root : pub Field, index : Field, hash_path : [Field; 2], secret: Field, priv_key: Field, proposalId: pub Field, vote: pub u8) -> pub Field {\n//     let note_commitment = std::hash::pedersen([priv_key, secret]);\n//     let nullifier = std::hash::pedersen([root, priv_key, proposalId]);\n\n//     let check_root = std::merkle::compute_merkle_root(note_commitment[0], index, hash_path);\n//     assert(root == check_root);\n\n//     // Originally contrained the vote to avoid front-running,\n//     // but including the vote as a public input is sufficient\n\n//     assert(vote <= 1);\n\n//     nullifier[0]\n// }\n\n// Helpers for getting note_commitments to build the merkle tree.\n// To view: nargo test --show-output\n\n// #[test]\n// fn test_build_merkle_tree() {\n//     let secret = 9;\n//     let commitment_0 = std::hash::pedersen_hash([0, secret]);\n//     let commitment_1 = std::hash::pedersen_hash([1, secret]);\n//     let commitment_2 = std::hash::pedersen_hash([2, secret]);\n//     let commitment_3 = std::hash::pedersen_hash([3, secret]);\n\n//     let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     std::println(\"Merkle Tree:\");\n//     std::println([root]);\n//     std::println([left_branch, right_branch]);\n//     std::println([commitment_0, commitment_1, commitment_2, commitment_3]);\n// }\n\n// #[test]\n// fn test_sparse_merkle_tree() {\n//     // Create hash functions for the tree\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n\n//     // Initialize the tree\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n//     // Create a leaf entry (commitment pair)\n//     let secret = 1;\n//     let value = 100;\n//     let entry = (secret, value);\n\n//     // Create proposal ID and hash path\n//     let proposal_id = 1;\n//     let hash_path = [secret, value];\n\n//     // Create siblings for the proof\n//     let mut siblings = [0; 254];\n\n//     // Calculate note commitment and root\n//     let note_commitment = std::hash::pedersen_hash([secret]);\n//     let root = std::merkle::compute_merkle_root(note_commitment, 0, hash_path);\n\n//     // Calculate nullifier as per main function\n//     let nullifier = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n//     // Test the main function with the same parameters as used in the original test\n//     let result = main(\n//         root, // root\n//         0, // index\n//         hash_path,\n//         secret,\n//         proposal_id,\n//         1, // vote\n//         proposal_id,\n//         nullifier,\n//         hash_path, // leaf\n//         siblings,\n//     );\n\n//     // The expected nullifier should match what we calculated\n//     assert(result == nullifier);\n// }\n","path":"/home/msg-encrypted/Documents/dev/privacy/afk-privacy/circuits/afk_common/src/main.nr"},"67":{"source":"pub use crate::types::{Calculator, MembershipProver, Modifier, NonMembershipProver, SMT_Creator};\n\npub struct SparseMerkleTree<T> {\n    pub root: T,\n    pub leaf_hasher: fn([T; 3]) -> T,\n    pub hasher: fn([T; 2]) -> T,\n}\n\nimpl<T> SMT_Creator<T> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn default(root: T, leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self { root, leaf_hasher, hasher }\n    }\n\n    fn from(root: T, leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::default(root, leaf_hasher, hasher)\n    }\n\n    fn new(leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::from(T::default(), leaf_hasher, hasher)\n    }\n}\n\nimpl<T> MembershipProver<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn membership<let N: u32>(self, entry: (T, T), indexes: Field, hash_path: [T; N]) {\n        // membership proof: the root is calculated based on the entry, the siblings,\n        // and the path determined by the key of entry through consecutive hashing\n        assert(self.calculate_root(entry, indexes, hash_path) == self.root);\n    }\n}\n\nimpl<T> NonMembershipProver<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn non_membership<let N: u32>(self, matching_entry: (T, T), index: Field, siblings: [T; N]) {\n        if (self.root != T::default()) {\n            // non-membership proof: the root is calculated based on the matching_entry, the siblings\n            // and the path that is determined by the key of entry. This makes sure that matching_entry is in fact\n            // a matching entry for entry meaning that it shares the same first bits as path\n            let mut calculated_root = self.calculate_root(matching_entry, index, siblings);\n            assert(calculated_root == self.root);\n        }\n    }\n}\n\nimpl<T> Modifier<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn add<let N: u32>(&mut self, new_entry: (T, T), index: Field, hash_path: [T; N]) {\n        // if the root node is zero the first leaf is added to the tree in which case\n        // the new root equals H(k,v,T::default())\n        // otherwise the correctness of the old root is validated based on the siblings after which\n        // the new root is calculated and returned\n        if (self.root == T::default()) {\n            self.root = (self.leaf_hasher)([new_entry.0, new_entry.1, T::default()]);\n        } else {\n            let (old, new) = self.calculate_two_roots(new_entry, index, hash_path);\n            assert(old == self.root);\n            self.root = new;\n        }\n    }\n\n    fn delete<let N: u32>(&mut self, entry: (T, T), indexes: Field, hash_path: [T; N]) {\n        // proves membership of entry in the old root, then calculates and returns the new root\n        let (new, old) = self.calculate_two_roots(entry, indexes, hash_path);\n\n        assert(old == self.root);\n        self.root = new;\n    }\n\n    fn update<let N: u32>(\n        &mut self,\n        new_value: (T, T),\n        old_value: (T, T),\n        index: Field,\n        hash_path: [T; N],\n    ) {\n        let key = index;\n        // both the old entry and new entry share the same key that is used to calculate the path\n        let path: [u1; N] = key.to_be_bits();\n\n        // old_parent is a container to temporarily store the nodes that ultimately lead to the OLD root\n        let mut old_parent = (self.leaf_hasher)([old_value.0, old_value.1, T::default()]);\n        // new_parent is a container to temporarily store the nodes that ultimately lead to the NEW root\n        let mut new_parent = (self.leaf_hasher)([new_value.0, new_value.1, T::default()]);\n        // starting from the bottom of the tree, for each level it checks whether there is a sibling and if\n        // that is the case, it hashes the two containers with the sibling and updates the containers with the\n        // resulting hashes until the uppermost level is reached aka the root node\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if sibling != T::default() {\n                if path[i] != 0 {\n                    new_parent = (self.hasher)([sibling, new_parent]);\n                    old_parent = (self.hasher)([sibling, old_parent]);\n                } else {\n                    new_parent = (self.hasher)([new_parent, sibling]);\n                    old_parent = (self.hasher)([old_parent, sibling]);\n                }\n            }\n        }\n        assert(old_parent == self.root);\n        self.root = new_parent;\n    }\n}\n\nimpl<T> Calculator<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    /*\n     * Calculates the root for a given tree entry based on the passed array of siblings and the passed path.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @param path The position of the entry in the tree as represented by bits from bottom to top\n     * @returns The calculated root node\n     */\n    fn calculate_root<let N: u32>(self, entry: (T, T), indexes: Field, hash_path: [T; N]) -> T {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n\n        // serves as container for hashes and is initialized to be the leaf node\n        let mut node = (self.leaf_hasher)([entry.0, entry.1, T::default()]);\n        // iterates over the list of siblings until the first sibling is found\n        // arbitrarily assigns the sibling to be the left and the node to be the\n        // right element of the hashing pair unless the path indicates the opposite\n        // order in which case the order is changed. The new hash is stored in the container\n        // until the root node is reached and returned.\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if sibling != T::default() {\n                let mut left = sibling;\n                let mut right = node;\n                if index_bits[i] == 0 {\n                    left = node;\n                    right = sibling;\n                }\n                node = (self.hasher)([left, right]);\n            }\n        }\n        node\n    }\n\n    /*\n     * Calculates two roots for a given leaf entry based on the passed array of siblings: one root\n     * for if the leaf entry was included in the tree and one for if the leaf entry was not included\n     * in the tree. This is useful for efficiently proving the membership of leaf entries for a\n     * tree while simultaneously modifying the tree.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @returns Two root nodes: the first one doesn't include entry, the second does\n     */\n    fn calculate_two_roots<let N: u32>(\n        self,\n        entry: (T, T),\n        indexes: Field,\n        hash_path: [T; N],\n    ) -> (T, T) {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n\n        // root_with_leaf is a container for hashes to derive the root node for the tree that\n        // includes the entry\n        let mut root_with_leaf = (self.leaf_hasher)([entry.0, entry.1, T::default()]);\n        // root_without_leaf is a container for hashes to derive the root node for the tree that\n        // doesn't include the entry\n        let mut root_without_leaf = T::default();\n        // iterate over the levels of the tree from bottom to top\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            // After the first sibling is found, the processes are started to calculate the two root nodes.\n            // The calulcation of the root node that includes the entry is comparable to `calculate_root`.\n            // To calc the root node that doesn't include entry, the first sibling is put into the container\n            // and starting from each SUBSEQUENT iteration it is hashed with its sibling and the resulting hash\n            // again stored in the container until the root is reached\n            if sibling != T::default() {\n                if hash_path[i - 1] == T::default() {\n                    root_without_leaf = hash_path[i];\n                }\n\n                if index_bits[i] != 0 {\n                    root_with_leaf = (self.hasher)([sibling, root_with_leaf]);\n                    if (root_without_leaf != sibling) {\n                        root_without_leaf = (self.hasher)([sibling, root_without_leaf]);\n                    }\n                } else {\n                    root_with_leaf = (self.hasher)([root_with_leaf, sibling]);\n\n                    if (root_without_leaf != sibling) {\n                        root_without_leaf = (self.hasher)([root_without_leaf, sibling]);\n                    }\n                }\n            }\n        }\n\n        (root_without_leaf, root_with_leaf)\n    }\n}\n","path":"/home/msg-encrypted/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/merkle-trees-v0.0.1/packages/merkle-trees/src/sparse_merkle.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_to_radix","directive_invert"]}