{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":2833113969098928749,"abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"proposal_id","type":{"kind":"field"},"visibility":"public"},{"name":"vote","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_default","type":{"kind":"field"},"visibility":"public"},{"name":"leaf","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":254,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3djmXHeWTfhde62Jn55Z9fZTAwZFk2CAiSoJ8BBoLefQ5HbJLD7umCOxTNBVfcGKZUrJMdVR2xtc9Za//tm3//7b/99T//9dvf/8cf/vzNv/yPv33zuz/85td/+fYPv3/909++ef7vf/TnP/7699/905//8us//eWbfzlz/Oqb3/7+31//39l//9U3//Ht7377zb+s/vdfffSlrfb8/mvbbOOHL+7PJ764P619/8X9GefzXzz6re+/eIyxf/rF//NX3zTuuevpH85ds3527v6pc98fvv0dz+fPPds833/tbHv98MW7feKL65n7+y+uZ//4h2znu6MMzlGKc5TJOcriHGVzjnI4R7mco7QHdJYGOguocBuocRuochuocxuodBuodRuodhuodzuodzuodzuodzuodzuodzuodzuodzuodzuodzuodweodweodwfpBgOodweodweodweodweodweodweodwvUuwXq3QL1bpHu7IJ6t0C9W6DeLVDvFqh3C9S7E9S7E9S7E9S7E9S7E9S7E9S7E9S7E9S7E9S7E9S7C9S7C9S7C9S7C9S7C9S7i/RZBlDvLlDvLlDvLlDvblDvblDvblDvblDvblDvblDvbtKHyEC9u0G9u0G9e0C9e0C9e0C9e0C9e0C9e0C9e0C9e0if3gX17gH17gX17gX17gX17gX17gX17gX17gX17gX17iVhEyhuggROPCRy4iGhEw+JnXhA5dseEj3xkPCJh8RPPCSA4iE1MAtdIzUwCl5D0WsofA3Fr6EANhTBhkLYSAxbI0FsjUSxNRLG1kgcWyOBbI1EsjUSytZILFsjwWyNRLM1Es7WSDxbIwFtjUS0NRLS1khMWyNBbY1EtTUS1tZIXFsjgW2NRLY1EtrWSGxbI8FtjUS3NRLe1kh8WyMBbo1EuDUS4tZIjFsjQW6NRLk1EubWSJxbI4FujUS6NRLq1kisWyPBbo1EuzUS7tZIvFsjAW+NRLw1EvLWSMxbI0FvjUS9NRL21kjcWyOBb41EvjUS+tZI7FsjwW+NRL81Ev7WSPxbIwFwjUTANRIC10gMXCNBcI1EwTUSBtdIHFwjgXCNRMI1EgrXSCxcI8FwjUTDNRIO10g8XCMBcY1ExDUSEtdITFwnMXGdxMR1EhPXSUxcf0AN3ElMXCcxcZ3ExHUSE9dJTFwnMXGdxMR1EhPX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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use dep::std;\nuse std::hash::poseidon2::Poseidon2::hash;\nuse trees::merkle::MerkleTree;\nuse trees::{\n    sparse_merkle::{Modifier, SparseMerkleTree},\n    types::{Calculator, MembershipProver, SMT_Creator},\n};\nuse afk_common::verify_vote::{verify_vote};\n\n\nfn main(\n    root: pub Field,\n    index: Field,\n    secret: Field,\n    proposal_id: pub Field,\n    vote: pub Field,\n    nullifier_default: pub Field,\n    leaf: [Field; 2],\n    siblings: [Field; 254],\n) -> pub Field {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // let mut tree = SparseMerkleTree::new(hash3, hash2);\n    // let mut tree = MerkleTree::new(hash2);\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n    let key = leaf[0];\n    let value = leaf[1];\n    let entry = (key, value);\n    let note_commitment = std::hash::pedersen_hash([secret]);\n\n    let root_check = tree.calculate_root(entry, key, siblings);\n    assert(root_check == root);\n\n\n    // tree.add(entry, index, siblings);\n    // // Calculate and verify root\n    // tree.membership(entry, index, siblings);\n\n    // Verify nullifier\n    let computed_nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n    assert(computed_nullifier == nullifier_default);\n\n    let res = verify_vote(root_check, secret, proposal_id, vote, nullifier_default, leaf, siblings);\n\n    // Return the commitment\n    std::hash::pedersen_hash([root, secret, proposal_id])\n\n}\n\n#[test]\nfn test_valid_sparse_merkle_tree_membership() {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // Create a simple tree structure\n    let key = 12345;\n    let value = 999;\n    let entry = (key, value);\n\n    // Initialize tree\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n    // Create siblings array with default values\n    let mut siblings = [0; 254];\n\n    // Calculate leaf hash\n    let leaf_hash = hash3([key, value, 0]);\n\n    // Calculate the first level sibling\n    siblings[0] = hash3([0, 0, 1]);\n\n    // Calculate intermediate nodes\n    let mut current_hash = leaf_hash;\n    for i in 0..3 {\n        // We'll create a small subtree for testing\n        current_hash = hash2([current_hash, siblings[i]]);\n        if i + 1 < 3 {\n            siblings[i + 1] = hash2([0, 0]); // Default sibling for next level\n        }\n    }\n\n    // The final hash becomes our root\n    let root = current_hash;\n\n    // Create vote parameters\n    let secret = 777;\n    let proposal_id = 1;\n    let vote = 1;\n    let leaf = [key, value];\n\n    // Calculate nullifier\n    let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n\n    // Execute the main circuit\n    let result = main(\n        root,\n        0,\n        secret,\n        proposal_id,\n        vote,\n        nullifier,\n        leaf,\n        siblings,\n    );\n\n    // Calculate expected output\n    let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n    assert(result == expected_output);\n}\n\n\n#[test]\nfn test_vote_verification() {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // Create a different tree structure for testing\n    let key = 98765; // Different key\n    let value = 444; // Different value\n    let entry = (key, value);\n\n    // Initialize tree\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n    // Create siblings array with default values\n    let mut siblings = [0; 254];\n\n    // Calculate leaf hash with different values\n    let leaf_hash = hash3([key, value, 0]); // Changed last param to 0 to match tree structure\n\n    // Calculate siblings with different values\n    siblings[0] = hash3([0, 0, 1]); // Match sibling format\n\n    // Calculate intermediate nodes with more levels\n    let mut current_hash = leaf_hash;\n    for i in 0..5 { // Keep consistent depth\n        current_hash = hash2([current_hash, siblings[i]]);\n        if i + 1 < 5 {\n            siblings[i + 1] = hash2([0, 0]); // Use consistent default siblings\n        }\n    }\n\n    // The final hash becomes our root\n    let root = current_hash;\n\n    // Create different vote parameters\n    let secret = 888; // Different secret\n    let proposal_id = 2; // Different proposal\n    let vote = 0; // Different vote\n    let leaf = [key, value];\n\n    // Calculate nullifier\n    let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n\n    // Execute the main circuit\n    let result = main(\n        root,\n        0,\n        secret,\n        proposal_id,\n        vote,\n        nullifier,\n        leaf,\n        siblings,\n    );\n\n    // Calculate expected output\n    let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n    assert(result == expected_output);\n}\n\n// #[test]\n// fn test_valid_sparse_merkle_tree_membership() {\n//     // let poseidon2 = std::hash::poseidon2::Poseidon2 {};\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n//     // Let's use a dummy key-value pair\n//     let key = 12345;\n//     let value = 999;\n//     let leaf = [key, value];\n\n//     // Build the SMT\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n//     let entry = (key, value);\n\n//     // NOTE: tree.insert() must happen **outside ZK circuit** (trusted setup)\n//     // let siblings = tree.add(entry, key);\n\n//  let commitment_0 = std::hash::pedersen_hash([1]);\n//     let commitment_1 = std::hash::pedersen_hash([2]);\n\n//       let commitment_2 = std::hash::pedersen_hash([3]);\n//     let commitment_3 = std::hash::pedersen_hash([4]);\n\n//      let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     let vote = 1;\n//     let secret: Field = 1;\n//     let hash_path = [commitment_1, right_branch];\n//     let leaf = commitment_0;\n//     let mut siblings = [0; 254];\n//     siblings[0] = commitment_1;\n//     siblings[1] = right_branch;\n//     let root = tree.calculate_root(entry, key, siblings);\n\n//     // Create vote identity\n//     let secret = 777;\n//     let proposal_id = 1;\n//     let vote = 1;\n\n//     // Construct the nullifier (public) and return value\n//     let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n//     let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n//     // Now invoke the ZK function\n//     let result = main(\n//         root,\n//         0,\n//         secret,\n//         proposal_id,\n//         vote,\n//         nullifier,\n//         hash_path,\n//         siblings,\n//     );\n\n//     assert(result == expected_output);\n// }\n\n// // #[test]\n// fn test_valid_build_merkle_tree() {\n//     let commitment_0 = std::hash::pedersen_hash([1]);\n//     let commitment_1 = std::hash::pedersen_hash([2]);\n//     let commitment_2 = std::hash::pedersen_hash([3]);\n//     let commitment_3 = std::hash::pedersen_hash([4]);\n\n//     let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     let proposalId = 0;\n//     let vote = 1;\n//     let secret = 1;\n//     let index = 0;\n//     let hash_path = [commitment_1, right_branch];\n//     let leaf = commitment_0;\n//     let mut siblings = [0; 254];\n//     siblings[0] = commitment_1;\n//     siblings[1] = right_branch;\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n//     // Initialize the tree\n//     // let mut tree = MerkleTree::new(hash2);\n\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n//     let nullifier = main(\n//         root,\n//         index,\n//         hash_path,\n//         secret,\n//         proposalId,\n//         vote,\n//         proposalId,\n//         std::hash::pedersen_hash([secret, proposalId]),\n//         hash_path,\n//         siblings,\n//     );\n\n//     let expected_nullifier = std::hash::pedersen_hash([root, secret, proposalId]);\n\n//     std::println(\"Merkle Tree:\");\n//     std::println([root]);\n//     std::println([left_branch, right_branch]);\n//     std::println([commitment_0, commitment_1, commitment_2, commitment_3]);\n\n//     assert(nullifier == expected_nullifier);\n// }\n\n// fn main(root : pub Field, index : Field, hash_path : [Field; 2], secret: Field, priv_key: Field, proposalId: pub Field, vote: pub u8) -> pub Field {\n//     let note_commitment = std::hash::pedersen([priv_key, secret]);\n//     let nullifier = std::hash::pedersen([root, priv_key, proposalId]);\n\n//     let check_root = std::merkle::compute_merkle_root(note_commitment[0], index, hash_path);\n//     assert(root == check_root);\n\n//     // Originally contrained the vote to avoid front-running,\n//     // but including the vote as a public input is sufficient\n\n//     assert(vote <= 1);\n\n//     nullifier[0]\n// }\n\n// Helpers for getting note_commitments to build the merkle tree.\n// To view: nargo test --show-output\n\n// #[test]\n// fn test_build_merkle_tree() {\n//     let secret = 9;\n//     let commitment_0 = std::hash::pedersen_hash([0, secret]);\n//     let commitment_1 = std::hash::pedersen_hash([1, secret]);\n//     let commitment_2 = std::hash::pedersen_hash([2, secret]);\n//     let commitment_3 = std::hash::pedersen_hash([3, secret]);\n\n//     let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n//     let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n//     let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n//     std::println(\"Merkle Tree:\");\n//     std::println([root]);\n//     std::println([left_branch, right_branch]);\n//     std::println([commitment_0, commitment_1, commitment_2, commitment_3]);\n// }\n\n// #[test]\n// fn test_sparse_merkle_tree() {\n//     // Create hash functions for the tree\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n\n//     // Initialize the tree\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n//     // Create a leaf entry (commitment pair)\n//     let secret = 1;\n//     let value = 100;\n//     let entry = (secret, value);\n\n//     // Create proposal ID and hash path\n//     let proposal_id = 1;\n//     let hash_path = [secret, value];\n\n//     // Create siblings for the proof\n//     let mut siblings = [0; 254];\n\n//     // Calculate note commitment and root\n//     let note_commitment = std::hash::pedersen_hash([secret]);\n//     let root = std::merkle::compute_merkle_root(note_commitment, 0, hash_path);\n\n//     // Calculate nullifier as per main function\n//     let nullifier = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n//     // Test the main function with the same parameters as used in the original test\n//     let result = main(\n//         root, // root\n//         0, // index\n//         hash_path,\n//         secret,\n//         proposal_id,\n//         1, // vote\n//         proposal_id,\n//         nullifier,\n//         hash_path, // leaf\n//         siblings,\n//     );\n\n//     // The expected nullifier should match what we calculated\n//     assert(result == nullifier);\n// }\n","path":"/home/msg-encrypted/Documents/dev/privacy/afk-privacy/circuits/cast_vote/src/main.nr"},"67":{"source":"use dep::std;\nuse std::hash::poseidon2::Poseidon2::hash;\nuse trees::merkle::MerkleTree;\nuse trees::{sparse_merkle::{SparseMerkleTree, Modifier}, types::{Calculator, MembershipProver, SMT_Creator}};\n\n// fn main(\n//     root: pub Field,\n//     secret: Field,\n//     proposal_id: pub Field,\n//     vote: pub Field,\n//     nullifier_default: pub Field,\n//     leaf: [Field; 2],\n//     siblings: [Field; 254],\n// ) -> pub Field {\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n//     let key = leaf[0];\n//     let value = leaf[1];    \n//     let entry = (key, value);\n//     // let note_commitment = std::hash::pedersen_hash([secret]);\n//     let nullifier = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n\n//     // Calculate and verify root\n//     // tree.membership(entry, key, siblings);\n   \n//     let root_check = tree.calculate_root(entry, key, siblings);\n//     assert(root_check == root);\n\n//     let entry = (leaf[0], leaf[1]);\n//     let calculated_root = tree.calculate_root(entry, leaf[0], siblings);\n//     assert(calculated_root == root);\n\n\n//     // 2. Verify nullifier is correct (prevents double voting)\n//     let expected_nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n//     assert(expected_nullifier == nullifier);\n\n\n//     // 3. Verify vote is valid (e.g., 0 or 1 for yes/no)\n//     // assert(vote == 0 || vote == 1);\n\n//     // Verify nullifier\n//     let computed_nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n//     assert(computed_nullifier == nullifier);\n\n//     // Return the commitment\n//     std::hash::pedersen_hash([root, secret, proposal_id])\n// }\npub fn verify_vote(\n    root: pub Field,\n    secret: Field,\n    proposal_id: pub Field,\n    vote: pub Field,\n    nullifier_default: pub Field,\n    leaf: [Field; 2],\n    siblings: [Field; 254],\n) -> pub Field {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n    let key = leaf[0];\n    let value = leaf[1];    \n    let entry = (key, value);\n    // let note_commitment = std::hash::pedersen_hash([secret]);\n    // let nullifier = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n\n    // Calculate and verify root\n    // tree.membership(entry, key, siblings);\n   \n    let root_check = tree.calculate_root(entry, key, siblings);\n    assert(root_check == root);\n\n    // Verify nullifier\n    let computed_nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n    assert(computed_nullifier == nullifier_default);\n\n    // Return the commitment\n    std::hash::pedersen_hash([root, secret, proposal_id])\n}\n\n#[test]\nfn test_valid_sparse_merkle_tree_membership() {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // Create a simple tree structure\n    let key = 12345;\n    let value = 999;\n    let entry = (key, value);\n    \n    // Initialize tree\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n    \n    // Create siblings array with default values\n    let mut siblings = [0; 254];\n    \n    // Calculate leaf hash\n    let leaf_hash = hash3([key, value, 0]);\n    \n    // Calculate the first level sibling\n    siblings[0] = hash3([0, 0, 1]);\n    \n    // Calculate intermediate nodes\n    let mut current_hash = leaf_hash;\n    for i in 0..3 {  // We'll create a small subtree for testing\n        current_hash = hash2([current_hash, siblings[i]]);\n        if i + 1 < 3 {\n            siblings[i + 1] = hash2([0, 0]);  // Default sibling for next level\n        }\n    }\n    \n    // The final hash becomes our root\n    let root = current_hash;\n    \n    // Create vote parameters\n    let secret = 777;\n    let proposal_id = 1;\n    let vote = 1;\n    let leaf = [key, value];\n    \n    // Calculate nullifier\n    let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n    // Execute the main circuit\n    let result = verify_vote(\n        root,\n        secret,\n        proposal_id,\n        vote,\n        nullifier,\n        leaf,\n        siblings\n    );\n    \n    // Calculate expected output\n    let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n    assert(result == expected_output);\n}\n\n#[test]\nfn test_sparse_merkle_tree() {\n    // let poseidon2 = std::hash::poseidon2::Poseidon2 {};\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // Let's use a dummy key-value pair\n    let key = 12345;\n    let value = 999;\n    let leaf = [key, value];\n\n    // Build the SMT\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n    let entry = (key, value);\n\n    let entries = [key, value];\n    // NOTE: tree.insert() must happen **outside ZK circuit** (trusted setup)\n    // let siblings = tree.add(entry, key);\n\n let commitment_0 = std::hash::pedersen_hash([1]);\n    let commitment_1 = std::hash::pedersen_hash([2]);\n    \n      let commitment_2 = std::hash::pedersen_hash([3]);\n    let commitment_3 = std::hash::pedersen_hash([4]);\n\n     let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n    let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n    let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n    let vote = 1;\n    let secret: Field = 1;\n    let hash_path = [commitment_1, right_branch];\n    let leaf = commitment_0;\n    let mut siblings = [0; 254];\n    siblings[0] = commitment_1;\n    siblings[1] = right_branch;\n    let root = tree.calculate_root(entry, key, siblings);\n\n    // Create vote identity\n    let secret = 777;\n    let proposal_id = 1;\n    let vote = 1;\n\n    // Construct the nullifier (public) and return value\n    let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n    let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n\n    // Now invoke the ZK function\n    let result = verify_vote(\n        root,\n        secret,\n        proposal_id,\n        vote,\n        nullifier,\n        entries,\n        siblings,\n    );\n\n    assert(result == expected_output);\n}\n\n#[test]\nfn test_vote_verification() {\n    let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n    let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n\n    // Create a different tree structure for testing\n    let key = 98765; // Different key\n    let value = 444; // Different value\n    let entry = (key, value);\n\n    // Initialize tree\n    let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n    // Create siblings array with default values\n    let mut siblings = [0; 254];\n\n    // Calculate leaf hash with different values\n    let leaf_hash = hash3([key, value, 0]); // Changed last param to 0 to match tree structure\n\n    // Calculate siblings with different values\n    siblings[0] = hash3([0, 0, 1]); // Match sibling format\n\n    // Calculate intermediate nodes with more levels\n    let mut current_hash = leaf_hash;\n    for i in 0..5 { // Keep consistent depth\n        current_hash = hash2([current_hash, siblings[i]]);\n        if i + 1 < 5 {\n            siblings[i + 1] = hash2([0, 0]); // Use consistent default siblings\n        }\n    }\n\n    // The final hash becomes our root\n    let root = current_hash;\n\n    // Create different vote parameters\n    let secret = 888; // Different secret\n    let proposal_id = 2; // Different proposal\n    let vote = 0; // Different vote\n    let leaf = [key, value];\n\n    // Calculate nullifier\n    let nullifier = std::hash::pedersen_hash([secret, proposal_id]);\n\n    // Execute the main circuit\n    let result = verify_vote(\n        root,\n        secret,\n        proposal_id,\n        vote,\n        nullifier,\n        leaf,\n        siblings,\n    );\n\n    // Calculate expected output\n    let expected_output = std::hash::pedersen_hash([root, secret, proposal_id]);\n    assert(result == expected_output);\n}\n\n\n// #[test]\n// fn test_sparse_merkle_tree() {\n//     // Create hash functions for the tree\n//     let hash3 = |x: [Field; 3]| -> Field { hash(x, 3) };\n//     let hash2 = |x: [Field; 2]| -> Field { hash(x, 2) };\n\n//     // Initialize the tree\n//     let mut tree = SparseMerkleTree::new(hash3, hash2);\n\n//     // Create a leaf entry (commitment pair)\n//     let secret = 1;\n//     let value = 100;\n//     // Calculate note commitment and root\n//     let key = 235;\n//     let note_commitment = std::hash::pedersen_hash([secret]);\n\n//     let entry = (secret, value);\n\n//     // Create proposal ID and hash path\n//     let proposal_id = 1;\n//     let hash_path = [secret, value];\n\n//     // Create siblings for the proof\n//     let mut siblings = [0; 254];\n\n\n\n//     // let root = std::merkle::compute_merkle_root(note_commitment, 0, hash_path);\n//     let root = tree.calculate_root(entry, key, siblings);\n//     // assert(root_check == root);\n\n//     // Calculate nullifier as per main function\n//     let nullifier = std::hash::pedersen_hash([root, secret, proposal_id]);\n//     let leaf = [key, value];\n//     // Test the main function with the same parameters as used in the original test\n//     let result = verify_vote    (\n//         root, // root\n//         secret,\n//         proposal_id,\n//         1, // vote\n//         nullifier,\n//         leaf,\n//         siblings,\n//     );\n\n//     // The expected nullifier should match what we calculated\n//     assert(result == nullifier);\n// }\n","path":"/home/msg-encrypted/Documents/dev/privacy/afk-privacy/circuits/afk_common/src/verify_vote.nr"},"71":{"source":"pub use crate::types::{Calculator, MembershipProver, Modifier, NonMembershipProver, SMT_Creator};\n\npub struct SparseMerkleTree<T> {\n    pub root: T,\n    pub leaf_hasher: fn([T; 3]) -> T,\n    pub hasher: fn([T; 2]) -> T,\n}\n\nimpl<T> SMT_Creator<T> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn default(root: T, leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self { root, leaf_hasher, hasher }\n    }\n\n    fn from(root: T, leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::default(root, leaf_hasher, hasher)\n    }\n\n    fn new(leaf_hasher: fn([T; 3]) -> T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::from(T::default(), leaf_hasher, hasher)\n    }\n}\n\nimpl<T> MembershipProver<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn membership<let N: u32>(self, entry: (T, T), indexes: Field, hash_path: [T; N]) {\n        // membership proof: the root is calculated based on the entry, the siblings,\n        // and the path determined by the key of entry through consecutive hashing\n        assert(self.calculate_root(entry, indexes, hash_path) == self.root);\n    }\n}\n\nimpl<T> NonMembershipProver<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn non_membership<let N: u32>(self, matching_entry: (T, T), index: Field, siblings: [T; N]) {\n        if (self.root != T::default()) {\n            // non-membership proof: the root is calculated based on the matching_entry, the siblings\n            // and the path that is determined by the key of entry. This makes sure that matching_entry is in fact\n            // a matching entry for entry meaning that it shares the same first bits as path\n            let mut calculated_root = self.calculate_root(matching_entry, index, siblings);\n            assert(calculated_root == self.root);\n        }\n    }\n}\n\nimpl<T> Modifier<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn add<let N: u32>(&mut self, new_entry: (T, T), index: Field, hash_path: [T; N]) {\n        // if the root node is zero the first leaf is added to the tree in which case\n        // the new root equals H(k,v,T::default())\n        // otherwise the correctness of the old root is validated based on the siblings after which\n        // the new root is calculated and returned\n        if (self.root == T::default()) {\n            self.root = (self.leaf_hasher)([new_entry.0, new_entry.1, T::default()]);\n        } else {\n            let (old, new) = self.calculate_two_roots(new_entry, index, hash_path);\n            assert(old == self.root);\n            self.root = new;\n        }\n    }\n\n    fn delete<let N: u32>(&mut self, entry: (T, T), indexes: Field, hash_path: [T; N]) {\n        // proves membership of entry in the old root, then calculates and returns the new root\n        let (new, old) = self.calculate_two_roots(entry, indexes, hash_path);\n\n        assert(old == self.root);\n        self.root = new;\n    }\n\n    fn update<let N: u32>(\n        &mut self,\n        new_value: (T, T),\n        old_value: (T, T),\n        index: Field,\n        hash_path: [T; N],\n    ) {\n        let key = index;\n        // both the old entry and new entry share the same key that is used to calculate the path\n        let path: [u1; N] = key.to_be_bits();\n\n        // old_parent is a container to temporarily store the nodes that ultimately lead to the OLD root\n        let mut old_parent = (self.leaf_hasher)([old_value.0, old_value.1, T::default()]);\n        // new_parent is a container to temporarily store the nodes that ultimately lead to the NEW root\n        let mut new_parent = (self.leaf_hasher)([new_value.0, new_value.1, T::default()]);\n        // starting from the bottom of the tree, for each level it checks whether there is a sibling and if\n        // that is the case, it hashes the two containers with the sibling and updates the containers with the\n        // resulting hashes until the uppermost level is reached aka the root node\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if sibling != T::default() {\n                if path[i] != 0 {\n                    new_parent = (self.hasher)([sibling, new_parent]);\n                    old_parent = (self.hasher)([sibling, old_parent]);\n                } else {\n                    new_parent = (self.hasher)([new_parent, sibling]);\n                    old_parent = (self.hasher)([old_parent, sibling]);\n                }\n            }\n        }\n        assert(old_parent == self.root);\n        self.root = new_parent;\n    }\n}\n\nimpl<T> Calculator<T, (T, T)> for SparseMerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    /*\n     * Calculates the root for a given tree entry based on the passed array of siblings and the passed path.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @param path The position of the entry in the tree as represented by bits from bottom to top\n     * @returns The calculated root node\n     */\n    fn calculate_root<let N: u32>(self, entry: (T, T), indexes: Field, hash_path: [T; N]) -> T {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n\n        // serves as container for hashes and is initialized to be the leaf node\n        let mut node = (self.leaf_hasher)([entry.0, entry.1, T::default()]);\n        // iterates over the list of siblings until the first sibling is found\n        // arbitrarily assigns the sibling to be the left and the node to be the\n        // right element of the hashing pair unless the path indicates the opposite\n        // order in which case the order is changed. The new hash is stored in the container\n        // until the root node is reached and returned.\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if sibling != T::default() {\n                let mut left = sibling;\n                let mut right = node;\n                if index_bits[i] == 0 {\n                    left = node;\n                    right = sibling;\n                }\n                node = (self.hasher)([left, right]);\n            }\n        }\n        node\n    }\n\n    /*\n     * Calculates two roots for a given leaf entry based on the passed array of siblings: one root\n     * for if the leaf entry was included in the tree and one for if the leaf entry was not included\n     * in the tree. This is useful for efficiently proving the membership of leaf entries for a\n     * tree while simultaneously modifying the tree.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @returns Two root nodes: the first one doesn't include entry, the second does\n     */\n    fn calculate_two_roots<let N: u32>(\n        self,\n        entry: (T, T),\n        indexes: Field,\n        hash_path: [T; N],\n    ) -> (T, T) {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n\n        // root_with_leaf is a container for hashes to derive the root node for the tree that\n        // includes the entry\n        let mut root_with_leaf = (self.leaf_hasher)([entry.0, entry.1, T::default()]);\n        // root_without_leaf is a container for hashes to derive the root node for the tree that\n        // doesn't include the entry\n        let mut root_without_leaf = T::default();\n        // iterate over the levels of the tree from bottom to top\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            // After the first sibling is found, the processes are started to calculate the two root nodes.\n            // The calulcation of the root node that includes the entry is comparable to `calculate_root`.\n            // To calc the root node that doesn't include entry, the first sibling is put into the container\n            // and starting from each SUBSEQUENT iteration it is hashed with its sibling and the resulting hash\n            // again stored in the container until the root is reached\n            if sibling != T::default() {\n                if hash_path[i - 1] == T::default() {\n                    root_without_leaf = hash_path[i];\n                }\n\n                if index_bits[i] != 0 {\n                    root_with_leaf = (self.hasher)([sibling, root_with_leaf]);\n                    if (root_without_leaf != sibling) {\n                        root_without_leaf = (self.hasher)([sibling, root_without_leaf]);\n                    }\n                } else {\n                    root_with_leaf = (self.hasher)([root_with_leaf, sibling]);\n\n                    if (root_without_leaf != sibling) {\n                        root_without_leaf = (self.hasher)([root_without_leaf, sibling]);\n                    }\n                }\n            }\n        }\n\n        (root_without_leaf, root_with_leaf)\n    }\n}\n","path":"/home/msg-encrypted/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/merkle-trees-v0.0.1/packages/merkle-trees/src/sparse_merkle.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_to_radix","directive_invert"]}